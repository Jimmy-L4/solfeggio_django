define('modules/Comments/src/CommentsModel', [], function () {
  /**
   * CommentsModel
   * @exports AudioComments/CommentsModel
   * @param {ServerComments} serverComments communicates with the server. Does not make really part of LeadsheetJS, it is provided by the server part, and it is hosted in it. In our case, in LSDB server. All methods work also without this Object, this way it works as an example without saving comment to a server part.
   */
  function CommentsModel(serverComments, userSession) {
    this.serverComments = serverComments
    this.comments = {}
    this.nextId = 0 //auto increment id used if there is no server
  }

  /**
   * gets the comments from the server. If there is no server, just runs the callback function
   * @param  {Function} callback [description]
   */
  CommentsModel.prototype.getComments = function (type, callback) {
    function getCommentsByType(type) {
      var types = type === 'audio' ? [type] : ['notes', 'chords']
      var typeComments = []
      for (var i in self.comments) {
        if (types.indexOf(self.comments[i].type) != -1) {
          typeComments.push(self.comments[i])
        }
      }
      return typeComments
    }

    var self = this
    if (this.serverComments) {
      this.serverComments.getComments(function (comments) {
        for (var i = 0; i < comments.length; i++) {
          self.addComment(comments[i])
        }
        callback(getCommentsByType(type))
      })
    } else {
      callback(getCommentsByType(type))
    }
  }

  CommentsModel.prototype.getComment = function (id) {
    return this.comments[id]
  }
  /**
   * if comment.id is defined, it means there exists a server part, so id is provided by the server (in our case it is a MongoDB id).
   * But if comment.id is not defined we just use our own auto_increment nextId
   * @param {Object} comment
   * @param {String} id
   */
  CommentsModel.prototype.addComment = function (comment) {
    var id
    if (comment.id !== undefined) {
      id = comment.id
      this.comments[id] = comment
    } else {
      id = this.nextId.toString() //ids will always be strings so that they work well for
      comment.id = id
      this.nextId++
      this.comments[id] = comment
    }
    return id
  }

  CommentsModel.prototype.saveComment = function (comment, callback) {
    var id,
      self = this

    if (this.serverComments) {
      this.serverComments.saveComment(comment, function (data) {
        comment = data
        id = self.addComment(comment)
        if (callback) callback(id)
      })
    } else {
      id = self.addComment(comment)
      if (callback) callback(id)
    }
    return id
  }

  CommentsModel.prototype.updateComment = function (id, text, callback) {
    var self = this
    this.comments[id].text = text
    var comment = this.comments[id]
    if (this.serverComments) {
      this.serverComments.saveComment(comment, function () {
        callback()
      })
    } else {
      callback()
    }
  }

  CommentsModel.prototype.removeComment = function (id, callback) {
    var self = this
    if (this.serverComments) {
      this.serverComments.removeComment(id, function () {
        delete self.comments[id]
        callback()
      })
    } else {
      delete this.comments[id]
      callback()
    }
  }
  /**
   * When clicked on canvasLayer, comments are accessed by orderedIndex, instead of by their id.
   * Example to understand difference between id and orderedIndex: If we add comment 0, comment 1, both id and orderedIndexes will be [0,1]
   * If we then add comment 2 and remove comment 0, ids will be [1,2] whereas orderedIndexes will be [0,1]
   *
   * @param  {Integer}	commentId  it's an auto_increment id (0, 1, 2..etc)
   * @return {Integer}	position in which comment is placed, corresponding to commentSpace position alse
   */
  CommentsModel.prototype.getOrderedIndexByCommentId = function (commentId) {
    var count = 0
    for (var id in this.comments) {
      if (id == commentId) {
        return count
      }
      count++
    }
  }

  return CommentsModel
})
define('modules/Edition/src/ElementManager', [], function () {
  /**
   * Abstraction class, used by NoteSpaceManager and ChordSpaceManager (by composition rather than heritage)
   * @exports Edition/ElementManager
   */
  function ElementManager() {}

  /*
   * @param  {Array} ini Array of two numbers representing x and y ([x,y]), represents the initial position (where user clicked initially on selection)
   * @param  {Array} end  Exactly the same as ini, but represents the end position (where user did mousup after dragging on selection),
   * @return {Boolean}
   */
  ElementManager.prototype.fromLeftBottom2TopRight = function (ini, end) {
    return ini[0] < end[0] && ini[1] > end[1]
  }

  /*
   * @param  {Array} ini Array of two numbers representing x and y ([x,y]), represents the initial position (where user clicked initially on selection)
   * @param  {Array} end  Exactly the same as ini, but represents the end position (where user did mousup after dragging on selection),
   * @return {Boolean}
   */
  ElementManager.prototype.fromTopRight2BottomLeft = function (ini, end) {
    return ini[0] > end[0] && ini[1] < end[1]
  }

  /**
   * [includesMultipleLines description]
   * @param  {Object} ys Has ys delimiting selection. e.g.:{bottomY: 12, topY: 24}
   * @return {Boolean}
   */
  ElementManager.prototype.includesMultipleLines = function (ys) {
    return ys.topY != ys.bottomY
  }

  /**
   * gets elements on a selection delimitied by an area, with some special cases
   * @param  {Array} elems  array of elements; e.g. 'NoteSpaceView'
   * @param  {Object} coords e.g. {x:23, y:34, xe: 153, ye: 45}
   * @param  {Array} ini    Array of two numbers representing x and y ([x,y]), represents the initial position (where user clicked initially on selection), x is equal to coords.x or coords.xe, and y is equal to coords.y or coords.ye (yes, it's redundant data, and should be refactored)
   * @param  {Array} end    Exactly the same as ini, but represents the end position (where user did mousup after dragging on selection),
   * @param  {Object} ys    Has ys delimiting selection. e.g.:{bottomY: 12, topY: 24}
   * @return {Array}        returns indexes including selected elements
   */
  ElementManager.prototype.getElemsInPath = function (elems, coords, ini, end, ys) {
    var min = null,
      max = null

    //special case of getElemsInPath: if we had selected from top right to bottom left, or from bottom left to top right, and elements selected
    //include more than one line:
    //	we have to get elements  starting after top right, and finishing before bottom left.
    //otherwise, we do a normal 'getElemsInPath', maybe we should refactor this to not treat so many 'special cases' and 'ifs'
    if (
      ini &&
      end &&
      ys &&
      (this.fromLeftBottom2TopRight(ini, end) || this.fromTopRight2BottomLeft(ini, end)) &&
      this.includesMultipleLines(ys)
    ) {
      return this.getInvertedElemsInPath(elems, coords)
    } else {
      for (var i in elems) {
        if (elems[i].isInPath(coords)) {
          if (min == null) {
            min = Number(i)
          }
          if (max == null || max < i) {
            max = Number(i)
          }
        }
      }
      return min === null && max === null ? false : [min, max]
    }
  }
  /**
   * like getElementsInPath but returns only one element, useful in for some classes like 'CommentSpaceManager'
   * @param  {Array} elems   elems  array of elements; e.g. 'CommentSpaceManager'
   * @param  {Object} coords e.g. {x:23, y:34, xe: 153, ye: 45}
   * @return {[type]}        [description]
   */
  ElementManager.prototype.getOneElemInPath = function (elems, coords) {
    for (var i in elems) {
      if (elems[i].isInPath(coords)) {
        return elems[i]
      }
    }
  }

  /**
   * instead of selecting elements specified by an area, gets for the very first line, and the last one, those not including getArea
   * @param  {Array} elems  array of elements; e.g. 'NoteSpaceView'
   * @param  {Object} coords e.g. {x:23, y:34, xe: 153, ye: 45}
   * @return {}
   */
  ElementManager.prototype.getInvertedElemsInPath = function (elems, coords) {
    function getFirstAndLast(inPathElems) {
      var firstLastElement = null
      if (inPathElems.length < 2) {
        //console.warn("inPathElems cannot be lower than 2");
        return false
      }
      var i = 0
      var elem
      var smallestY = inPathElems[0].y

      while (inPathElems[i].y === smallestY) {
        i++
      }

      var indexFirstLine = inPathElems[i - 1].index
      var hightestY = inPathElems[inPathElems.length - 1].y

      i = inPathElems.length - 1
      while (inPathElems[i].y === hightestY) {
        i--
      }
      var indexLastLine = inPathElems[i + 1].index
      return indexFirstLine == null && indexLastLine == null ? false : [indexFirstLine, indexLastLine]
    }

    var min = null,
      max = null
    var inPathElems = []
    for (var i in elems) {
      if (elems[i].isInPath(coords)) {
        inPathElems.push({
          index: Number(i),
          y: elems[i].position.y,
        })
      }
    }
    return getFirstAndLast(inPathElems)
  }

  /**
   * @param  {Array} elems array of elements; e.g. 'NoteSpaceView'
   * @param  {Array} ys    [yMin, yMax]
   * @return {Array} of two positions [min, max], or boolean false if nothing found
   */
  ElementManager.prototype.getElemsBetweenYs = function (elems, ys) {
    var min = null,
      max = null
    for (var i in elems) {
      if (elems[i].isBetweenYs(ys)) {
        if (min == null) {
          min = Number(i)
        }
        if (max == null || max < i) {
          max = Number(i)
        }
      }
    }
    return min === null && max === null ? false : [min, max]
  }

  /**
   * function to determine how high elements are situated
   * @param  {Array} elems  array of elements; e.g. 'NoteSpaceView'
   * @param  {Object} coords
   */
  ElementManager.prototype.getYs = function (elems, coords) {
    var cursor = this.getElemsBetweenYs(elems, [coords.y, coords.ye])
    if (cursor) {
      return {
        topY: elems[cursor[0]].getArea().y,
        bottomY: elems[cursor[1]].getArea().y,
      }
    } else {
      return false
    }
  }

  /**
   * @param  {Array} elems      [description]
   * @param  {Array} cursor     [Integer, Integer]
   * @return {Array}    Array of Objects in this form: {area.x, area.y, area.xe, area.ye}
   */
  ElementManager.prototype.getElementsAreaFromCursor = function (elems, cursor) {
    var areas = [],
      area,
      cInit = cursor[0],
      cEnd = cursor[1]

    if (typeof elems[cInit] === 'undefined') {
      return areas
    }
    var x, y, xe, currElem, currElemY, nextElemY, firstElemLine, lastElemLine

    firstElemLine = elems[cInit]

    // to avoid bug when after making changes in melody new melody is shorter than cursor length
    if (cEnd >= elems.length) cEnd = elems.length - 1

    while (cInit <= cEnd) {
      currElem = elems[cInit]
      if (typeof currElem.getArea !== 'function') {
        throw 'ElementManager - Error: element passed has no getArea() function'
      }
      currElemY = currElem.getArea().y

      if (typeof elems[cInit + 1] !== 'undefined') {
        nextElemY = elems[cInit + 1].getArea().y
      }
      if (currElemY != nextElemY || cInit == cEnd) {
        lastElemLine = currElem.getArea()
        x = firstElemLine.getArea().x
        xe = lastElemLine.x - x + lastElemLine.w
        area = {
          x: x,
          y: currElemY,
          w: xe,
          h: currElem.getArea().h,
        }
        areas.push(area)
        if (cInit != cEnd) {
          firstElemLine = elems[cInit + 1]
        }
      }
      cInit++
    }
    return areas
  }
  /**
   * merges two cursors, used on cumulated section (using mouse + ctrl),
   * We manage the case in which one of those cursors has position null, which arrives when the cursor was disabled,
   * but not the case where both are null, which should never array
   *
   * @param  {Array} cursor1 [start, end]
   * @param  {Array} cursor2 [start, end]
   * @return {Array}         [start, end]
   */
  ElementManager.prototype.getMergedCursors = function (cursor1, cursor2) {
    var mergedCursor = []

    if (cursor1[0] == null && cursor1[1] == null) {
      cursor1 = cursor2
    } else if (cursor2[0] == null && cursor2[1] == null) {
      cursor2 = cursor1
    }
    mergedCursor[0] = cursor1[0] < cursor2[0] ? cursor1[0] : cursor2[0]
    mergedCursor[1] = cursor1[1] > cursor2[1] ? cursor1[1] : cursor2[1]
    return mergedCursor
  }

  return ElementManager
})
define('modules/Edition/src/ElementView', [], function () {
  var ElementView = {}

  /**
   * @exports Edition/ElementView
   * @param  {Object}  area    area can be in two forms :
   *                           {x: 10, y: 10, xe: 20, ye: 20} / xe and ye are absolute positions (not relative to x and y)
   *                           {x: 10, y:10}
   * @param  {Object}  position {x: 2, y: 20}
   * @param  {Scaler}  scaler
   * @return {Boolean}
   */
  ElementView.isInPath = function (area, position, scaler) {
    area.xe = area.xe || area.x
    area.ye = area.ye || area.y //in case xe and ye are not defined, they take the same value a x and y respectively
    var pos = scaler.getScaledObj(position),
      posXe = pos.x + pos.w,
      posYe = pos.y + pos.h
    return area.x < posXe && area.xe > pos.x && area.y < posYe && area.ye > pos.y
  }
  /**
   * isBetweenYs description
   * @param  {Array}  ys       [yMin, yMax]
   * @param  {Object} position obj normally in the form of {x: 23, y:130, xe: 33, ye: 23}
   * @param  {Scaler}  scaler   LSviewer scaler
   * @return {Boolean}
   */
  ElementView.isBetweenYs = function (ys, position, scaler) {
    var pos = scaler.getScaledObj(position),
      posYe = pos.y + pos.h
    return ys[0] < posYe && ys[1] > pos.y
  }

  return ElementView
})
define('modules/Comments/src/CommentSpaceView', ['modules/Edition/src/ElementView'], function (ElementView) {
  /**
   * CommentSpaceView allow comments to be clickable
   * This object is created by CommentSpaceManager
   * @exports AudioComments/CommentSpaceView
   * @param {Object} position {x:439.25, y:33,w:10,h:10} //position
   * @param {Scaler} viewerScaler
   */
  function CommentSpaceView(id, position, viewerScaler) {
    this.id = id
    this.position = position
    this.scaler = viewerScaler
    this.shown = false
  }
  /**
   * @interface
   * @param  {Object}  coords [description]
   * @return {Boolean}        [description]
   */
  CommentSpaceView.prototype.isInPath = function (coords) {
    return ElementView.isInPath(coords, this.position, this.scaler)
  }
  /**
   * @interface
   */
  CommentSpaceView.prototype.getArea = function () {
    return this.position
  }

  CommentSpaceView.prototype.getId = function () {
    return this.id
  }
  return CommentSpaceView
})
define('modules/Comments/src/CommentSpaceManager', [
  'modules/Edition/src/ElementManager',
  'modules/Comments/src/CommentSpaceView',
  'jquery',
], function (ElementManager, CommentSpaceView, $) {
  /**
   * CommentSpaceManager creates and manages an array of comment space
   * @exports AudioComments/CommentSpaceManager
   */
  function CommentSpaceManager(viewer) {
    this.commentSpaces = {}
    this.viewer = viewer
    this.elemMng = new ElementManager()
    this.CL_TYPE = 'CLICKABLE'
    this.CL_NAME = 'AudioComments'
    this.clickedElem = null
  }
  CommentSpaceManager.prototype.getType = function () {
    return this.CL_TYPE
  }
  CommentSpaceManager.prototype.addCommentSpace = function (id, commentArea) {
    this.commentSpaces[id] = new CommentSpaceView(id, commentArea, this.viewer.scaler)
  }

  CommentSpaceManager.prototype.inPath = function (coords) {
    var elem = this.elemMng.getOneElemInPath(this.commentSpaces, coords)
    if (elem) {
      this.clickedElem = elem // we know it will be only one, so pos 0 == pos 1, no matter which one we take
    }
    return !!elem
  }

  CommentSpaceManager.prototype.enable = function () {
    //do nothing
  }

  CommentSpaceManager.prototype.disable = function () {
    //do nothing
  }
  CommentSpaceManager.prototype.isEnabled = function () {
    return true
  }

  CommentSpaceManager.prototype.onSelected = function () {
    $.publish('CommentSpaceManager-clickedComment', this.clickedElem.getId())
  }
  return CommentSpaceManager
})
define('modules/Comments/src/AudioCommentsView', [], function () {
  /**
   * Represents audio comments
   * @param {AudioDrawer} audioDrawer [description]
   */
  var AudioCommentsView = function (audioDrawer) {
    //when initializing AudioCommentsView
    return {
      getArea: function (comment) {
        var cursor = audioDrawer.audioCursor.cursor
        var timeInterval = comment ? comment.timeInterval : cursor.getPos()
        return audioDrawer.audioCursor.getAreasFromTimeInterval(timeInterval[0], timeInterval[1])
      },
      isEnabled: function () {
        return audioDrawer.audioCursor.isEnabled()
      },
      getTimeInterval: function () {
        return audioDrawer.audioCursor.cursor.getPos()
      },
      color: '#77B979',
    }
  }
  return AudioCommentsView
})
define('modules/Comments/src/NoteCommentsView', [], function () {
  /**
   * Represents notes comments
   * @param {NoteSpaceManager} noteSpaceMng
   * @param {Cursor} notesCursor
   * @param {SongModel} song
   */
  var NoteCommentsView = function (noteSpaceMng, notesCursor, song) {
    var noteMng = song.getComponent('notes')
    return {
      /**
       * @param  {Comment|null} comment , if null, we get area from notesCursor
       * @return {[type]}         [description]
       */
      getArea: function (comment) {
        var indexes = comment
          ? //loading a given comment
            noteMng.getIndexesStartingBetweenBeatInterval(comment.beatInterval[0], comment.beatInterval[1], true)
          : //getting indexes from selection
            [notesCursor.getStart(), notesCursor.getEnd()]

        return noteSpaceMng.elemMng.getElementsAreaFromCursor(noteSpaceMng.noteSpace, indexes)
      },
      isEnabled: function () {
        return noteSpaceMng.isEnabled()
      },
      getBeatInterval: function () {
        return noteMng.getBeatIntervalByIndexes(notesCursor.getStart(), notesCursor.getEnd())
      },
      color: '#EB9696',
    }
  }
  return NoteCommentsView
})
define('modules/Comments/src/ChordCommentsView', [], function () {
  /**
   * Represents chord comments
   * @param {ChordsEditor} chordsEditor
   * @param {SongModel} song
   */
  var ChordCommentsView = function (chordsEditor, song) {
    var chordMng = song.getComponent('chords')
    return {
      /**
       * [getArea description]
       * @param  {Comment|null} comment , if null, we get area from notesCursor
       * @return {[type]}         [description]
       */
      getArea: function (comment) {
        var indexes = comment
          ? //loading a given comment
            [comment.beatInterval[0] - 1, comment.beatInterval[1] - 1]
          : //getting indexes from selection
            chordsEditor.controller.cursor.getPos()
        return chordsEditor.chordSpaceMng.elemMng.getElementsAreaFromCursor(
          chordsEditor.chordSpaceMng.chordSpaces,
          indexes
        )
      },
      isEnabled: function () {
        return chordsEditor.chordSpaceMng.isEnabled()
      },
      getBeatInterval: function () {
        var indexes = chordsEditor.controller.getSelectedChordsBeats()
        return [indexes[0], indexes[1] - 1]
        //return chordMng.getBeatIntervalByIndexes(notesCursor.getStart(), notesCursor.getEnd());
      },
      color: '#D8B337',
    }
  }
  return ChordCommentsView
})
/**
 * @license RequireJS text 2.0.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text', ['module'], function (module) {
  'use strict'

  var text,
    fs,
    Cc,
    Ci,
    xpcIsWindows,
    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
    xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
    bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
    hasLocation = typeof location !== 'undefined' && location.href,
    defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
    defaultHostName = hasLocation && location.hostname,
    defaultPort = hasLocation && (location.port || undefined),
    buildMap = {},
    masterConfig = (module.config && module.config()) || {}

  text = {
    version: '2.0.14',

    strip: function (content) {
      //Strips <?xml ...?> declarations so that external SVG and XML
      //documents can be added to a document without worry. Also, if the string
      //is an HTML document, only the part inside the body tag is returned.
      if (content) {
        content = content.replace(xmlRegExp, '')
        var matches = content.match(bodyRegExp)
        if (matches) {
          content = matches[1]
        }
      } else {
        content = ''
      }
      return content
    },

    jsEscape: function (content) {
      return content
        .replace(/(['\\])/g, '\\$1')
        .replace(/[\f]/g, '\\f')
        .replace(/[\b]/g, '\\b')
        .replace(/[\n]/g, '\\n')
        .replace(/[\t]/g, '\\t')
        .replace(/[\r]/g, '\\r')
        .replace(/[\u2028]/g, '\\u2028')
        .replace(/[\u2029]/g, '\\u2029')
    },

    createXhr:
      masterConfig.createXhr ||
      function () {
        //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
        var xhr, i, progId
        if (typeof XMLHttpRequest !== 'undefined') {
          return new XMLHttpRequest()
        } else if (typeof ActiveXObject !== 'undefined') {
          for (i = 0; i < 3; i += 1) {
            progId = progIds[i]
            try {
              xhr = new ActiveXObject(progId)
            } catch (e) {}

            if (xhr) {
              progIds = [progId] // so faster next time
              break
            }
          }
        }

        return xhr
      },

    /**
     * Parses a resource name into its component parts. Resource names
     * look like: module/name.ext!strip, where the !strip part is
     * optional.
     * @param {String} name the resource name
     * @returns {Object} with properties "moduleName", "ext" and "strip"
     * where strip is a boolean.
     */
    parseName: function (name) {
      var modName,
        ext,
        temp,
        strip = false,
        index = name.lastIndexOf('.'),
        isRelative = name.indexOf('./') === 0 || name.indexOf('../') === 0

      if (index !== -1 && (!isRelative || index > 1)) {
        modName = name.substring(0, index)
        ext = name.substring(index + 1)
      } else {
        modName = name
      }

      temp = ext || modName
      index = temp.indexOf('!')
      if (index !== -1) {
        //Pull off the strip arg.
        strip = temp.substring(index + 1) === 'strip'
        temp = temp.substring(0, index)
        if (ext) {
          ext = temp
        } else {
          modName = temp
        }
      }

      return {
        moduleName: modName,
        ext: ext,
        strip: strip,
      }
    },

    xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

    /**
     * Is an URL on another domain. Only works for browser use, returns
     * false in non-browser environments. Only used to know if an
     * optimized .js version of a text resource should be loaded
     * instead.
     * @param {String} url
     * @returns Boolean
     */
    useXhr: function (url, protocol, hostname, port) {
      var uProtocol,
        uHostName,
        uPort,
        match = text.xdRegExp.exec(url)
      if (!match) {
        return true
      }
      uProtocol = match[2]
      uHostName = match[3]

      uHostName = uHostName.split(':')
      uPort = uHostName[1]
      uHostName = uHostName[0]

      return (
        (!uProtocol || uProtocol === protocol) &&
        (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
        ((!uPort && !uHostName) || uPort === port)
      )
    },

    finishLoad: function (name, strip, content, onLoad) {
      content = strip ? text.strip(content) : content
      if (masterConfig.isBuild) {
        buildMap[name] = content
      }
      onLoad(content)
    },

    load: function (name, req, onLoad, config) {
      //Name has format: some.module.filext!strip
      //The strip part is optional.
      //if strip is present, then that means only get the string contents
      //inside a body tag in an HTML string. For XML/SVG content it means
      //removing the <?xml ...?> declarations so the content can be inserted
      //into the current doc without problems.

      // Do not bother with the work if a build and text will
      // not be inlined.
      if (config && config.isBuild && !config.inlineText) {
        onLoad()
        return
      }

      masterConfig.isBuild = config && config.isBuild

      var parsed = text.parseName(name),
        nonStripName = parsed.moduleName + (parsed.ext ? '.' + parsed.ext : ''),
        url = req.toUrl(nonStripName),
        useXhr = masterConfig.useXhr || text.useXhr

      // Do not load if it is an empty: url
      if (url.indexOf('empty:') === 0) {
        onLoad()
        return
      }

      //Load the text. Use XHR if possible and in a browser.
      if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
        text.get(
          url,
          function (content) {
            text.finishLoad(name, parsed.strip, content, onLoad)
          },
          function (err) {
            if (onLoad.error) {
              onLoad.error(err)
            }
          }
        )
      } else {
        //Need to fetch the resource across domains. Assume
        //the resource has been optimized into a JS module. Fetch
        //by the module name + extension, but do not include the
        //!strip part to avoid file system issues.
        req([nonStripName], function (content) {
          text.finishLoad(parsed.moduleName + '.' + parsed.ext, parsed.strip, content, onLoad)
        })
      }
    },

    write: function (pluginName, moduleName, write, config) {
      if (buildMap.hasOwnProperty(moduleName)) {
        var content = text.jsEscape(buildMap[moduleName])
        write.asModule(pluginName + '!' + moduleName, "define(function () { return '" + content + "';});\n")
      }
    },

    writeFile: function (pluginName, moduleName, req, write, config) {
      var parsed = text.parseName(moduleName),
        extPart = parsed.ext ? '.' + parsed.ext : '',
        nonStripName = parsed.moduleName + extPart,
        //Use a '.js' file name so that it indicates it is a
        //script that can be loaded across domains.
        fileName = req.toUrl(parsed.moduleName + extPart) + '.js'

      //Leverage own load() method to load plugin value, but only
      //write out values that do not have the strip argument,
      //to avoid any potential issues with ! in file names.
      text.load(
        nonStripName,
        req,
        function (value) {
          //Use own write() method to construct full module value.
          //But need to create shell that translates writeFile's
          //write() to the right interface.
          var textWrite = function (contents) {
            return write(fileName, contents)
          }
          textWrite.asModule = function (moduleName, contents) {
            return write.asModule(moduleName, fileName, contents)
          }

          text.write(pluginName, nonStripName, textWrite, config)
        },
        config
      )
    },
  }

  if (
    masterConfig.env === 'node' ||
    (!masterConfig.env &&
      typeof process !== 'undefined' &&
      process.versions &&
      !!process.versions.node &&
      !process.versions['node-webkit'] &&
      !process.versions['atom-shell'])
  ) {
    //Using special require.nodeRequire, something added by r.js.
    fs = require.nodeRequire('fs')

    text.get = function (url, callback, errback) {
      try {
        var file = fs.readFileSync(url, 'utf8')
        //Remove BOM (Byte Mark Order) from utf8 files if it is there.
        if (file[0] === '\uFEFF') {
          file = file.substring(1)
        }
        callback(file)
      } catch (e) {
        if (errback) {
          errback(e)
        }
      }
    }
  } else if (masterConfig.env === 'xhr' || (!masterConfig.env && text.createXhr())) {
    text.get = function (url, callback, errback, headers) {
      var xhr = text.createXhr(),
        header
      xhr.open('GET', url, true)

      //Allow plugins direct access to xhr headers
      if (headers) {
        for (header in headers) {
          if (headers.hasOwnProperty(header)) {
            xhr.setRequestHeader(header.toLowerCase(), headers[header])
          }
        }
      }

      //Allow overrides specified in config
      if (masterConfig.onXhr) {
        masterConfig.onXhr(xhr, url)
      }

      xhr.onreadystatechange = function (evt) {
        var status, err
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
          status = xhr.status || 0
          if (status > 399 && status < 600) {
            //An http 4xx or 5xx error. Signal an error.
            err = new Error(url + ' HTTP status: ' + status)
            err.xhr = xhr
            if (errback) {
              errback(err)
            }
          } else {
            callback(xhr.responseText)
          }

          if (masterConfig.onXhrComplete) {
            masterConfig.onXhrComplete(xhr, url)
          }
        }
      }
      xhr.send(null)
    }
  } else if (
    masterConfig.env === 'rhino' ||
    (!masterConfig.env && typeof Packages !== 'undefined' && typeof java !== 'undefined')
  ) {
    //Why Java, why is this so awkward?
    text.get = function (url, callback) {
      var stringBuffer,
        line,
        encoding = 'utf-8',
        file = new java.io.File(url),
        lineSeparator = java.lang.System.getProperty('line.separator'),
        input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
        content = ''
      try {
        stringBuffer = new java.lang.StringBuffer()
        line = input.readLine()

        // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
        // http://www.unicode.org/faq/utf_bom.html

        // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
        if (line && line.length() && line.charAt(0) === 0xfeff) {
          // Eat the BOM, since we've already found the encoding on this file,
          // and we plan to concatenating this buffer with others; the BOM should
          // only appear at the top of a file.
          line = line.substring(1)
        }

        if (line !== null) {
          stringBuffer.append(line)
        }

        while ((line = input.readLine()) !== null) {
          stringBuffer.append(lineSeparator)
          stringBuffer.append(line)
        }
        //Make sure we return a JavaScript string and not a Java string.
        content = String(stringBuffer.toString()) //String
      } finally {
        input.close()
      }
      callback(content)
    }
  } else if (
    masterConfig.env === 'xpconnect' ||
    (!masterConfig.env && typeof Components !== 'undefined' && Components.classes && Components.interfaces)
  ) {
    //Avert your gaze!
    Cc = Components.classes
    Ci = Components.interfaces
    Components.utils['import']('resource://gre/modules/FileUtils.jsm')
    xpcIsWindows = '@mozilla.org/windows-registry-key;1' in Cc

    text.get = function (url, callback) {
      var inStream,
        convertStream,
        fileObj,
        readData = {}

      if (xpcIsWindows) {
        url = url.replace(/\//g, '\\')
      }

      fileObj = new FileUtils.File(url)

      //XPCOM, you so crazy
      try {
        inStream = Cc['@mozilla.org/network/file-input-stream;1'].createInstance(Ci.nsIFileInputStream)
        inStream.init(fileObj, 1, 0, false)

        convertStream = Cc['@mozilla.org/intl/converter-input-stream;1'].createInstance(Ci.nsIConverterInputStream)
        convertStream.init(
          inStream,
          'utf-8',
          inStream.available(),
          Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER
        )

        convertStream.readString(inStream.available(), readData)
        convertStream.close()
        inStream.close()
        callback(readData.value)
      } catch (e) {
        throw new Error(((fileObj && fileObj.path) || '') + ': ' + e)
      }
    }
  }
  return text
})

define('text!modules/Comments/src/SpeechBubbleTpl.html', [], function () {
  return '<div class="speech-bubble">\n\t\t<span style="float:right"><a class="close" href="#">x</a></span>\n\t\t{{#ownComment}}\n\t\t<div><a class="edit-comment" href="#">Edit</a> | <a class="remove-comment" href="#">Remove</a></div>\n\t\t{{/ownComment}}\n\t    <div class="textComment">{{textComment}}</div>\n    \n\t<div class="arrow bottom right"></div>\n</div>'
})

define('text!modules/Comments/src/NewCommentTpl.html', [], function () {
  return '<div id="newComment" class="speech-bubble">\n\t\t<span style="float:right"><a class="close" href="#">x</a></span>\n\t\t<div class="arrow bottom right"></div>\n\t\t<form>\n      \t\t<textarea style=\'width:90%;height:90%\'></textarea>\n      \t\t<input type="hidden" name="commentId"/>\n      \t\t<button id="sendNewComment" class=\'btn btn-small btn-primary\' type=\'button\' style="float:right">Send</button>\n\t\t</form>\n</div>'
})

define('modules/Comments/src/CommentsView', [
  'mustache',
  'jquery',
  'modules/Comments/src/CommentSpaceManager',
  'modules/Comments/src/AudioCommentsView',
  'modules/Comments/src/NoteCommentsView',
  'modules/Comments/src/ChordCommentsView',
  'text!modules/Comments/src/SpeechBubbleTpl.html',
  'text!modules/Comments/src/NewCommentTpl.html',
], function (
  Mustache,
  $,
  CommentSpaceManager,
  AudioCommentsView,
  NoteCommentsView,
  ChordCommentsView,
  SpeechBubbleTpl,
  NewCommentTpl
) {
  /**
   *
   * @exports AudioComments/CommentsView
   */
  function CommentsView(viewer, song, audioCursor, noteSpaceMng, notesCursor, chordsEditor) {
    this.viewer = viewer
    this.COLOR = '#FFBF00'
    this.commentSpaceMng = null
    this.initController()
    this.newComment = {}
    this.offset = $('#' + viewer.canvasId).offset()
    this.newCommentId = 'newComment'
    this.bubblePreId = 'bubble' //prefix Id, the comments of bubbles' id will be, bubble0, bubble1...etc.
    this.commentSpaceMng = new CommentSpaceManager(this.viewer)
    this.viewTypes = {}
    if (audioCursor) {
      this.viewTypes['audio'] = AudioCommentsView(audioCursor)
    }
    if (noteSpaceMng) {
      this.viewTypes['notes'] = NoteCommentsView(noteSpaceMng, notesCursor, song)
    }
    if (chordsEditor) {
      this.viewTypes['chords'] = ChordCommentsView(chordsEditor, song)
    }
    this.noteSpaceMng = noteSpaceMng
    this.notesCursor = notesCursor
    this.song = song
  }

  /**
   * jquery events
   */
  CommentsView.prototype.initController = function () {
    var self = this
    //close comment
    $(document).on('click', '.close', function () {
      var id = $(this).closest('.speech-bubble').attr('id')
      if (id == self.newCommentId) {
        self.hideNewComment()
      } else {
        id = id.substr(self.bubblePreId.length, id.length) //extracting prefix "bubble", to get id X on "bubbleX"
        $.publish('CommentsView-closeBubble', id)
      }
    })
    //new comment
    $(document).on('click', '#sendNewComment', function () {
      var commentEl = $(this).closest('.speech-bubble')
      var text = commentEl.find('textarea').val()
      var commentId = commentEl.find('input[name="commentId"]').val()

      if (commentId.length !== 0) {
        $.publish('CommentsView-updateComment', [commentId, text])
      } else {
        self.newComment.text = text
        $.publish('CommentsView-saveComment', self.newComment)
      }
      self.hideNewComment()
    })

    //edit comment
    $(document).on('click', '.edit-comment', function () {
      var commentEl = $(this).closest('.speech-bubble'),
        commentId = commentEl.attr('data-commentId')
      $.publish('CommentsView-editingComment', [commentEl, commentId])
    })

    //remove comment
    $(document).on('click', '.remove-comment', function () {
      var commentEl = $(this).closest('.speech-bubble'),
        commentId = commentEl.attr('data-commentId')
      $.publish('CommentsView-removingComment', [commentEl, commentId])
    })
  }

  CommentsView.prototype._htmlIdExists = function (id) {
    return $('#' + id).length !== 0
  }

  /**
   * called by AudioCommentsController
   * draws comment marker (with the picture and the name)
   * @param  {CommentsModel} CommentsModel
   * @param  {WaveDrawer} waveDrawer
   */
  CommentsView.prototype.draw = function (comments, userId) {
    //we need to add element to canvas each time we draw
    this.viewer.canvasLayer.addElement(this.commentSpaceMng, true)

    //we construct it here because it adds himself to canvasLayer which exists only after the score is drawn
    var ctx = this.viewer.ctx,
      self = this

    //draw only if doesn't exists, to avoid duplicates
    //(html elements are different from canvas elements, html elements are not reseted in every LSViewer draw whereas canvas elements are)
    if (!this._htmlIdExists(this.newCommentId)) {
      this.drawNewComment()
    }

    //draw using drawElem to respect scaling
    this.viewer.drawElem(function () {
      var bubbleId
      for (var i in comments) {
        self.drawComment(comments[i], ctx)
        bubbleId = self.bubblePreId + comments[i].id
        if (!self._htmlIdExists(bubbleId)) {
          self.drawBubble(comments[i], bubbleId, userId)
        }
      }
    })
  }

  CommentsView.prototype.drawComment = function (comment, ctx) {
    var saveFillColor = ctx.fillStyle
    var clickableArea
    var color = this.viewTypes[comment.type].color || this.COLOR
    ctx.fillStyle = color
    ctx.strokeStyle = color
    var areas = this.viewTypes[comment.type].getArea(comment)

    ctx.beginPath()
    ctx.lineWidth = 5
    paddingY = 5 // could be part of each viewType
    for (var i = 0; i < areas.length; i++) {
      areas[i].y -= paddingY
    }
    //draw border top of comment marker
    for (i = 0, c = areas.length; i < c; i++) {
      ctx.moveTo(areas[i].x, areas[i].y)
      ctx.lineTo(areas[i].x + areas[i].w, areas[i].y)
    }
    ctx.stroke()

    ctx.lineWidth = 1
    //draw border left, to indicate time start of audio comment
    ctx.moveTo(areas[0].x, areas[0].y)
    ctx.lineTo(areas[0].x, areas[0].y + areas[0].h + paddingY)

    //draw border right, to indicate time end of audio comment
    var lastArea = areas.length - 1
    ctx.moveTo(areas[lastArea].x + areas[lastArea].w - 1, areas[lastArea].y)
    ctx.lineTo(areas[lastArea].x + areas[lastArea].w - 1, areas[lastArea].y + areas[0].h)
    ctx.closePath()
    ctx.stroke()

    ctx.font = '12px Arial'
    var text = ctx.measureText(comment.userName)
    var widthBox = 100
    if (text.width > widthBox) {
      widthBox = text.width + 50 // 50 stand for 30px image width + padding/margin
    }

    //draw little box with picture and name, which will be clickable
    clickableArea = {
      x: areas[0].x,
      y: areas[0].y - 30,
      w: widthBox,
      h: 30,
    }

    ctx.strokeRect(clickableArea.x, clickableArea.y, clickableArea.w, clickableArea.h)
    ctx.globalAlpha = 0.7
    ctx.fillRect(clickableArea.x, clickableArea.y, clickableArea.w, clickableArea.h)
    ctx.globalAlpha = 1
    var img = new Image()
    img.onload = function () {
      ctx.drawImage(img, areas[0].x, areas[0].y - 30, 30, 30)
    }
    ctx.fillStyle = '#000'
    ctx.textBaseline = 'bottom'
    img.src = comment.img

    ctx.fillText(comment.userName, areas[0].x + 38, areas[0].y - 15)

    if (comment.date !== undefined) {
      ctx.font = '10px Arial'
      ctx.fillText('(' + comment.date + ')', areas[0].x + 35, areas[0].y - 2)
    }

    ctx.fillStyle = saveFillColor
    //add clickable area to commentSpaceMgn
    this.commentSpaceMng.addCommentSpace(comment.id, clickableArea)
  }

  /**
   * Bubble is a HTML div, it is drawn as a hidden element after every LSViewer draw
   * @param  {Object} comment
   * @param  {String} bubbleId
   * @param  {String} userId
   */
  CommentsView.prototype.drawBubble = function (comment, bubbleId, userId) {
    var el = Mustache.render(SpeechBubbleTpl, {
      textComment: comment.text,
      ownComment: comment.userId == userId,
    })

    $('body').append($(el).attr('id', bubbleId).attr('data-commentId', comment.id).hide())
  }

  /**
   * NewComment represents the editable bubble with empty textare, drawn here as hidden
   */
  CommentsView.prototype.drawNewComment = function () {
    var el = Mustache.render(NewCommentTpl)
    $('body').append($(el).hide())
  }

  /**
   * show bubble is called when clicking on box with picture and name
   * @param  {String} commentId  Id of the comment, coincides with the key of the comments object in the model
   * @param  {Integer} index   refers to the index of the space manager, which is an ordered index, unlike comment Id
   *                           e.g. if we have removed comment with id 2, keys of comments is ["0","1","3","4"] whereas corresponding indexes will be [0,1,2,3], so when *                           commentId is 2, index will be 3 (works well as every time a comment is added or deleted, everything is recalculated)
   */
  CommentsView.prototype.showBubble = function (commentId, index) {
    var height = $('#' + this.bubblePreId + commentId).height()

    var area = this.commentSpaceMng.commentSpaces[commentId].getArea()
    var offset = this.offset //to avoid 'this' closure problem
    $('#bubble' + commentId)
      .css({
        top: area.y - area.h + offset.top - height,
        left: area.x + offset.left,
        maxHeight: height,
        zIndex: 1900,
      })
      .show()
    $('#bubble' + commentId + ' .textComment')
  }

  /**
   * When click on 'edit' in a comment, what we do is hide the actual comment and show 'new comment' bubble with the text of the current comment
   * @param  {Object}		bubbleEl    jquery Element
   * @param  {String}				commentText text of current comment
   * @param  {String}				commentId
   */
  CommentsView.prototype.showEditingComment = function (bubbleEl, commentText, commentId, controller) {
    function getOldCommentPosition(bubbleEl, newCommentId) {
      var offset = $(bubbleEl).offset()
      var oldCommentHeight = $(bubbleEl).outerHeight(true)
      var newCommentHeight = $('#' + newCommentId).outerHeight(true)
      return {
        x: offset.left,
        y: offset.top + oldCommentHeight - newCommentHeight,
      }
    }
    //need to get point before hiding comment
    var point = getOldCommentPosition(bubbleEl, this.newCommentId)
    controller.hideComment(bubbleEl.attr('id')) //TODO: hideComment and showComment methods should be in view
    // controller calls this.hideBubble();

    var newCommentEl = $('#' + this.newCommentId)

    newCommentEl.find('textarea').val(commentText)
    newCommentEl.find('input[name="commentId"]').val(commentId)
    newCommentEl
      .css({
        position: 'absolute',
        top: point.y,
        left: point.x,
        zIndex: 1900,
      })
      .show()
    $('#' + this.newCommentId + ' textarea').focus()
  }

  /**
   * when select audio region we show 'new commment' bubble
   * @param  {Array} cursorPos  [startTime, endTime]
   * @param  {AudioCursor} audioCursor : to find area from cursorPos
   */
  CommentsView.prototype.showNewComment = function () {
    var audioEnabled = this.viewTypes['audio'] && this.viewTypes['audio'].isEnabled()
    var notesEnabled = this.viewTypes['notes'] && this.viewTypes['notes'].isEnabled()
    var chordsEnabled = this.viewTypes['chords'] && this.viewTypes['chords'].isEnabled()

    var type = audioEnabled ? 'audio' : notesEnabled ? 'notes' : chordsEnabled ? 'chords' : null

    var areas = this.viewTypes[type].getArea()
    if (type === 'audio') {
      this.newComment.timeInterval = this.viewTypes[type].getTimeInterval() // [cursorPos[0], cursorPos[1]];
    } else {
      this.newComment.beatInterval = this.viewTypes[type].getBeatInterval()
    }
    this.newComment.type = type
    var offset = this.offset //to avoid 'this' closure problem
    height = $('#' + this.newCommentId).outerHeight(true) + 8
    $('#' + this.newCommentId)
      .css({
        position: 'absolute',
        top: areas[0].y + offset.top - height,
        left: areas[0].x + offset.left,
        zIndex: 1900,
      })
      .show()
    $('#' + this.newCommentId + ' textarea').focus()
  }

  /**
   * Update html text (updating model has been done from the controller)
   * @param  {String} id    id of the comment
   * @param  {String} text
   */
  CommentsView.prototype.updateComment = function (id, text) {
    $('#' + this.bubblePreId + id + ' .textComment').html(text)
  }
  /**
   * @param  {String} bubbleId html id of bubble.
   * Normally a bubble id "bubbleX" starts always with prefix "bubble", but we can call this function with the prefix (ex. "bubble0abc") or the id directly (ex. "0abc")
   * If there is no prefix, we add it
   */
  CommentsView.prototype.hideBubble = function (bubbleId) {
    if (bubbleId.indexOf(this.bubblePreId) == -1) {
      bubbleId = this.bubblePreId + bubbleId
    }
    $('#' + bubbleId).hide()
  }
  /**
   * hides the 'new comment' bubble
   */
  CommentsView.prototype.hideNewComment = function () {
    this.newComment = {}
    var newCommentEl = $('#' + this.newCommentId)
    newCommentEl.find('input[name="commentId"]').val('')
    newCommentEl.find('textarea').val('')
    newCommentEl.hide()
  }
  return CommentsView
})
define('modules/Comments/src/CommentsController', [
  'pubsub',
  'jquery',
  'modules/Comments/src/CommentsModel',
  'modules/Comments/src/CommentsView',
], function (pubsub, $, CommentsModel, CommentsView) {
  /**
   * Audio comments controller
   * @exports AudioComments/CommentsController
   * @param {AudioModule} audio
   * @param {LSViewer} viewer
   * @param {song} song
   * @param {Object} userSession    with fields {'name': "Jon", id:'4abcgf4435', pathImg: 'path/to/img'}
   *
   * @param {Object} serverAudioComments is an external objects that can allow to save comment to a server
   */
  function CommentsController(params, serverComments) {
    params = params || {}

    if (!params.viewer || !params.song || !params.userSession || !params.userSession.name || !params.userSession.id) {
      throw 'CommentsController - wrong params'
    }

    var audioDrawer = params.audio && params.audio.drawer ? params.audio.drawer : undefined

    this.model = new CommentsModel(serverComments)
    this.view = new CommentsView(
      params.viewer,
      params.song,
      audioDrawer,
      params.noteSpaceManager,
      params.notesCursor,
      params.chordsEditor
    )
    this.song = params.song
    this.user = params.userSession
    this.commentsShowingBubble = []
    this.initSubscribe()
  }

  CommentsController.prototype.initSubscribe = function () {
    var self = this
    /**
     * draw comments when audio has been drawn
     */
    $.subscribe('AudioDrawer-audioDrawn', function () {
      self.model.getComments('audio', function (comments) {
        self.view.draw(comments, self.user.id)
      })
    })

    //ScoreComments
    $.subscribe('LSViewer-drawEnd', function () {
      self.model.getComments('score', function (comments) {
        self.view.draw(comments, self.user.id)
      })
    })
    //comments are activated by K-key
    $.subscribe('K-key', function (el) {
      self.view.showNewComment()
    })
    // showing audio comment could be directly done on audio selection
    // (BUT there is an issue, audioCursor is 'disabled', as we have not released the mouse button yet in this moment )
    //
    // $.subscribe('AudioCursor-selectedAudio', function(el, startCursor, endCursor) {
    // 	self.view.showNewComment();
    // });

    $.subscribe('CommentSpaceManager-clickedComment', function (el, commentId) {
      //If shown, hide. If hidden, show
      if (self.commentsShowingBubble.indexOf(commentId) === -1) {
        self.showComment(commentId /*, orderedIndex*/)
      } else {
        self.hideComment(commentId)
      }
    })
    $.subscribe('CommentsView-closeBubble', function (el, commentId) {
      self.hideComment(commentId)
    })
    $.subscribe('CommentsView-saveComment', function (el, comment) {
      comment.userId = self.user.id
      comment.userName = self.user.name
      comment.img = self.user.img
      comment.type = self.view.newComment.type
      self.saveComment(comment, function (commentId) {
        $.publish('ToViewer-draw', self.song)
        //we show comment bubble after waiting 200 ms, time enough to let 'toViewer-draw' finish drawing all comments, otherwise it would give an error
        setTimeout(function () {
          self.showComment(commentId)
        }, 200)
      })
    })
    $.subscribe('CommentsView-updateComment', function (el, commentId, text) {
      self.updateComment(commentId, text)
    })
    $.subscribe('CommentsView-editingComment', function (el, bubbleEl, commentId) {
      var comment = self.model.getComment(commentId)
      self.view.showEditingComment(bubbleEl, comment.text, commentId, self)
    })
    $.subscribe('CommentsView-removingComment', function (el, bubbleEl, commentId) {
      bubbleEl.remove()
      self.model.removeComment(commentId, function () {
        $.publish('ToViewer-draw', self.song)
      })
    })
  }
  CommentsController.prototype.hideComment = function (commentId) {
    this.view.hideBubble(commentId)
    //remove element from array
    var index = this.commentsShowingBubble.indexOf(commentId)
    this.commentsShowingBubble.splice(index, 1)
  }
  /**
   * calls view showBubble, and saves the information needed to remember that comment is being shown
   * @param  {String} commentId
   * @param  {String} orderedIndex
   * @param  {Integer|String} orderedIndex
   */
  CommentsController.prototype.showComment = function (commentId, orderedIndex) {
    if (this.commentsShowingBubble.indexOf(commentId) === -1) {
      this.commentsShowingBubble.push(commentId)
    }
    this.view.showBubble(commentId)
  }
  CommentsController.prototype.saveComment = function (comment, callback) {
    var self = this
    this.model.saveComment(comment, callback)
  }
  CommentsController.prototype.updateComment = function (commentId, text) {
    var self = this
    this.model.updateComment(commentId, text, function () {
      self.view.updateComment(commentId, text)
      self.showComment(commentId)
    })
  }

  /**
   * this function is only used in test examples, to load comments directly (when there is no database to load comments from)
   * @param {String} comment
   */
  CommentsController.prototype.addComment = function (comment) {
    this.model.addComment(comment)
  }
  return CommentsController
})
define('modules/core/src/TimeSignatureModel', [], function () {
  /**
   * TimeSignature is a model to represent time signature for songmodel or barmodel, it contains all informations
   * about beatUnit and number of beats in a bar
   * @exports core/TimeSignatureModel
   */
  function TimeSignatureModel(timeSig) {
    var re = /\d\/\d/

    if (!timeSig || !timeSig.match(re)) {
      throw 'TimeSignatureModel - Time signature not valid ' + timeSig
    }

    var timeSigArr = timeSig.split('/')

    // eg. 6/8 will be numBeats = 6 and beatUnit = 8
    this.numBeats = parseInt(timeSigArr[0], 10)
    this.beatUnit = parseInt(timeSigArr[1], 10)
  }

  /**
   * The function returns the number of beats from the timeSig arguments or by default on current timeSignature
   * @return {int} number of beats in a measure  in the unit of the signature. E.g.: for 6/8 -> 6, for 4/4 -> 4 for 2/2 -> 2
   */
  TimeSignatureModel.prototype.getBeats = function () {
    return this.numBeats
  }

  /**
   * The function returns the beats unit from the current time signature
   * @return {int} beat unit in a measure. E.g.: for 6/8 -> 0.5, for 4/4 -> 1 for 2/2 -> 2
   */
  TimeSignatureModel.prototype.getBeatUnitQuarter = function () {
    return 4 / this.beatUnit
  }

  TimeSignatureModel.prototype.getBeatUnit = function () {
    return this.beatUnit
  }
  /**
   * @return {int} number of quarter beats in a measure, e.g. for 6/8 -> 3, for 4/4 -> 4, for 2/2 -> 4
   */
  TimeSignatureModel.prototype.getQuarterBeats = function () {
    return (4 / this.beatUnit) * this.numBeats
  }

  /**
   * @return {string} return a string of the timesignature in the type 3/4
   */
  TimeSignatureModel.prototype.toString = function () {
    return this.numBeats + '/' + this.beatUnit
  }

  return TimeSignatureModel
})
define('modules/core/src/SongBarChange', [], function () {
  /**
   * This class abstracts the logic to treat changes on time signature and key signature in a leadsheet. It is used only by SongBarsIterator.
   * 'Elem' part in properties name refers to the actual element which can be either time signature or key signature
   * @param {SongBarsIterator} barsIt
   * @param {String} getBarChangeFn    represents a method of BarModel to call.  Possible values "getTimeSignatureChange" or "getKeySignatureChange"
   * @param {String} getElementValueFn represents a method of SongModel or SectionMdoel. Possible values "getTimeSignature" or "getTonality"
   * @param {Object} constructor             element constructor if needed. Is the case of time signature
   */
  function SongBarsChange(barsIt, getBarChangeFn, getElementValueFn, constructor) {
    this.getBarChangeFn = getBarChangeFn
    this.getElementValueFn = getElementValueFn
    this.barsIt = barsIt
    this.beforeEnding = null
    this.constructor = constructor
    this.prevElemValue = null
  }
  SongBarsChange.prototype = {
    reset: function () {
      this.beforeEnding = null
      this.prevElemValue = null
    },
    setPrevValue: function (val) {
      this.prevElemValue = val
    },
    getPrevValue: function () {
      return this.prevElemValue
    },
    setBeforeEndingValue: function (val) {
      this.beforeEnding = val
    },
    getBeforeEndingValue: function () {
      return this.beforeEnding
    },
    getBarChange: function () {
      var barChange = this.barsIt.getBar()[this.getBarChangeFn]()
      if (barChange) {
        return barChange
      } else {
        var sectionChange
        //if we are at a new section, we add a time signature change
        if (this.barsIt.isFirstSectionBar) {
          var section = this.barsIt.song.getSection(this.barsIt.iSection)
          var sectionChange = section[this.getElementValueFn] ? section[this.getElementValueFn]() : null //if function does not exists, returns null (it's the case of getTonality)
          return sectionChange
            ? this.constructor
              ? new this.constructor(sectionChange)
              : sectionChange //time signature needs a constructor where key signature is just a string
            : null
        }
      }
    },
    getBarElemValue: function () {
      var elemValue = this.getBarChange()
      if (elemValue) {
        return elemValue
      } else if (this.barsIt.prevEnding == 1 && this.barsIt.getEnding(this.barsIt.isFirstSectionBar) == 2) {
        // is important to use == instead of === as we are comparing sometimes string to numbers
        // when we are in the bar just after ending 1, we return bar time signature we had before ending 1,
        //so that signature changes to ending 1 are not anymore taken into account
        return this.beforeEnding
      } else {
        //case we are in first bar
        return this.barsIt.index === 0 ? this.barsIt.song[this.getElementValueFn]() : this.prevElemValue
      }
    },
  }
  return SongBarsChange
})
define('modules/core/src/SongBarsIterator', [
  'modules/core/src/TimeSignatureModel',
  'modules/core/src/SongBarChange',
], function (TimeSignatureModel, SongBarChange) {
  /**
   * Iterator that allow to go through bars
   * @exports core/SongBarsIterator
   */

  function SongBarsIterator(song) {
    this.song = song
    this.bm = this.song.getComponent('bars')
    this.timeSigMng = new SongBarChange(this, 'getTimeSignatureChange', 'getTimeSignature', TimeSignatureModel)
    this.keySigMng = new SongBarChange(this, 'getKeySignatureChange', 'getTonality')
    this.reset()
  }
  SongBarsIterator.prototype = {
    _getTimeSignatureChange: function () {
      return
      // var barSigChange = this.getBar().getTimeSignatureChange();
      // if (barSigChange){
      // 	return barSigChange;
      // }else{
      // 	var sectionTimeSig;
      //  	//if we are at a new section, we add a time signature change
      // 	if (this.isFirstSectionBar){
      // 		sectionTimeSig = this.song.getSection(this.iSection).getTimeSignature();
      // 		return sectionTimeSig ? new TimeSignatureModel(sectionTimeSig) : null;
      // 	}
      // }
    },

    reset: function () {
      this.index = 0
      this.iSection = 0
      this.iSectionNumbars = 0 // sum of bars in previous sections
      this.isFirstSectionBar = true
      this.timeSigMng.reset()
      this.keySigMng.reset()
      this.endingState = null
      this.ending = null
      this.beats = 1
    },
    /**
     *	if true, it means we are at the last iteration, should be used like this
     *	while(songBarsIt.hasNext())
     *	{
     *		//here goes all the logic to do on current bar
     *		songBarsIt.next();
     *	}
     *
     *	(apparently all iterators work the other around, first 'next()', then logic, TODO: change)
     *
     * @return {Boolean}
     */
    hasNext: function () {
      return this.index < this.bm.getTotal()
    },

    /**
     *	steps forward, returns if it hasNext after making the step, this way we can check if we can move one step forward.
     *	Useful if we want to get information about next iteration on a loop
     *
     * while( loop ){
     * 		//logic
     *
     * 	if (songBarIt.next()){
     *		//get info about next bar
     *	}
     *
     * }
     *
     *
     * @return {Boolean}
     */
    next: function () {
      var keySig = this.getBarKeySignature()
      var timeSig = this.getBarTimeSignature()

      this.timeSigMng.setPrevValue(timeSig)
      this.keySigMng.setPrevValue(keySig)

      this.beats += timeSig.getQuarterBeats()
      // section
      var sectionNumBars = this.song.getSection(this.iSection).getNumberOfBars()
      if (this.index === this.iSectionNumbars + sectionNumBars - 1) {
        this.iSectionNumbars += sectionNumBars
        this.iSection++
        this.isFirstSectionBar = true
      } else {
        this.isFirstSectionBar = false
      }
      var ending = this.getEnding(this.isFirstSectionBar)
      this.prevEnding = ending
      //we calculate always timeSig before endings, except if it is ending 1, because we will retrieve it after ending one
      if (ending != 1) {
        this.timeSigMng.setBeforeEndingValue(timeSig)
        this.keySigMng.setBeforeEndingValue(keySig)
      }
      this.index++
      return this.hasNext()
    },
    setBarIndex: function (index) {
      if (index < this.index) {
        throw 'index is ' + this.index + ', cannot go backwards to ' + index
      }
      while (this.index != index) {
        this.next()
      }
    },
    getBarIndex: function () {
      return this.index
    },
    getBar: function () {
      return this.bm.getBar(this.index)
    },
    getFollowingBar: function () {
      return this.bm.getBar(this.index + 1)
    },
    getPrevKeySignature: function () {
      return this.keySigMng.getPrevValue()
    },
    getPrevTimeSignature: function () {
      return this.timeSigMng.getPrevValue()
    },
    getBarKeySignature: function () {
      return this.keySigMng.getBarElemValue()
    },
    getBarTimeSignature: function () {
      return this.timeSigMng.getBarElemValue()
    },
    doesTimeSignatureChange: function () {
      var timeSig = this.timeSigMng.getBarChange()
      return !!timeSig && timeSig != this.timeSigMng.getPrevValue()
    },
    getStartEndBeats: function () {
      return [this.beats, this.beats + this.getBarTimeSignature().getQuarterBeats()]
    },
    getEnding: function (isFirstSectionBar) {
      if (isFirstSectionBar) {
        return this.getBar().getEnding()
      } else {
        return this.getBar().getEnding() || this.prevEnding
      }
    },
    /**
     * getEndingState and setEndingState are functions used when drawing the ending boxes. The values can be 'BEGIN', 'MID', 'BEGIN_END', 'END'
     */
    getEndingState: function () {
      return this.endingState
    },
    setEndingState: function (endingState) {
      this.endingState = endingState
    },
    isLast: function () {
      return this.index == this.bm.getTotal() - 1
    },
  }
  return SongBarsIterator
})
define('utils/NoteUtils', [], function () {
  var NoteUtils = {}
  NoteUtils.ACCIDENTALS = ['bb', 'b', '', '#', '##']
  NoteUtils.NATURAL_PITCHES = {
    C: 0,
    D: 1,
    E: 2,
    F: 3,
    G: 4,
    A: 5,
    B: 6,
  }
  NoteUtils.pitch2Number = function (pitch) {
    var naturalPitch = pitch.substring(0, 1)
    var accidental = pitch.substring(1, pitch.length)
    var number = this.PITCH_2_NUMBER[naturalPitch]
    for (var i = 0; i < NoteUtils.ACCIDENTALS.length; i++) {
      if (accidental == NoteUtils.ACCIDENTALS[i]) {
        return (number += i - 2)
        return number < 0 ? number : number + 12
      }
    }
  }
  NoteUtils.PITCH_CLASSES = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
  NoteUtils.ASC_CHROMATIC_PITCHES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
  NoteUtils.DESC_CHROMATIC_PITCHES = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
  NoteUtils.PITCH_2_NUMBER = {
    C: 0,
    'C#': 1,
    Db: 1,
    D: 2,
    'D#': 3,
    Eb: 3,
    E: 4,
    Fb: 4,
    'E#': 5,
    F: 5,
    'F#': 6,
    Gb: 6,
    G: 7,
    'G#': 8,
    Ab: 8,
    A: 9,
    'A#': 10,
    Bb: 10,
    B: 11,
    Cb: 11,
    'B#': 0,
  }

  NoteUtils.DURATIONS = {
    4: 'w',
    2: 'h',
    1: 'q',
    0.5: '8',
    0.25: '16',
    0.125: '32',
    0.0625: '64',
  }
  NoteUtils.ARR_DUR = [
    {
      strDur: 'w',
      numDur: 4,
    },
    {
      strDur: 'h',
      numDur: 2,
    },
    {
      strDur: 'q',
      numDur: 1,
    },
    {
      strDur: '8',
      numDur: 0.5,
    },
    {
      strDur: '16',
      numDur: 0.25,
    },
    {
      strDur: '32',
      numDur: 0.125,
    },
    {
      strDur: '64',
      numDur: 0.0625,
    },
  ]

  NoteUtils.getStringFromBeatDuration = function (beat) {
    return NoteUtils.DURATIONS[beat]
  }

  NoteUtils.getBeatFromStringDuration = function (string) {
    for (var dur in NoteUtils.DURATIONS) {
      if (NoteUtils.DURATIONS[dur] === string) {
        return Number(dur)
      }
    }
  }

  /**
   * sorting pitches in case of polyphony because Vexflow adds accidentals in order relating to pitch order,
   * not to the actual array order
   * @param  {Array} pitches e.g.: ["A"]
   * @return {Array}         [description]
   */
  NoteUtils.sortPitches = function (pitches) {
    /**
     * @param  {string} pitch1 example: "A/4"
     * @param  {string} pitch2 example: "Db/3"
     * @return {int}    1 if (pitch1>pitch2), 0 if they are equal, -1 if (pitch1<pitch2)
     */
    function comparePitches(pitch1, pitch2) {
      var r
      var pc1 = pitch1.substring(0, 1).toUpperCase()
      var oct1 = parseInt(pitch1.slice(-1), null)
      var pc2 = pitch2.substring(0, 1).toUpperCase()
      var oct2 = parseInt(pitch2.slice(-1), null)

      if (oct1 > oct2) r = 1
      else if (oct1 < oct2) r = -1
      else {
        //if equal
        var map = NoteUtils.NATURAL_PITCHES

        if (map[pc1] > map[pc2]) r = 1
        if (map[pc1] < map[pc2]) r = -1
        else r = 0
      }
      return r
    }

    var pitchClass,
      octave,
      sortedPitches = [],
      curPitch,
      prevPitch = null,
      i = 0,
      inserted,
      op,
      resultComparison,
      oPitch

    for (var p in pitches) {
      curPitch = pitches[p]
      if (sortedPitches.length === 0) {
        sortedPitches.push(curPitch)
      } else {
        inserted = false
        op = 0
        while (inserted === false && op < sortedPitches.length) {
          oPitch = sortedPitches[op]
          resultComparison = comparePitches(curPitch, oPitch)
          if (resultComparison < 0) {
            sortedPitches.splice(op, 0, curPitch)
            inserted = true
          }
          op++
        }
        if (inserted === false) {
          sortedPitches.push(curPitch)
        }
      }
    }
    return sortedPitches
  }

  NoteUtils.number2Pitch = function (number) {
    var number2PitchArray = {
      0: 'C',
      1: 'C#',
      2: 'D',
      3: 'D#',
      4: 'E',
      5: 'F',
      6: 'F#',
      7: 'G',
      8: 'G#',
      9: 'A',
      10: 'A#',
      11: 'B',
    }
    number = (number + 12) % 12
    var pitch
    if (typeof number2PitchArray[number] !== 'undefined') {
      pitch = number2PitchArray[number]
    }
    return pitch
  }

  NoteUtils.transformStringNote2ArrayNote = function (chordString) {
    var chordArray = []
    if (typeof chordString !== 'undefined') {
      var chord = chordString.split(',')
      for (var i = 0; i < chord.length; i++) {
        var s = /[A-Z][b,#]{0,2}[0-9]?/i.exec(chord[i])
        if (s) {
          chordArray.push(s[0])
        }
      }
    }
    return chordArray
  }

  NoteUtils.getValidPitch = function (value) {
    var re = /[a-g|A-G]/
    if (typeof value === 'number') {
      return -1
    } else {
      if (!value.match(re)) return -1
      else return value.toUpperCase()
    }
  }

  NoteUtils.getClosestKey = function (pitch, pitchClass2) {
    var pitchClass = pitch.split('/')[0]
    var pitches = this.PITCH_CLASSES
    var pos1 = this.getKeyPosition(pitchClass, pitches)
    var pos2 = this.getKeyPosition(pitchClass2, pitches)
    var d1 = pos2 - pos1
    var d2 = pitches.length - Math.abs(d1)
    if (d1 > 0) d2 *= -1
    var inc = Math.abs(d2) < Math.abs(d1) ? d2 : d1
    return this.getNextKey(pitch, inc)
  }

  NoteUtils.getKeyPosition = function (key, pitches) {
    for (var i = 0; i < pitches.length; i++) {
      if (pitches[i] == key) break
    }
    return i
  }
  NoteUtils._parseNote = function (note, parseAccidental) {
    var noteParts = note.split('/')
    var noteObj = {
      octave: parseInt(noteParts[1], null),
    }
    var pitch = noteParts[0]
    noteObj.pitch = parseAccidental ? pitch[0] : pitch

    if (parseAccidental) {
      noteObj.accidental = pitch.length == 2 ? pitch[1] : ''
    }
    return noteObj
  }

  NoteUtils._getKey = function (note, inc, pitches, isChromatic) {
    var currentPos = isChromatic ? this.pitch2Number(note.pitch) : this.getKeyPosition(note.pitch, pitches)
    var newAbsPos = currentPos + inc
    var newPos = newAbsPos % pitches.length
    if (newPos < 0) newPos += pitches.length

    var octavesInc = Math.floor(newAbsPos / pitches.length)
    var newOctave = note.octave + octavesInc
    //range: from e/3 to f/6
    if ((newOctave <= 1 && newPos < 2) || (newOctave >= 7 && newPos > 3)) return null
    else
      return {
        pitch: pitches[newPos],
        octave: newOctave,
      }
  }
  NoteUtils.getNextKey = function (key, inc) {
    var note = this._parseNote(key, true)
    var newNote = this._getKey(note, inc, this.PITCH_CLASSES, false)
    if (newNote) {
      return newNote.pitch + note.accidental + '/' + newNote.octave
    }
  }
  NoteUtils.getNextChromaticKey = function (key, inc, withoutOctave) {
    var note = this._parseNote(key)
    var pitches = inc > 0 ? this.ASC_CHROMATIC_PITCHES : this.DESC_CHROMATIC_PITCHES
    var newNote = this._getKey(note, inc, pitches, true)
    if (newNote) {
      return withoutOctave ? newNote.pitch : newNote.pitch + '/' + newNote.octave
    }
  }
  /**
   * @param  {Number}		4.5,
   * @param  {Number}		0.5
   * @return {Array}		array of notes
   */
  NoteUtils.durationToNotes = function (duration, initBeat) {
    var durs = ['w', 'h', 'q', '8', '16', '32', '64']

    function findDur(arrNotes, indexes, duration) {
      arrNotes = arrNotes || []
      indexes = indexes || []
      var matchedDur = 4
      var iDur = 0
      while (iDur <= durs.length) {
        if (duration == matchedDur) {
          arrNotes.push(durs[iDur])
          indexes.push(iDur)
          break
        } else if (duration > matchedDur) {
          arrNotes.push(durs[iDur])
          indexes.push(iDur)
          arrNotes = findDur(arrNotes, indexes, duration - matchedDur)
          break
        }
        iDur++
        matchedDur /= 2
      }
      return {
        notes: arrNotes,
        indexes: indexes,
      }
    }

    function mergeByDot(notes, indexes) {
      var mergedNotes = [],
        dot = 0,
        curIndex,
        prevIndex,
        curNote,
        prevNote

      for (var i = notes.length - 1; i > 0; i--) {
        curIndex = indexes[i]
        prevIndex = indexes[i - 1]

        if (curIndex - 1 === prevIndex) {
          if (dot === 0) {
            dot++
            notes[i - 1] += '.'
          } else if (dot === 1) {
            dot++
            notes[i - 1] += '..'
          } else {
            dot = 0
            mergedNotes.push(notes[i])
          }
        } else {
          mergedNotes.push(notes[i])
        }
      }
      mergedNotes.push(notes[i])
      return mergedNotes
    }

    var notes = []
    var indexes = []
    findDur(notes, indexes, duration)
    // console.log(notes);
    // console.log(indexes);
    notes = mergeByDot(notes, indexes)

    return notes
  }
  NoteUtils.roundBeat = function (beat) {
    return Math.round(beat * 1000000) / 1000000
  }

  return NoteUtils
})
define('modules/core/src/PitchClass', ['utils/NoteUtils'], function (NoteUtils) {
  /**
   * PitchClass useful to transpose bu interval (TODO: integrate in NoteModel ?)
   * @param {String} pitch e.g.: "A", "A#"
   */
  function PitchClass(pitch) {
    this.name = pitch.substring(0, 1) // "A","B"
    this.accidental = pitch.substring(1, pitch.lengh) //"#", "##"
    this.semitoneCount = NoteUtils.pitch2Number(pitch)
  }

  PitchClass.prototype.toString = function () {
    return this.name + this.accidental
  }
  /**
   * gets the semitone distances between current pitchClass and pc2
   * @param  {PitchClass} pc2       pitch class to compare to
   * @param  {Number} direction either 1 or -1
   * @return {Number} semitones difference
   */
  PitchClass.prototype._semitonesDiff = function (pc2, direction) {
    var pc2semitoneCount = pc2.semitoneCount

    if (
      this.semitoneCount != pc2.semitoneCount /*this.name != pc2.name &&*/ &&
      this.semitoneCount > pc2.semitoneCount == direction > 0
    ) {
      pc2semitoneCount += 12 * direction // in case both are false, direction is -1, otherwise direction is 1
    }
    return pc2semitoneCount - this.semitoneCount
  }
  /**
	   return resulting natural pitch of adding interval, e.g. A + perfectFourth, returns D and octaveDiff 1
	 * @param  {String} name         pitch name e.g. "A","B","C"...etc.
	 * @param  {Number} intervalType natural interval. e.g. 3 for third, regardless if it is major, minor or augmented
	 * @param  {Number} direction    either 1 or -1
	 * @return {Object}              {pitchClassName: "D", octaveDiff: 1}
	 */
  PitchClass.prototype._sumNaturalCount = function (name, intervalType, direction) {
    direction = direction || 1
    var naturalCount = NoteUtils.NATURAL_PITCHES[name]
    var naturalCountEnd = naturalCount + (intervalType - 1) * direction
    var octaveDiff = naturalCountEnd < 0 || naturalCountEnd >= 7 ? direction : 0
    naturalCount = naturalCountEnd % 7 // -1 because interval type includes starting position. e.g. C - E is a 3rd, whereas C + 2 = E
    if (naturalCount < 0) naturalCount += 7
    return {
      pitchClassName: NoteUtils.PITCH_CLASSES[naturalCount],
      octaveDiff: octaveDiff,
    }
  }
  /**
   * sets accidental to a new pitch witch has no accidental dpending on semitones to move.
   * @param {number} semitonesToMove e.g. if semitonesToMove = 2, this.accidental is set to "##"
   */
  PitchClass.prototype._setAccidental = function (semitonesToMove) {
    this.accidental = NoteUtils.ACCIDENTALS[2 + semitonesToMove] // position 2 is where empty accidental is, in this point, we will always start form empty accidental
  }

  /**
   * @param  {Interval} interval  object representing interval to move, e.g. perfectFifth
   * @param  {Number} direction either 1 or -1
   * @param  {Boolean} getOctave if true, we return octave also
   * @return {String|Object}           (depending on getOctave)
   */
  PitchClass.prototype.transposeBy = function (interval, direction, getOctave) {
    direction = direction || 1

    //to avoid errors we substitute
    if (this.accidental.length == 2) {
      if (this.accidental == '##') this.name = this._sumNaturalCount(this.name, 2, 1).pitchClassName
      if (this.accidental == 'bb') this.name = this._sumNaturalCount(this.name, 2, -1).pitchClassName
      this.accidental = ''
    }

    var r = this._sumNaturalCount(this.name, interval.type, direction)
    var newPitch = new PitchClass(r.pitchClassName),
      octaveDiff = r.octaveDiff
    var semitonesDiff = this._semitonesDiff(newPitch, direction)
    var semitonesToMove = interval.semitones - Math.abs(semitonesDiff)
    newPitch._setAccidental(semitonesToMove * direction)

    // if accidental is undefined it means it should be a bbb or ###, we find equivalent. e.g : F### ==> G#
    if (newPitch.accidental === undefined) {
      newPitch._setAccidental(semitonesToMove * direction + 2 * direction * -1)
      var equivalentPitch = newPitch._sumNaturalCount(newPitch.name, 2, direction) // moving a second
      newPitch.name = equivalentPitch.pitchClassName
      //  case in which we have to change octave,
      //	e.g. G## + augemented third -> B### which would be switched to  C#, but in that case we are changing octave, so take it into account
      octaveDiff += equivalentPitch.octaveDiff
    }
    if (newPitch.accidental === undefined) {
      newPitch._setAccidental(semitonesToMove * direction + 4 * direction * -1)
      var equivalentPitch = newPitch._sumNaturalCount(newPitch.name, 2, direction) // moving a second
      newPitch.name = equivalentPitch.pitchClassName
      //  case in which we have to change octave,
      //	e.g. G## + augemented third -> B### which would be switched to  C#, but in that case we are changing octave, so take it into account
      octaveDiff += equivalentPitch.octaveDiff
    }

    return getOctave
      ? {
          newPitch: newPitch,
          octaveDiff: octaveDiff,
        }
      : newPitch
  }
  return PitchClass
})
define('utils/UserLog', ['jquery'], function ($) {
  var UserLog = {
    type: 'info',
    title: 'Untitled',
    element: $('body')[0],
    speed: 5000,
  }

  UserLog.setOptions = function (options) {
    if (typeof options === 'undefined') {
      return
    }
    if (typeof options.type !== 'undefined') {
      this.type = options.type
    }
    if (typeof options.title !== 'undefined' && !isNaN(title)) {
      this.title = options.title
    }
    if (typeof options.element !== 'undefined') {
      this.element = options.element
    }
    if (typeof options.speed !== 'undefined' && !isNaN(speed)) {
      this.speed = options.speed
    }
  }

  /**
   * Call log function to send a message to user, message will automatically fadeOut quickly
   * @param  {string} type         Define the type of message you are sending: 'info', 'success', 'warn' or 'error' (by default it's set to info)
   * @param  {string} title        Title is the text that will be displayed to the user, it can contain variables
   * @param  {HTMLElement} element HTMLElement where the span message will be inserted (it's inserted before this element) (by default it's on body)
   */
  UserLog.logAutoFade = function (type, title, element, speed) {
    if (typeof type === 'undefined') {
      type = this.type
    }
    if (typeof title === 'undefined') {
      title = this.title
    }
    if (typeof element === 'undefined') {
      element = this.element
    }
    if (typeof speed === 'undefined') {
      speed = this.speed
    }
    var className = ''
    switch (type) {
      case 'info':
        className = 'alert alert-info'
        break
      case 'success':
        className = 'alert alert-success'
        break
      case 'warn':
        className = 'alert alert-warning'
        break
      case 'error':
        className = 'alert alert-error'
        break
      default:
        className = 'alert alert-info'
    }
    var saveMsg = "<span class='" + className + "' style='position:fixed; z-index:9999; left:30%'>" + title + '</span>'
    $(saveMsg)
      .insertBefore(element)
      .fadeOut(speed, function () {
        $(this).remove()
      })
  }

  /**
   * Call log function to send a message to user, message will not be hidden unless you call remove
   * @param  {string} type         Define the type of message you are sending: 'info', 'success', 'warn' or 'error' (by default it's set to info)
   * @param  {string} title        Title is the text that will be displayed to the user, it can contain variables
   * @param  {HTMLElement} element HTMLElement where the span message will be inserted (it's inserted before this element) (by default it's on body)
   * @return {string} Return the logList id of the newly created dom element
   */
  UserLog.log = function (type, title, element) {
    if (typeof type === 'undefined') {
      type = this.type
    }
    if (typeof title === 'undefined') {
      title = this.title
    }
    if (typeof element === 'undefined') {
      element = this.element
    }
    var className = ''
    switch (type) {
      case 'info':
        className = 'alert alert-info'
        break
      case 'success':
        className = 'alert alert-success'
        break
      case 'warn':
        className = 'alert alert-warning'
        break
      case 'error':
        className = 'alert alert-error'
        break
      default:
        className = 'alert alert-info'
    }
    var id = Math.round(Math.random() * 1000) + '-' + Date.now()
    var saveMsg =
      "<span class='" +
      className +
      "' id='logId-" +
      id +
      "' style='position:fixed; z-index:9999; left:35%'>" +
      title +
      '</span>'
    $(saveMsg).insertBefore(element)
    return id
  }

  UserLog.removeLog = function (id) {
    if (typeof id === 'undefined') {
      console.warn('UserLog - remove - id undefined ' + id)
    }
    $('#logId-' + id).remove()
  }

  return UserLog
})
define('modules/ChordEdition/src/ChordEditionController', [
  'mustache',
  'modules/core/src/SongBarsIterator',
  'utils/NoteUtils',
  'modules/core/src/PitchClass',
  'utils/UserLog',
  'jquery',
  'pubsub',
], function (Mustache, SongBarsIterator, NoteUtils, PitchClass, UserLog, $, pubsub) {
  /**
   * ChordEditionController manages all chords edition function
   * @exports ChordEdition/ChordEditionController
   */
  function ChordEditionController(songModel, cursor, chordSpaceMng) {
    if (!songModel || !cursor || !chordSpaceMng) {
      throw 'ChordEditionController params are wrong'
    }
    this.songModel = songModel
    this.cursor = cursor
    this.chordSpaceMng = chordSpaceMng
    this.initSubscribe()
  }

  /**
   * Subscribe to view events
   */
  ChordEditionController.prototype.initSubscribe = function () {
    var self = this

    $.subscribe('ChordEditionView', function (el, fn, param) {
      if (self.chordSpaceMng.isEnabled()) {
        self[fn].call(self, param)
        $.publish('ToViewer-draw', self.songModel)
      }
    })
  }

  ChordEditionController.prototype.setChordPitch = function (inc) {
    var chordMng = this.songModel.getComponent('chords')
    var indexes = this.getSelectedChordsIndexes()
    var chord
    for (var i = 0; i < indexes.length; i++) {
      chord = chordMng.getChord(indexes[i])
      chord.setNote(NoteUtils.getNextChromaticKey(chord.getNote(), inc, true))
    }
  }

  ChordEditionController.prototype.deleteChords = function () {
    var beats = this.getSelectedChordsBeats()
    var chordMng = this.songModel.getComponent('chords')
    var self = this
    var firstChordSpace = chordMng.getBarNumAndBeatFromBeat(this.songModel, beats[0])
    var lastChordSpace = chordMng.getBarNumAndBeatFromBeat(this.songModel, beats[1] - 1)
    if (lastChordSpace.exceedsSongLength) {
      //when we are removing last positions, we just set lastChordSpace greater than last position
      var lastChordSpaceView = this.chordSpaceMng.chordSpaces[this.chordSpaceMng.chordSpaces.length - 1]
      lastChordSpace.barNumber = lastChordSpaceView.barNumber + 1
      lastChordSpace.beatNumber = lastChordSpaceView.beatNumber + 1
    }
    chordMng.removeChordsBetweenPositions(
      firstChordSpace.barNumber,
      firstChordSpace.beatNumber,
      lastChordSpace.barNumber,
      lastChordSpace.beatNumber
    )

    $.publish('ToHistory-add', 'Remove chord')
  }

  /*ChordEditionController.prototype.addChord = function() {
		console.log('addChord');
		// editor.addChord();
	};*/
  ChordEditionController.prototype.toggleEditChord = function () {
    console.log('toggleEditChord')
  }

  ChordEditionController.prototype.copyChords = function () {
    this.buffer = this.getSelectedChordsBeats()
    //this.buffer now equals to [startBeat, endBeat]
  }

  ChordEditionController.prototype.pasteChords = function () {
    if (!this.buffer || this.buffer.length === 0) {
      return
    }
    var chordMng = this.songModel.getComponent('chords')
    var arrBeatChords = chordMng.getBeatsBasedChordIndexes(this.songModel)
    var indexesBeats = chordMng.getChordsRelativeToBeat(this.songModel, this.buffer[0], this.buffer[1], arrBeatChords)
    // indexesBeat is an array of objects {index: 1, beat: 2} (with the index of the chord, and the beat differents to start beat of selected sections)

    if (indexesBeats.length === 0) {
      //no chords selected
      return
    }

    var pos1 = indexesBeats[0].index
    var pos2 = indexesBeats[indexesBeats.length - 1].index

    var copiedChords = chordMng.cloneElems(pos1, pos2 + 1)
    var startPasteBeat = this.getSelectedChordsBeats()[0]
    var endPasteBeat = startPasteBeat + this.buffer[1] - this.buffer[0] - 1

    // remove chords in affected chordspaces
    var firstChordSpace = chordMng.getBarNumAndBeatFromBeat(this.songModel, startPasteBeat)
    var lastChordSpace = chordMng.getBarNumAndBeatFromBeat(this.songModel, endPasteBeat)
    if (firstChordSpace.exceedsSongLength || lastChordSpace.exceedsSongLength) {
      throw 'ChordEdition error exceedsSongLength'
    }
    chordMng.removeChordsBetweenPositions(
      firstChordSpace.barNumber,
      firstChordSpace.beatNumber,
      lastChordSpace.barNumber,
      lastChordSpace.beatNumber
    )

    //we copy chords
    var pasteBeat, numBarAndBeat, barNumAndBeat
    for (var i = 0; i < indexesBeats.length; i++) {
      pasteBeat = indexesBeats[i].beat + startPasteBeat
      barNumAndBeat = chordMng.getBarNumAndBeatFromBeat(this.songModel, pasteBeat)
      if (!barNumAndBeat.notExactBeat) {
        copiedChords[i].setBarNumber(barNumAndBeat.barNumber)
        copiedChords[i].setBeat(barNumAndBeat.beatNumber)
        chordMng.addChord(copiedChords[i])
      }
    }

    var ch, str
    for (var i = 0; i < chordMng.getChords().length; i++) {
      ch = chordMng.getChords()[i]
      str = ch.toString() + ' ' + ch.getBarNumber() + ' ..  ' + ch.getBeat()
    }

    $.publish('ToHistory-add', 'Paste chord')
  }

  /*ChordEditionController.prototype.chordTabEvent = function(way) {
		console.log('chordTabEvent', way);
	};*/

  /**
   * returns start and end beats of chords taking into account cursor, depending on chordSpaces selected
   * @return {Array} [startBeat, endBeat]
   */
  ChordEditionController.prototype.getSelectedChordsBeats = function () {
    var songIt = new SongBarsIterator(this.songModel)
    var startChordSpace = this.chordSpaceMng.chordSpaces[this.cursor.getStart()]
    var startBarNum = startChordSpace.barNumber

    songIt.setBarIndex(startBarNum)
    var beatInc = 4 / songIt.getBarTimeSignature().getBeatUnit() //will be 1 for x/4 time signatures, 2 for x/2, and 0.5 for x/8
    var barBeatOffset = (startChordSpace.beatNumber - 1) * beatInc
    var startBeat = this.songModel.getStartBeatFromBarNumber(startBarNum) + barBeatOffset
    var iBeat = startBeat

    for (var i = this.cursor.getStart(); i <= this.cursor.getEnd(); i++) {
      if (barBeatOffset === songIt.getBarTimeSignature().getQuarterBeats() && songIt.hasNext()) {
        songIt.next()
        beatInc = 4 / songIt.getBarTimeSignature().getBeatUnit()
        barBeatOffset = 0
      } else if (barBeatOffset > songIt.getBarTimeSignature().getQuarterBeats()) {
        console.warn('barBeatOffset > total bar duration') //should never enter here
      }
      iBeat += beatInc
      barBeatOffset += beatInc
    }
    return [startBeat, iBeat]
  }
  /**
   * Returns indexes of chords depending on cursor position
   * @return {Array} index number of selected chords. e.g. [0,1,2]
   */
  ChordEditionController.prototype.getSelectedChordsIndexes = function () {
    var chordManager = this.songModel.getComponent('chords')
    var selectedChords = []
    for (var cursorIndex = this.cursor.getStart(); cursorIndex <= this.cursor.getEnd(); cursorIndex++) {
      var chordSpace = this.chordSpaceMng.chordSpaces[cursorIndex]
      var pos = {
        numBeat: chordSpace.beatNumber,
        numBar: chordSpace.barNumber,
      }
      var r = chordManager.getChordIndexByPosition(pos)
      if (r.exact) {
        selectedChords.push(r.index)
      }
    }
    return selectedChords
  }

  return ChordEditionController
})
define('modules/core/src/NoteModel', ['utils/NoteUtils'], function (NoteUtils) {
  /**
   * Note Model is a core model representing a leadsheet note
   * @exports core/NoteModel
   * @param {Object|String|null} param : depending on the type it will create an empty note, a rest note or a pitch note
   */
  function NoteModel(param) {
    this.pitchClass = [] // Note c, b
    this.octave = [] // octave from 0 to 8
    this.accidental = [] // b or #
    this.duration = param && param.duration ? param.duration : undefined // string duration "h", "q", "8", "16" ...etc
    this.isRest = param && param.isRest ? param.isRest : false
    this.dot = param && param.dot ? param.dot : 0 // 0,1,2
    this.tie = param && param.tie ? param.tie : undefined // contain "start", "stop", "stop_start"
    this.tuplet = param && param.tuplet ? param.tuplet : undefined
    this.timeModification = param && param.timeModification ? param.timeModification : undefined // it's an attribute that exist only with tuplet

    //for whole silences that cover an entire measure, duration will depend on bar's time signature:
    this.durationDependsOnBar = false
    this.barDuration = null

    if (typeof this.tuplet !== 'undefined') {
      this.setTuplet(this.tuplet, this.timeModification)
    }

    if (typeof param == 'string') {
      //duration "h","d","8" or C#/4-8r
      this.setNoteFromString(param)
    } else if (typeof param !== 'undefined' && typeof param.pitchList !== 'undefined') {
      if (param.pitchList.length > 1) {
        param.pitchList = NoteUtils.sortPitches(param.pitchList)
      }
      for (var i = 0, c = param.pitchList.length; i < c; i++) {
        this.setNoteFromString(param.pitchList[i], i)
      }
    }
  }

  /**
   *
   * @return {String} examples: "A#/4-q", "E/4-q.", "qr", "w.r"
   */
  NoteModel.prototype.toString = function () {
    var str,
      dur = this.duration
    for (var i = 0; i < this.dot; i++) {
      dur += '.'
    }
    if (this.timeModification) {
      dur += '(' + this.timeModification + ')'
    }
    if (this.isRest) {
      str = dur + 'r'
    } else {
      str = this.pitchClass[0] + this.accidental[0] + '/' + this.octave[0] + '-' + dur
    }
    return str
  }
  /**
   * String examples: C#/4-8.
   * @param {String} string string defining a note like C#/4-8
   * @param {Integer} index
   */
  NoteModel.prototype.setNoteFromString = function (string, index) {
    index = index || 0
    var re = /[a-g|A-G](#{1,2}|b{1,2}|n)?(-[w|h|q|8|16|32|64])?\.{0,2}\/\d/
    var partDuration
    if (string.match(re)) {
      var parts = string.split('-')
      var partPitch = parts[0].split('/')
      this.pitchClass[index] = partPitch[0].substr(0, 1).toUpperCase()
      this.accidental[index] = partPitch[0].substr(1, partPitch[0].length)
      this.octave[index] = partPitch[1]

      if (parts.length == 2) {
        partDuration = parts[1]
      }
    } else {
      re = /[w|h|q|8|16|32|64](r)?/
      if (!string.match(re)) {
        throw (
          'Creating pitch ' +
          string +
          ". Should be in de form [pitch][acc]/[octave]. e.g. Ab/4 or [duration] if you want a rest eg. '8'"
        )
      }
      this.pitchClass[0] = 'B'
      this.octave[0] = '4'
      this.accidental[0] = ''
      var restPosition = string.indexOf('r')
      if (restPosition === -1) {
        partDuration = string
      } else {
        partDuration = string.substr(0, restPosition)
      }
      this.isRest = true
    }
    if (partDuration) {
      // check if there is a dot
      var dotPosition = partDuration.indexOf('.')
      if (dotPosition == -1) {
        this.duration = partDuration
      } else {
        this.duration = partDuration.split('.')[0]
        this.dot = partDuration.length - dotPosition
      }
    }
  }

  NoteModel.prototype.getNumPitches = function () {
    return this.pitchClass.length
  }

  NoteModel.prototype.setPitchClass = function (value, i) {
    i = i || 0
    this.pitchClass[i] = value
  }

  NoteModel.prototype.getPitchClass = function (i) {
    i = i || 0
    return this.pitchClass[i]
  }

  NoteModel.prototype.getAccidental = function (i) {
    i = i || 0
    return this.accidental[i]
  }

  NoteModel.prototype.setOctave = function (octave, i) {
    i = i || 0
    this.octave[i] = octave
    return this.octave[i]
  }

  NoteModel.prototype.getOctave = function (i) {
    i = i || 0
    return this.octave[i]
  }

  /**
   * @param  {Number} index
   * @param  {Boolean} withoutSlash
   * @return {String}        e.g.: "A#/5", "Bb/4" or       "A#5", "Bb4"
   */
  NoteModel.prototype.getPitch = function (index, withoutSlash) {
    // check if number, check if  < numPitches
    index = index || 0

    var accidental = ''
    if (typeof this.accidental[index] !== 'undefined') {
      accidental = this.accidental[index]
    }

    var octave = ''
    if (typeof this.octave[index] !== 'undefined') {
      if (!withoutSlash) octave += '/'
      octave += this.octave[index]
    }
    return this.pitchClass[index] + accidental + octave
  }

  /**
   * @param {Number} dots
   */
  NoteModel.prototype.setDot = function (dots) {
    if (typeof dots === 'undefined') {
      return
    }
    var nDots = Number(dots)
    if (isNaN(nDots) || nDots < 0 || nDots > 2) throw 'not valid number of dots'
    this.dot = nDots
  }

  NoteModel.prototype.getDot = function () {
    return this.dot
  }

  /**
   * @param {String} tieType "start","stop" or "stop_start"
   */
  NoteModel.prototype.setTie = function (tieType) {
    if (!tieType) return

    var arr = ['start', 'stop', 'stop_start']
    if (arr.indexOf(tieType) == -1) throw 'NoteModel - setTie - not valid tie type ' + tieType

    if (!this.tie) this.tie = tieType
    else if (tieType != this.tie) this.tie = 'stop_start'
  }

  NoteModel.prototype.getTie = function () {
    return this.tie
  }

  NoteModel.prototype.removeTie = function (tieType) {
    if (this.tie != 'stop_start' || tieType === undefined) {
      this.tie = null
    } else {
      // This part allow keeping a part of tie active when we call removeTie on stop_start note
      this.tie = tieType == 'start' ? 'stop' : 'start'
    }
  }
  /**
   * if tieType not specified, returns boolean if there is actually a tie (no matter which type)
   * if tieType is specified checks in a 'soft' way, that means that for tie "stop_start", both isTie("start")
   * and isTie("stop") will return true
   *
   * @param  {String}  tieType
   * @return {Boolean}
   */
  NoteModel.prototype.isTie = function (tieType) {
    if (!tieType) return this.tie != null
    else return this.tie && this.tie.indexOf(tieType) != -1
  }

  /* if both parameters are null or undefined, function does not do anything, this happens on constructor
   *
   * @param {[type]} typeTuplet       "start","stop","middle", middle does not set the value this.tuplet
   * @param {[type]} timeModification if empty set to "3/2"
   * examples:
   *		setTuplet(), setTuplet(undefined)  won't do anything
   *		setTuplet("middle")	will set only this.timeModification
   */
  NoteModel.prototype.setTuplet = function (typeTuplet, timeModification) {
    if (!typeTuplet && !timeModification) return

    var validTypes = ['start', 'stop', 'stop_start', 'middle']
    if (typeTuplet && validTypes.indexOf(typeTuplet) == -1) {
      throw 'not valid typeTuplet ' + typeTuplet
    }
    this.timeModification = timeModification || '3/2'
    //we know typeTuple is a valid type, just check that is not middle
    if (typeTuplet != 'middle') this.tuplet = typeTuplet
  }
  /**
   * @return {String} it can be "start", "stop", "stop_start", "middle"
   */
  NoteModel.prototype.getTuplet = function () {
    if (this.timeModification && !this.tuplet) return 'middle'
    else return this.tuplet
  }

  NoteModel.prototype.getTimeModification = function () {
    return this.timeModification || null
  }

  NoteModel.prototype.removeTuplet = function () {
    this.timeModification = null
    this.tuplet = null
  }

  /**
   * if "type" is undefined, just checkes that is tuplet,
   * if type is 'start' or 'stop' returns checks that tuplet is type
   * @param  {String}  type  "start" , "stop" or undefined
   * @return {Boolean}
   */
  NoteModel.prototype.isTuplet = function (type) {
    return !type
      ? this.timeModification != null
      : this.timeModification != null && this.tuplet && this.tuplet.indexOf(type) != -1
  }

  /**
   * @param {Boolean} bool
   */
  NoteModel.prototype.setRest = function (bool) {
    if (typeof bool === 'undefined') bool = true
    this.isRest = bool
    //if (this.isRest) this.setRestPitch(); // maybe use it in module viewer, because it's only for vexflow viewer
    this.setAccidental('')
  }

  /**
   * @param {String} acc ["","#","b","n"]
   * @param {Number} i   default 0
   */
  NoteModel.prototype.setAccidental = function (acc, i) {
    var validAccidentals = ['', '#', 'b', 'n', '##', 'bb']
    if (validAccidentals.indexOf(acc) == -1) throw 'invalid accidental'
    i = i || 0
    this.accidental[i] = acc
  }
  NoteModel.prototype.getAccidental = function (i) {
    i = i || 0
    return this.accidental[i]
  }
  NoteModel.prototype.removeAccidental = function (i) {
    this.setAccidental('', i)
  }

  NoteModel.prototype.getNumPitches = function () {
    return this.pitchClass.length
  }
  /**
   * returns duration in number of beats. where 1.0 is a quarter note, regardless of the time signature (6/8, 4/4...)
   * in that case it's sent as parameter
   * @return {Float}
   */
  NoteModel.prototype.getDuration = function () {
    var dur = 0.0
    dur = NoteUtils.getBeatFromStringDuration(this.duration)
    if (dur === 4) {
      if (this.isRest && this.durationDependsOnBar && this.barDuration) {
        dur = this.barDuration
      }
    }
    if (this.timeModification != null) {
      var nums = this.timeModification.split('/')
      dur = (dur * parseInt(nums[1], null)) / parseInt(nums[0], null)
    }
    var durTmp = dur
    for (var i = 0, c = this.dot; i < c; i++) {
      durTmp /= 2
      dur += durTmp
    }
    return dur
  }

  NoteModel.prototype.setDurationByBeats = function (dur) {
    if (typeof dur !== 'number') {
      throw 'NoteModel - setDurationByBeats -  dur is not a number '
    }

    if (dur * 64 !== parseInt(dur * 64, 10)) {
      throw 'NoteModel - setDuration - dur should be fraction of 2, dur =' + dur
    }
    var finalStringDur, durObj, newNumDur, residualDur

    this.setDot(0)
    for (var i in NoteUtils.ARR_DUR) {
      durObj = NoteUtils.ARR_DUR[i]
      if (durObj.numDur == dur) {
        finalStringDur = durObj.strDur
        break
      } else if (durObj.numDur < dur) {
        finalStringDur = durObj.strDur
        //if not equal, must have dots, check
        newNumDur = dur - durObj.numDur
        residualDur = dur - newNumDur

        if (newNumDur == residualDur / 2) {
          this.setDot(1)
        } else if (newNumDur > residualDur / 2) {
          newNumDur = newNumDur - residualDur / 2
          if (newNumDur == residualDur / 4) {
            this.setDot(2)
          } else {
            throw 'NoteModel - setDuration - could not find mapping duration for ' + dur
          }
        }
        break
      }
    }
    this.duration = finalStringDur
  }

  /**
   * @param {string|number} dur can be a string "h" , "q" , "8" ...etc. or a number
   */
  NoteModel.prototype.setDuration = function (dur) {
    if (!NoteUtils.getBeatFromStringDuration(dur)) {
      throw 'NoteModel - setDuration - did not found string duration: ' + dur
    }
    this.duration = dur
  }

  NoteModel.prototype.serialize = function (complete) {
    if (complete === undefined) complete = true

    var noteObj = {}
    noteObj.pitchList = []

    for (var i = 0, c = this.getNumPitches(); i < c; i++) {
      noteObj.pitchList.push(this.getPitch(i))
    }
    noteObj.duration = this.duration
    //important only set property if not null,
    if (this.dot != null) noteObj.dot = this.dot
    if (this.tie != null && complete) noteObj.tie = this.tie
    if (this.tuplet != null && complete) noteObj.tuplet = this.tuplet
    if (this.timeModification != null && complete) noteObj.timeModification = this.timeModification
    if (this.isRest) noteObj.isRest = this.isRest

    return noteObj
  }

  /**
   * @param  {boolean} complete: if true, clones completely (case of copy/paste), if false,
   *                             ommits ties and tuplets (case of addNote). If not defined, it's true
   * @return {NoteModel}
   */
  NoteModel.prototype.clone = function (complete) {
    return new NoteModel(this.serialize(complete))
  }

  return NoteModel
})
define('modules/core/src/NotesIterator', ['utils/NoteUtils'], function (NoteUtils) {
  /**
   * class iterates through notes but being aware of structure issues (like time or key signature changes)
   * @param {SongBarsIterator} songIt
   * @param {NoteManagerModel} noteMng
   */
  function NotesIterator(songIt, noteMng) {
    this.songIt = songIt
    this.noteMng = noteMng
    this._reset()
  }
  NotesIterator.prototype._reset = function () {
    this.index = 0
    this.duration = 0
    this.iFirstNoteBar = 0
    this.barNumBeats = null
    this.isNewBar = false
    this.songIt.reset()
  }
  NotesIterator.prototype.setStart = function (iStart) {
    this._reset()

    while (this.index < iStart) {
      this.next()
    }
  }
  NotesIterator.prototype.setToBarStart = function () {
    this.index = this.iFirstNoteBar
    this.duration = this.barNumBeats[0]
  }
  NotesIterator.prototype.lowerThan = function (end) {
    return this.index < end && this.index < this.noteMng.getTotal()
  }
  NotesIterator.prototype.hasNext = function () {
    return this.lowerThan(this.noteMng.getTotal())
  }

  NotesIterator.prototype.next = function () {
    this.barNumBeats = this.songIt.getStartEndBeats()
    this.duration += this.noteMng.notes[this.index].getDuration()
    if (NoteUtils.roundBeat(this.duration) == this.barNumBeats[1] - 1) {
      this.songIt.next()
      this.iFirstNoteBar = this.index + 1
      this.isNewBar = true
    } else {
      this.isNewBar = false
    }
    this.index++
  }
  return NotesIterator
})
define('modules/core/src/KeySignatureModel', [], function () {
  function KeySignatureModel(key) {
    this.keys = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#']
    var bemols = key.indexOf('b') !== -1

    if (bemols) {
      key = key[0]
    }
    if (this.keys.indexOf(key) == -1) {
      throw 'Key ' + key + ' not valid'
    }
    this.accidentals = this._setAccidentals(key, bemols)
  }

  KeySignatureModel.prototype = {
    /**
     * 												// TODO: could be improved with a circular array
     * @param  {String} key e.g.: "A", "Bb", "C#"
     * @return {Array}     accidentals of key. e.g.: for "D" -> {"F":"#","C":"#"}; for "Bb" -> {"B":"b","E":"b"}
     */
    _setAccidentals: function (key, bemols) {
      var index,
        firstNonBemolPos = 7 //F#
      for (var i = 0; i < this.keys.length; i++) {
        if (this.keys[i] == key) {
          if (bemols || i == 0) {
            // case keys with bemols (F, Bb, Eb...etc.)
            var bemolKeys = {}
            index = bemols ? i - 1 : firstNonBemolPos - 1 - i
            for (var j = firstNonBemolPos - 1; j >= index; j--) {
              bemolKeys[this.keys[j]] = 'b'
            }
            return bemolKeys
          } else {
            // case keys with sharps
            var sharpKeys = {}
            for (var j = 0; j < i - 1; j++) {
              sharpKeys[this.keys[j]] = '#'
            }
            return sharpKeys
          }
        }
      }
    },
    getAccidentals: function () {
      return this.accidentals
    },
    getPitchAccidental: function (pitch) {
      return this.accidentals[pitch] || ''
    },
  }
  return KeySignatureModel
})
define('modules/core/src/BarAccidentals', [], function () {
  /**
   * when converting notes from socre2play or for play2score (see NoteManagerModel), this object is useful for checking accidnetal that appear in each bar
   * accidentals found in a measure will influence other notes with same pitch class and octave
   */
  function BarAccidentals() {
    this.list = {}
  }

  BarAccidentals.prototype.updateAccidentals = function (note) {
    var accidental = note.getAccidental()
    if (accidental) {
      var octaveNote = note.getPitchClass() + note.getOctave()
      this.list[octaveNote] = accidental
      return accidental
    }
    return false
  }
  BarAccidentals.prototype.getAccidental = function (note) {
    return this.list[note.getPitchClass() + note.getOctave()]
  }
  BarAccidentals.prototype.reset = function () {
    for (var acc in this.list) delete this.list[acc]
  }
  return BarAccidentals
})
define('modules/core/src/NoteManager', [
  'modules/core/src/NoteModel',
  'utils/NoteUtils',
  'modules/core/src/SongBarsIterator',
  'modules/core/src/NotesIterator',
  'modules/core/src/KeySignatureModel',
  'modules/core/src/BarAccidentals',
], function (NoteModel, NoteUtils, SongBarsIterator, NotesIterator, KeySignatureModel, BarAccidentals) {
  /**
   * Note manager represents list of notes, it's a component of SongModel
   * @exports core/NoteManager
   */
  function NoteManager() {
    this.notes = []
  }

  // Interface functions (this functions are also in ChordManagerModel)

  /**
   * @interface getTotal
   */
  NoteManager.prototype.getTotal = function () {
    return this.notes.length
  }
  /**
   * returns duration in number of beats
   * @param  {Integer} pos1
   * @param  {Integer} pos2
   * @return {float}
   */
  NoteManager.prototype.getTotalDuration = function (pos1, pos2) {
    var notes = this.getNotes(pos1, pos2)
    var totalDur = 0
    notes.forEach(function (note) {
      totalDur += note.getDuration()
    })
    return NoteUtils.roundBeat(totalDur)
  }

  NoteManager.prototype.addNote = function (note, pos) {
    if (!note instanceof NoteModel) throw 'note is not an instance of Note'
    if (pos === undefined) {
      this.notes.push(note)
    } else {
      //check
      this.notes.splice(pos, 0, note)
    }
  }
  /**
   * @param  {integer} by default 0
   * @return {NoteModel}
   */
  NoteManager.prototype.getNote = function (pos) {
    pos = pos || 0
    return this.notes[pos]
  }

  NoteManager.prototype.deleteNote = function (pos) {
    if (typeof pos === 'undefined') throw "pos undefined. Can't delete note"
    var notes = this.getNotes()
    this.notes.splice(pos, 1)
  }

  /**
   * gets notes (by reference. To clone use cloneElems)
   * @param  {Integer} from :  index, if not specified, 0
   * @param  {Integer} to   :  index, first note that is not taken, e.g if to = 4, notes will be taken from 'from' to 3.
   * @return {Array}   array of NoteModel
   */
  NoteManager.prototype.getNotes = function (from, to) {
    return this.notes.slice(from, to)
  }

  /**
   * [setNotes description]
   * @param {Array} notes array of NoteModel
   */
  NoteManager.prototype.setNotes = function (notes) {
    if (typeof notes !== 'undefined') this.notes = notes
  }

  /**
   * @interface cloneElems
   * returns a copy of the notes from, pos1, to pos2.
   * @param  {Integer} pos1 if not specified, 0
   * @param  {Integer} pos2 first note that is not taken, e.g if to = 4, notes will be taken from 'from' to 3.
   * @return {Array}  array of cloned NoteModel
   */
  NoteManager.prototype.cloneElems = function (pos1, pos2) {
    var newNotes = []
    var notesToClone = this.getNotes(pos1, pos2)
    var note
    notesToClone.forEach(function (note) {
      newNotes.push(note.clone())
    })
    return newNotes
  }

  /**
   * replace notes from pos1 to pos2+1, by default will always replace one note, if we want to insert notes at
   * position pos without replacing note at 'pos' (e.g. in StructureEditionController.addBar()) we need to call it with cursor = [pos, pos -1 ]
   * @param  {Array} cursor       [pos1,pos2]
   * @param  {Array} notesToPaste array of NoteModel
   */
  NoteManager.prototype.notesSplice = function (cursor, notesToPaste) {
    var part1 = this.notes.slice(0, cursor[0])
    var part2 = this.notes.slice(cursor[1] + 1, this.notes.length) //selected notes are removed
    var copyArr = []
    for (var i = 0, c = notesToPaste.length; i < c; i++) copyArr.push(notesToPaste[i].clone())
    this.notes = part1.concat(copyArr, part2)
  }

  /**
   * Adds notes in a given position (special case of noteSplice)
   * @param {Array} notes Array of NoteModel
   * @param {Integer} position
   */
  NoteManager.prototype.addNotes = function (notes, position) {
    if (position === undefined) {
      position = this.notes.length
    }
    this.notesSplice([position, position - 1], notes)
  }
  /**
   * returns the global beat of a note specified by its index (starting at 1)
   * @param  {Integer} index of the note
   * @return {Float}   beat
   */
  NoteManager.prototype.getNoteBeat = function (index) {
    if (typeof index === 'undefined' || isNaN(index) || index >= this.notes.length || index < 0) {
      throw 'NoteManager - getNoteBeat: problem with index ' + index
    }
    var noteBeat = 1, // because beats are based on 1
      i
    for (i = 0; i < index; i++) {
      noteBeat += this.notes[i].getDuration()
    }
    return NoteUtils.roundBeat(noteBeat)
  }

  /**
   *
   * @return {Array} array of pitches of all the notes. e.g.  ["Db/4-q", "E/4-q", "F/4-8", "A#/4-4", "C/5-4", "B/4-q"]
   */
  NoteManager.prototype.getNotesAsString = function () {
    var arrPitches = []
    this.notes.forEach(function (note) {
      arrPitches.push(note.toString())
    })
    return arrPitches
  }

  /**
   * FUNCTION DOES NOT WORK AS EXPECTED
   * @param  {NoteModel} note
   * @return {Integer}
   */
  NoteManager.prototype.getNoteIndex = function (note) {
    if (typeof note !== 'undefined' && note instanceof NoteModel) {
      console.warn('getNoteIndex does not work as expected')
      for (var i = 0; i < this.notes.length; i++) {
        if (JSON.stringify(this.notes[i].serialize(true)) === JSON.stringify(note.serialize(true))) {
          return i
        }
      }
    }
    return undefined
  }

  NoteManager.prototype.getIndexesBetweenBarNumbers = function (barNum1, barNum2, song) {
    if (!song) {
      throw 'NoteManager - getNotesBetweenBarNumbers - missing parameter song'
    }
    var barMng = song.getComponent('bars')
    var startBeat = song.getStartBeatFromBarNumber(barNum1)
    var endBeat = barMng.getTotal() - 1 === barNum2 ? null : song.getStartBeatFromBarNumber(barNum2 + 1)
    return this.getIndexesStartingBetweenBeatInterval(startBeat, endBeat)
  }
  NoteManager.prototype.getNotesBetweenBarNumbers = function (barNum1, barNum2, song) {
    var indexes = this.getIndexesBetweenBarNumbers(barNum1, barNum2, song)
    return this.getNotes(indexes[0], indexes[1])
  }

  /**
   * @param  {SongBarsIterator} songIt iterator, contains info about which is the current bar
   * @return {Array}        of NoteModels
   */
  NoteManager.prototype.getNotesAtCurrentBar = function (songIt) {
    var beatIntervals = songIt.getStartEndBeats()
    var idxs = this.getIndexesStartingBetweenBeatInterval(beatIntervals[0], beatIntervals[1])
    return this.getNotes(idxs[0], idxs[1])
  }
  /**
   * @param  {Number} barNumber
   * @param  {SongModel} song
   * @return {Array}  of NoteModels
   */
  NoteManager.prototype.getNotesAtBarNumber = function (barNumber, song) {
    if (!song) {
      throw 'NoteManager - getNotesAtBarNumber - incorrect song parameter'
    }
    var songIt = new SongBarsIterator(song)
    songIt.setBarIndex(barNumber)
    return this.getNotesAtCurrentBar(songIt)
  }
  /*NoteManager.prototype._notesTransformationTemplate = function(transformationFn, start, end, song) {
		console.log(arguments);
		var playingNoteAcc, //current accidental
			newNote,
			storedAcc,
			note,
			needToResetAccidentals = false,
			barAcc = new BarAccidentals();

		var notesIt = this._getNotesIteratorAt(start, song);
		notesIt.setStart(notesIt.iFirstNoteBar);
		var newNoteMng = new NoteManager();
		while(notesIt.lowerThan(end)){

			transformationFn();

			notesIt.next();
			if (notesIt.isNewBar){
				needToResetAccidentals = true;
			}
			if (needToResetAccidentals && !newNote.isTie("start")){
				barAcc.reset();
				needToResetAccidentals = false;
			}
		}
		return newNoteMng;
	};
	NoteManager.prototype.play2score = function(start, end, song ) {
		
		this._notesTransformationTemplate(function(){
			if (notesIt.index < start ){
				barAcc.updateAccidentals(note);
			}
			else{
				var keySignature = new KeySignatureModel(notesIt.songIt.getBarKeySignature());
				newNote = note.clone();
				playingNoteAcc = note.getAccidental();
				storedAcc = barAcc.getAccidental(note) || keySignature.getPitchAccidental(note.getPitchClass());
				if (playingNoteAcc){
					if (playingNoteAcc == storedAcc){
						newNote.setAccidental("");
					}else{
						barAcc.updateAccidentals(newNote);
					}
				}else{
					if (storedAcc && storedAcc != "n"){
						newNote.setAccidental("n");
						barAcc.updateAccidentals(newNote);
					}
				}
				newNoteMng.addNote(newNote);
			}
		}, start, end,song);
	};
*/
  NoteManager.prototype.play2score = function (song, start, end) {
    var playingNoteAcc, //current accidental
      newNote,
      storedAcc,
      note,
      needToResetAccidentals = false,
      barAcc = new BarAccidentals()
    var notesIt = this._getNotesIteratorAt(start, song)
    notesIt.setStart(notesIt.iFirstNoteBar)
    var newNoteMng = new NoteManager()

    while (notesIt.lowerThan(end)) {
      note = this.notes[notesIt.index]
      if (notesIt.index < start) {
        barAcc.updateAccidentals(note)
      } else {
        var keySignature = new KeySignatureModel(notesIt.songIt.getBarKeySignature())
        newNote = note.clone()
        playingNoteAcc = note.getAccidental()
        storedAcc = barAcc.getAccidental(note) || keySignature.getPitchAccidental(note.getPitchClass())
        if (playingNoteAcc) {
          if (playingNoteAcc == storedAcc) {
            newNote.setAccidental('')
          } else {
            barAcc.updateAccidentals(newNote)
          }
        } else {
          if (storedAcc && storedAcc != 'n') {
            newNote.setAccidental('n')
            barAcc.updateAccidentals(newNote)
          }
        }
        newNoteMng.addNote(newNote)
      }
      notesIt.next()
      if (notesIt.isNewBar) {
        needToResetAccidentals = true
      }
      if (needToResetAccidentals && !newNote.isTie('start')) {
        barAcc.reset()
        needToResetAccidentals = false
      }
    }
    return newNoteMng
  }

  NoteManager.prototype.score2play = function (song, start, end) {
    start = start || 0
    end = end || this.getTotal()

    var accidental, //current accidental
      newNote,
      note,
      needToResetAccidentals = false,
      barAcc = new BarAccidentals()

    var notesIt = this._getNotesIteratorAt(start, song)
    notesIt.setStart(notesIt.iFirstNoteBar)
    var newNoteMng = new NoteManager()

    while (notesIt.lowerThan(end)) {
      note = this.notes[notesIt.index]
      accidental = barAcc.updateAccidentals(note)

      if (notesIt.index >= start) {
        newNote = note.clone()
        accidental = accidental || barAcc.getAccidental(note)

        if (!accidental) {
          var keySignature = new KeySignatureModel(notesIt.songIt.getBarKeySignature())
          accidental = keySignature.getPitchAccidental(note.getPitchClass())
        }
        if (accidental) {
          if (accidental == 'n') {
            accidental = ''
          }
          newNote.setAccidental(accidental)
        }
        newNoteMng.addNote(newNote)
      }
      notesIt.next()
      if (notesIt.isNewBar) {
        needToResetAccidentals = true
      }
      if (needToResetAccidentals && !newNote.isTie('start')) {
        barAcc.reset()
        needToResetAccidentals = false
      }
    }
    return newNoteMng
  }

  NoteManager.prototype._getNotesIteratorAt = function (index, song) {
    if (isNaN(index) || index < 0 || song === undefined) {
      throw 'NoteManager - getNoteBarNumber - attributes are not what expected, song: ' + song + ', index: ' + index
    }
    var duration = 0,
      songIt = new SongBarsIterator(song),
      notesIt = new NotesIterator(songIt, this)

    notesIt.setStart(index)
    return notesIt
  }
  /**
   * @param  {Number} index
   * @param  {SongModel} song
   * @return {Number}
   */
  NoteManager.prototype.getNoteBarNumber = function (index, song) {
    return this._getNotesIteratorAt(index, song).songIt.getBarIndex()
  }

  /**
   * @param  {integer} start
   * @param  {integer} end
   * @return {Array}
   */
  NoteManager.prototype.getBeatIntervalByIndexes = function (start, end) {
    if (typeof start === 'undefined' || isNaN(start) || start >= this.notes.length || start < 0) {
      throw 'NoteManager - getBeatIntervalByIndexes:  problem with start ' + start
    }
    if (typeof end === 'undefined' || isNaN(end) || end >= this.notes.length || end < 0) {
      throw 'problem with end ' + end
    }
    var startBeat = this.getNoteBeat(start)
    var endBeat = this.getNoteBeat(end) + this.getNote(end).getDuration()
    endBeat = NoteUtils.roundBeat(endBeat)
    return [startBeat, endBeat]
  }
  /**
   * abstraction of code used by both getNextIndexNoteByBeat and getPrevIndexNoteByBeat
   * @param  {Integer} beat    Global beat from where you want informations
   * @return {Object}         Return an object that contain index and curBeat parameter
   */
  NoteManager.prototype._getIndexAndCurBeat = function (beat) {
    var i = 0,
      curNote,
      curBeat = 1
    //we round in the comparison in order to not carry the rounding in curBeat (which is cumulative inside the iteration)
    while (NoteUtils.roundBeat(curBeat) < beat) {
      //to avoid problems with tuplet
      curNote = this.getNote(i)
      if (curNote === undefined) {
        // throw 'NoteManager - _getIndexAndCurBeat - Note not found (possibly beat is greater than last note beat)';
        return {
          index: undefined,
          curBeat: NoteUtils.roundBeat(curBeat),
        }
      }
      curBeat += curNote.getDuration()
      i++
    }
    return {
      index: i,
      curBeat: NoteUtils.roundBeat(curBeat),
    }
  }
  /**
   * Returns the index of the note found at the exact beat, and if not, at the
   * closest note just after a given beat
   * @param  {float} beat global beat (first beat starts at 1, not 0)
   * @return {Integer} index of the note
   * TODO: optimisation: accept object with cached index and beat to start from, useful when function is called in loops (iterator)
   */
  NoteManager.prototype.getNextIndexNoteByBeat = function (beat) {
    if (isNaN(beat) || beat < 1) {
      throw 'NoteManager - getNextIndexNoteByBeat - beat must be a positive float greater than 1 ' + beat
    }
    return this._getIndexAndCurBeat(beat).index
  }

  /**
   * Similar to previous one (getNextIndexNote()), but if
   * exact beat is not found, it returns the closest previous note
   * @param  {float} beat global beat (first beat starts at 1, not 0)
   * @param  {ifExactExclude} if note with index X starts at beat, we will not include it, we'll return index X-1
   *
   * @return {Integer} index of the note
   */
  NoteManager.prototype.getPrevIndexNoteByBeat = function (beat, ifExactExclude) {
    if (isNaN(beat) || beat < 0) {
      throw 'NoteManager - getPrevIndexNoteByBeat - beat must be a positive float ' + beat
    }
    var r = this._getIndexAndCurBeat(beat)
    var index
    if (r.curBeat === beat) {
      //returned r.curBeat is already rounded (so 40.0000003 is -> 40)
      index = ifExactExclude ? r.index - 1 : r.index
    } else {
      index = r.index - 1
    }
    return index
  }

  /**
   * gets indexes of the notes who's start is between startBeat and endBeat
   * @param  {Integer} startBeat
   * @param  {Integer} endBeat
   * @param {Boolean} ifExactExlude, default is false.
   *                                 ex: to get all notes of bar 1 we should do getIndexesStartingBetweenBeatInterval(1,5,true) or getIndexesStartingBetweenBeatInterval(1,4.99)
   *                                 normally we want to not exclude because function getNotes(start,end) already excludes 'end' index and gets notes until end - 1
   * @return {Array}           indexes e.g. [1,2]
   */

  NoteManager.prototype.getIndexesStartingBetweenBeatInterval = function (startBeat, endBeat, ifExactExclude) {
    if (isNaN(startBeat) || startBeat < 0) {
      startBeat = 1
    }
    if (isNaN(endBeat)) {
      throw 'NoteManager - getIndexesStartingBetweenBeatInterval - endBeat must be a positive integer ' + endBeat
    }
    var index1 = this.getNextIndexNoteByBeat(startBeat)
    var index2
    if (endBeat > this.getTotalDuration() || endBeat == null) {
      // important ==, to be true if null or undefined
      index2 = ifExactExclude ? this.getTotal() - 1 : this.getTotal()
    } else {
      index2 = this.getPrevIndexNoteByBeat(endBeat, ifExactExclude) //ifExactExclude is true, that means that we wont return note starting exactly at endBeat
    }

    if (index1 > index2) index1 = index2 //if startBeat and endBeat are within a note, the indexes will be [x,x-1], we fix it here

    return [index1, index2]
  }

  /**
   *
   * @param  {Array | Number} durations array of durations corresponding to bars divisions
   */

  NoteManager.prototype.fillGapWithRests = function (durations) {
    var newNote
    var rests = [],
      silenceDurs = [],
      self = this

    if (!Array.isArray(durations)) {
      durations = [durations]
    }

    durations.forEach(function (duration) {
      silenceDurs = NoteUtils.durationToNotes(duration)
      if (silenceDurs[0] !== undefined) {
        silenceDurs.forEach(function (dur) {
          newNote = new NoteModel(dur + 'r')
          self.addNote(newNote)
        })
      }
    })
  }
  NoteManager.prototype.onlyRests = function () {
    for (var i = 0; i < this.notes.length; i++) {
      if (!this.notes[i].isRest) {
        return false
      }
    }
    return true
  }

  /**
   * This function is called in a temporal NoteManager with selected notes in a time signature change (from StructureEditionController)
   * so notes are adapted to only one time signature (no time signature changes)
   * @param  {TimeSignatureModel} timeSig
   * @param  {integer} numBars number of bars to change, used when there are only rests, when there are notes, numBars can be undefined
   * @return {Array}         of NoteModel
   */
  NoteManager.prototype.getNotesAdaptedToTimeSig = function (timeSig, numBars) {
    var newNoteMng = new NoteManager()
    var numBeatsBar = timeSig.getQuarterBeats()

    var i
    if (this.onlyRests()) {
      var divisions = []
      for (i = 0; i < numBars; i++) {
        divisions.push(timeSig.getQuarterBeats())
      }
      newNoteMng.fillGapWithRests(divisions)
    } else {
      var accDuration = 0 //accumulated Duration
      var note, newNote
      for (i = 0; i < this.notes.length; i++) {
        note = this.notes[i]
        accDuration += note.getDuration()
        if (NoteUtils.roundBeat(accDuration) == numBeatsBar && i < this.notes.length - 1) {
          accDuration = 0
          newNoteMng.addNote(note)
        } else if (NoteUtils.roundBeat(accDuration) > numBeatsBar) {
          var diff = NoteUtils.roundBeat(accDuration) - numBeatsBar
          note.setDurationByBeats(note.getDuration() - diff)
          note.setTie('start')
          newNoteMng.addNote(note)
          newNote = note.clone()
          newNote.setDurationByBeats(diff)

          newNote.removeTie()
          newNote.setTie('stop')
          newNoteMng.addNote(newNote)

          accDuration = diff
        } else {
          newNoteMng.addNote(note)
        }
      }
      var startingBeat = newNoteMng.getTotalDuration() + 1 //beat is 1 based
      var gapDuration = numBeatsBar - accDuration
      newNoteMng.fillGapWithRests(gapDuration)
    }
    return newNoteMng.getNotes()
  }
  /**
   * if there are ties that with different pitches, we remove the tie
   */
  NoteManager.prototype.reviseTiesPitch = function () {
    var notes = this.notes
    var note, notes2
    for (var i = 0; i < notes.length - 1; i++) {
      note = notes[i]
      note2 = notes[i + 1]
      if (note.isTie('start') && note2.isTie('stop') && note.getPitch() != note2.getPitch()) {
        note.removeTie(note.getTie())
        note2.removeTie(note2.getTie())
      }
    }
  }
  /**
   * @param  {Array} pos cursor position e.g. [0,2]
   * @return {Array|null}     search on left then right, then if nothing is found it return null
   */
  NoteManager.prototype.findRestAreas = function (pos) {
    //only merge non tuplet rests
    function expandableRest(note) {
      return note && note.isRest && !note.isTuplet()
    }
    //merge areas if they are touching each other
    function mergeAreas(area1, area2) {
      var mergedAreas
      if (area1 && area2 && area1[1] == area2[0] - 1) {
        mergedAreas = [area1[0], area2[1]]
      } else {
        mergedAreas = area1 || area2
      }
      return mergedAreas
    }

    var start = pos[0],
      end = pos[1],
      iLeft,
      iRight

    //outer left area (out of cursor position) if there are rests
    var outerLeftArea = null
    if (start > 0) {
      iLeft = start - 1
      if (expandableRest(this.notes[iLeft])) {
        outerLeftArea = []
        outerLeftArea[1] = iLeft
        while (iLeft >= 0 && expandableRest(this.notes[iLeft])) {
          outerLeftArea[0] = iLeft
          iLeft--
        }
      }
    }
    // outerLeftArea will be :
    //				like [x, y] (being x first index and y last index),
    // 				or
    //				null if no area found

    //outer right area
    var outerRightArea = null
    if (end < this.getTotal() - 1) {
      iRight = end + 1
      if (expandableRest(this.notes[iRight])) {
        outerRightArea = []
        outerRightArea[0] = iRight
        while (iRight < this.getTotal() && expandableRest(this.notes[iRight])) {
          outerRightArea[1] = iRight
          iRight++
        }
      }
    }
    //inner left area (inside cursor) if there are rests
    var innerLeftArea = null
    iLeft = start
    if (expandableRest(this.notes[iLeft])) {
      innerLeftArea = []
      innerLeftArea[0] = iLeft
      while (iLeft <= end && expandableRest(this.notes[iLeft])) {
        innerLeftArea[1] = iLeft
        iLeft++
      }
    }
    //inner right area
    var innerRightArea = null
    iRight = end
    var limit = innerLeftArea ? innerLeftArea[1] : start
    if (expandableRest(this.notes[iRight]) && iRight > limit) {
      innerRightArea = []
      innerRightArea[1] = iRight
      while (iRight > limit && expandableRest(this.notes[iRight])) {
        innerRightArea[0] = iRight
        iRight--
      }
    }

    var leftArea = mergeAreas(outerLeftArea, innerLeftArea)
    var rightArea = mergeAreas(innerRightArea, outerRightArea)

    if (leftArea && rightArea) {
      if (leftArea[1] == rightArea[0] - 1) {
        return [[leftArea[0], rightArea[1]]]
      } else {
        return [leftArea, rightArea]
      }
    } else {
      return leftArea ? [leftArea] : rightArea ? [rightArea] : null
    }
  }

  /**
   * this function is called after deleting a note or copy and pasting notes, to check if there is a malformed tuplet or a malformed tie
   * if it does, it deletes the tie or the tuplet
   */
  NoteManager.prototype.reviseNotes = function () {
    function getRemoveSet(input, i) {
      var min = i
      var max = i
      while (min > 0 && input[min - 1] != 'no') {
        min--
      }
      while (max + 1 < input.length && input[max + 1] != 'no') {
        max++
      }
      return {
        min: min,
        max: max,
      }
    }

    /**
     * This function parses input controling that all transitions are valid,
     * if it finds a problem, removes the property that causes the error
     *
     * @param  {Array} notes          Array of NoteModel, notes to modify
     * @param  {Object} graph          tranistion graph represents valid transitions
     * @param  {Array}  input          array of states, taken from notes
     * @param  {Function} removeFunction function to remove property
     */
    function parser(notes, graph, input, removeFunction) {
      var prevState, currState
      var isTie = []
      var states = Object.keys(graph)
      var iToStartRemoving
      var intervalsToRemove = []
      for (var i = 0; i < input.length; i++) {
        prevState = i < 1 ? 'no' : input[i - 1]
        currState = i == input.length ? 'no' : input[i]
        if ($.inArray(prevState, states) == -1) {
          throw 'value ' + prevState + '(position ' + i + ') not specified on transitions graph'
        }
        if ($.inArray(currState, graph[prevState]) == -1) {
          var iToStartRemove = currState == 'no' ? i - 1 : i
          intervalsToRemove.push(getRemoveSet(input, iToStartRemove))
        }
      }

      var max, min
      for (var i in intervalsToRemove) {
        max = intervalsToRemove[i].max
        min = intervalsToRemove[i].min

        for (var j = min; j <= max; j++) {
          NoteModel.prototype[removeFunction].call(notes[j], notes[j].tie)
        }
      }
    }

    function checkTuplets(notes) {
      var note
      var states = []
      var state
      for (var i = 0; i < notes.length; i++) {
        note = notes[i]
        state = note.getTuplet() || 'no'
        states.push(state)
      }
      parser(
        notes,
        {
          no: ['no', 'start'],
          start: ['middle'],
          middle: ['stop'],
          stop: ['start', 'no'],
        },
        states,
        'removeTuplet'
      )
    }

    function checkTies(notes) {
      var note
      var states = []
      var state
      for (var i = 0; i < notes.length; i++) {
        note = notes[i]
        state = note.getTie() || 'no'
        states.push(state)
      }
      parser(
        notes,
        {
          no: ['no', 'start'],
          start: ['stop', 'stop_start'],
          stop_start: ['stop', 'stop_start'],
          stop: ['start', 'no'],
        },
        states,
        'removeTie'
      )
    }
    checkTuplets(this.notes)
    checkTies(this.notes)
  }

  return NoteManager
})
define('modules/core/src/BarModel', ['modules/core/src/TimeSignatureModel'], function (TimeSignatureModel) {
  /**
   * Bar core model
   * @exports core/BarModel
   */
  function BarModel(options) {
    options = options || {}
    this.begining = options.begining
    this.clef = options.clef // empty clef means it doesn't change from previous
    this.ending = options.ending // object with repeat, type (BEGIN,END, BEGIN_END, MID) and ending (text)
    this.style = options.style || ''
    this.setTimeSignatureChange(options.timeSignatureChange) // empty timeSignature means it doesn't change from previous
    this.keySignatureChange = options.keySignatureChange
    this.label = options.label // Segno, fine, coda, on cue ...
    this.sublabel = options.sublabel // Ds, Ds al fine, ds al capo ...
  }

  BarModel.prototype.setBegining = function (begining) {
    if (typeof begining === 'undefined') {
      throw 'BarModel - begining should not be undefined'
    }
    this.begining = begining
  }

  BarModel.prototype.getBegining = function () {
    return this.begining
  }

  BarModel.prototype.setClef = function (clef) {
    var clefType = ['', 'treble', 'bass', 'alto', 'tenor', 'percussion']
    if (typeof clef === 'undefined' && typeof clefType[clef] === 'undefined') {
      throw 'BarModel - clef should not be undefined'
    }
    this.clef = clef
  }

  BarModel.prototype.getClef = function () {
    return this.clef
  }

  BarModel.prototype.setEnding = function (ending) {
    if (typeof ending === 'undefined') {
      ending = undefined
    }
    this.ending = ending
  }
  BarModel.prototype.removeEnding = function () {
    this.ending = undefined
  }
  BarModel.prototype.getEnding = function () {
    return this.ending
  }

  BarModel.prototype.setStyle = function (style) {
    if (typeof style === 'undefined') {
      style = ''
    }
    this.style = style
  }

  BarModel.prototype.getStyle = function () {
    return this.style
  }
  /**
   * if param is string, it is converted to TimeSignatureModel
   * @param {TimeSignatureModel | String} timeSignatureChange
   */
  BarModel.prototype.setTimeSignatureChange = function (timeSignatureChange) {
    if (!timeSignatureChange) {
      this.timeSignatureChange = undefined
    } else if (typeof timeSignatureChange === 'string') {
      this.timeSignatureChange = new TimeSignatureModel(timeSignatureChange)
    } else {
      this.timeSignatureChange = timeSignatureChange
    }
  }

  BarModel.prototype.getTimeSignatureChange = function () {
    return this.timeSignatureChange
  }

  BarModel.prototype.setKeySignatureChange = function (keySignatureChange) {
    if (typeof keySignatureChange === 'undefined') {
      keySignatureChange = ''
    }
    this.keySignatureChange = keySignatureChange
  }

  BarModel.prototype.getKeySignatureChange = function () {
    return this.keySignatureChange
  }

  BarModel.prototype.setLabel = function (label) {
    if (typeof label === 'undefined') {
      label = ''
    }
    this.label = label
  }

  BarModel.prototype.getLabel = function () {
    return this.label
  }

  BarModel.prototype.setSublabel = function (sublabel) {
    if (typeof sublabel === 'undefined') {
      sublabel = ''
    }
    this.sublabel = sublabel
  }

  /**
   *
   * @param  {boolan} formatted : if true, it returns formatted example for drawing.
   * @return {String}  e.g.: if formatted -> "DC_AL_CODA"; else -> "DC al Coda"
   */
  BarModel.prototype.getSublabel = function (formatted) {
    if (formatted && typeof this.sublabel !== 'undefined') {
      return this.sublabel.replace(/ /g, '_').toUpperCase()
    } else {
      return this.sublabel
    }
  }
  /**
   * @param  {boolean} unfolding , if true it means we are unfolding so we want to remove endings, labels..etc., if false, is pure cloning
   * @return {BarModel}
   */
  BarModel.prototype.clone = function (unfolding) {
    var newBar = new BarModel(this)
    if (unfolding) {
      newBar.removeEnding()
    }
    return newBar
  }

  return BarModel
})
define('modules/core/src/BarManager', ['modules/core/src/BarModel'], function (BarModel) {
  /**
   * A module representing a list of bars
   * @exports core/BarManager
   */
  function BarManager() {
    this.bars = []
  }

  BarManager.prototype.getTotal = function () {
    return this.bars.length
  }

  BarManager.prototype.getBars = function () {
    return this.bars
  }
  BarManager.prototype.setBars = function (bars) {
    this.bars = bars
  }

  /**
   * Retrieve bar defined by index
   * @param  {Integer} index
   */
  BarManager.prototype.getBar = function (index) {
    if (isNaN(index) || index < 0) {
      throw 'BarManager - getBar - invalid index :' + index
    }
    return this.bars[index]
  }

  /**
   * @param {BarModel} bar
   */
  BarManager.prototype.addBar = function (bar) {
    if (typeof bar === 'undefined' || !(bar instanceof BarModel)) {
      bar = new BarModel()
    }
    this.bars.push(bar)
    return bar
  }

  /**
   *
   * @param  {BarModel} bar
   * @param  {Integer} index
   */
  BarManager.prototype.insertBar = function (indexBar, song, numBars) {
    if (indexBar === undefined || !song) {
      throw 'BarManager - insertBar - missing params'
    }
    numBars = numBars || 1
    var barsToInsert = []
    for (var i = 0; i < numBars; i++) {
      this.bars.splice(indexBar + 1, 0, new BarModel())
    }
    if (indexBar > 0) {
      indexBar-- // we need to get previous bar, otherwise section doesn't know yet the new number of bars
    }
    var section = song.getSection(song.getSectionNumberFromBarNumber(indexBar))
    section.setNumberOfBars(section.getNumberOfBars() + numBars)
  }

  BarManager.prototype.removeBar = function (index) {
    if (typeof index === 'undefined' || isNaN(index) || index < 0) {
      throw 'BarManager - removeBar - invalid index ' + index
    }
    this.bars.splice(index, 1)
  }
  BarManager.prototype.clear = function () {
    this.bars = []
  }

  return BarManager
})
define('utils/ChordTypesCollection', [], function () {
  var ChordTypesCollection = [
    { ct: '', cn: 'C4, E4, G4' },
    { ct: 'M7', cn: 'C4,E4,G4,B4' },
    { ct: 'm7', cn: 'C4,Eb4,G4,Bb4' },
    { ct: 'm', cn: 'C4,Eb4,G4' },
    { ct: 'mM7', cn: 'C4,Eb4,G4,B4' },
    { ct: '7', cn: 'C4, E4, G4, Bb4' },
    { ct: '6', cn: 'C4,E4,G4,A4' },
    { ct: '9', cn: 'C4,E4,G4,Bb4,D5' },
    { ct: '69', cn: 'C4,E4,G4,A4,D5' },
    { ct: '11', cn: 'C4,E4,G4,Bb4,D5,F5' },
    { ct: '13', cn: 'C4,E4,G4,Bb4,D5,F#5,A5' },
    { ct: 'halfdim7', cn: 'C4,Eb4,Gb4,Bb4' },
    { ct: 'dim', cn: 'C4,Eb4,Gb4' },
    { ct: 'dim7', cn: 'C4,Eb4,Gb4,A4' },
    { ct: '7b9', cn: 'C4, E4, G4, Bb4, Db5' },
    { ct: '7#9', cn: 'C4,E4,G4,Bb4,D#5' },
    { ct: '7#9b5', cn: 'C4,E4,Gb4,Bb4,D#5' },
    { ct: '7sus', cn: 'C4,F4,G4,Bb4' },
    { ct: '7b9sus', cn: 'C4,F4,G4,Bb4,Db5' },
    { ct: '7b13', cn: 'C4,E4,G4,Bb4,D5,F#5,Ab5' },
    { ct: '7#11', cn: 'C4,E4,G4,Bb4,D5,F#5' },
    { ct: '7#5', cn: 'C4,E4,G#4,Bb4' },
    { ct: 'm6', cn: 'C4, Eb4, G4, A4' },
    { ct: 'm9', cn: 'C4,Eb4,G4,Bb4,D5' },
    { ct: '9#5', cn: 'C4,E4,G#4,Bb4,D5' },
    { ct: '9sus', cn: 'C4, F4, G4, Bb4, D5' },
    { ct: '4sus', cn: 'C4,F4,G4' },
    { ct: '+', cn: 'C4,E4,G#4' },
    { ct: 'aug', cn: 'C4,E4,G#4' },
    { ct: 'M7#5', cn: 'C4, E4, G#4, B4' },
    { ct: 'M7#11', cn: 'C4,E4,G4,B4,D5,F#5' },
    { ct: 'add9', cn: 'C4,E4,G4,D5' },
    { ct: 'alt', cn: 'C4,E4,G#4,Bb4,D#5' },
    { ct: '9#11', cn: 'C4,E4,G4,Bb4,D5,F#5' },
    { ct: 'm11', cn: 'C4,Eb4,G4,Bb4,D5,F5' },
    { ct: '2', cn: 'C4,D4,E4,G4' },
    { ct: '7#5b5', cn: 'C4,E4,Gb4,G#4,Bb4' },
    { ct: '7#4#5', cn: 'C4,E4,F#4,G#4,Bb4' },
    { ct: '7#5#11', cn: 'C4,F4,G#4,Bb4,D5,F#5' },
    { ct: '7b5', cn: 'C4,E4,Gb4,Bb4' },
    { ct: '13b9', cn: 'C4,E4,G4,Bb4,Db5,F#5,A5' },
    { ct: '13#11', cn: 'C4,E4,G4,Bb4,D5,F#5,A5' },
    { ct: '7b9#5', cn: 'C4,E4,G#4,Bb4,Db5' },
    { ct: '11b9', cn: 'C4,E4,G4,Bb4,Db5,F5' },
    { ct: 'M9', cn: 'C4,E4,G4,B4,D5' },
    { ct: 'm69', cn: 'C4,Eb4,G4,A4,D5' },
    { ct: '9b5', cn: 'C4,E4,Gb4,Bb4,D5' },
    { ct: '7b9b5', cn: 'C4,E4,Gb4,Bb4,Db5' },
    { ct: '7b9#11', cn: 'C4,F4,G4,Bb4,Db5,F#5' },
    { ct: '7alt', cn: 'C4,E4,G#4,Bb4,D#5' },
    { ct: '7#9#5', cn: 'C4,E4,G#4,Bb4,D#5' },
    { ct: '+7', cn: 'C4,E4,G#4,Bb4' },
    { ct: '6#11', cn: 'C4,E4,G4,A4,F#5' },
    { ct: 'Phrygian', cn: 'C4,F4,G4,Bb4,Db5' },
    { ct: 'Lydian', cn: 'C4,E4,G4,B4,D5,F#5' },
    { ct: 'Aeolian', cn: 'C4, Eb4, G4, Bb4, D5, F5' },
    { ct: 'm7sus4', cn: 'C4,F4,G4,Bb4' },
    { ct: '7b13#11', cn: 'C4,E4,G4,Bb4,D5,F#5,Ab5' },
    { ct: 'dimM7', cn: 'C4,Eb4,Gb4,B4' },
    { ct: 'm7#5', cn: 'C4,Eb4,G#4,Bb4' },
    { ct: 'M9#11', cn: 'C4,E4,G4,B4,D5,F#5' },
    { ct: '13sus', cn: 'C4, F4, G4, Bb4, D5, A5' },
    { ct: '7b9#9', cn: 'C4,E4,G4,Bb4,Db5,D#5' },
    { ct: '7#9#11', cn: 'C4,E4,G4,Bb4,D#5,F#5' },
    { ct: '7b9b13', cn: 'C4,E4,G4,Bb4,Db5,F#5,Ab5' },
    { ct: 'mb6', cn: 'C4,Eb4,G4,Ab4' },
    { ct: '7susadd3', cn: 'C4,E4,F4,Bb4' },
    { ct: '7b13sus', cn: 'C4,F4,G4,Bb4,D5,Ab5' },
    { ct: '7b9b13sus', cn: 'C4,F4,G4,Bb4,Db5,Ab5' },
    { ct: 'Dorian', cn: 'C4, Eb4, G4, Bb4, D5, F5' },
    { ct: 'm13', cn: 'C4,Eb4,G4,Bb4,D5,F5,A5' },
    { ct: 'M7#9b9', cn: 'C4,E4,G4,Bb4,Db5,D#5' },
    { ct: 'M7b9', cn: 'C4,E4,G4,B4,Db5' },
    { ct: '+7#9', cn: 'C4,E4,G#4,Bb4,D#5' },
    { ct: 'm#5', cn: 'C4,Eb4,G#4' },
    { ct: '+7b9', cn: 'C4,E4,G#4,Bb4,Db5' },
    { ct: 'M7#5#11', cn: 'C4,E4,G#4,Bb4,D5,F#5' },
    { ct: 'mb5b13', cn: 'C4,Eb4,Gb4,Bb4,D5,Ab5' },
    { ct: '6#9', cn: 'C4,E4,G4,A4,D#5' },
    { ct: 'M7b5', cn: 'C4,E4,Gb4,B4' },
    { ct: 'm9#11', cn: 'C4,Eb4,G4,Bb4,D5,F#5' },
    { ct: 'm13#11', cn: 'C4,Eb4,G4,Bb4,D5,F#5,A5' },
    { ct: 'm7#11', cn: 'C4,Eb4,G4,Bb4,F#5' },
    { ct: 'M7#9#11', cn: 'C4,E4,G4,Bb4,D#5,F#5' },
    { ct: 'sus2', cn: 'C4, D4, G4' },
    { ct: '13#9', cn: 'C4,E4,G4,Bb4,D#5,A5' },
    { ct: '7#5b9', cn: 'C4,E4,G#4,Bb4,Db5' },
    { ct: '69#11', cn: 'C4,E4,G4,A4,D5,F#5' },
    { ct: 'sus4', cn: 'C4,F4,G4' },
    { ct: 'aug#4', cn: 'C4,E4,F#4,G#4' },
    { ct: 'm7add4', cn: 'C4,Eb4,F4,G4,Bb4' },
    { ct: '7#5#9', cn: 'C4,E4,G#4,Bb4,D#5' },
    { ct: 'm9M7', cn: 'C4,Eb4,G4,B4,D5' },
    { ct: 'pedal', cn: 'C4' },
    { ct: '+add9', cn: 'C4,E4,G#4,D5' },
    { ct: '7b5#9', cn: 'C4,E4,Gb4,Bb4,D#5' },
    { ct: '7#4', cn: 'C4,E4,F#4,G4,Bb4' },
    { ct: 'M7#4', cn: 'C4,E4,F#4,G4,B4' },
    { ct: 'm(add9)', cn: 'C4,Eb4,G4,D5' },
    { ct: 'm7b5#5', cn: 'C4,Eb4,Gb4,G#4,Bb4' },
    { ct: '13b9sus', cn: 'C4,E4,G4,Bb4,Db5,A5' },
    { ct: 'm9b5', cn: 'C4,Eb4,Gb4,Bb4,D5' },
    { ct: '(#11)', cn: 'C4,E4,G4,F#5' },
    { ct: 'M7(\u266e4)', cn: 'C4,E4,F4,G4,B4' },
    { ct: 'm7(b5b2)', cn: 'C4,Db4,Eb4,Gb4,Bb4' },
    { ct: '+(add9)', cn: 'C4,E4,G#4,D5' },
    { ct: 'M13', cn: 'C4,E4,G4,B4,D5,F#5,A5' },
    { ct: 'm7b5b13', cn: 'C4,Eb4,Gb4,Bb4,D5,Ab5' },
    { ct: '5', cn: 'C4,G4' },
    { ct: '(no3rd)', cn: 'C4,G4' },
    { ct: '(b5)', cn: 'C4,E4,Gb4' },
    { ct: 'm(M9)', cn: 'C4,Eb4,G4,D5' },
    { ct: '(add9)', cn: 'C4,E4,G4,D5' },
    { ct: '(9, #11)', cn: 'C4,E4,G4,Bb4,D5,F#5' },
    { ct: 'm(m7M7)', cn: 'C4,Eb4,G4,B4' },
    { ct: '(b9b13)', cn: 'C4,E4,G4,Bb4,Db5,Ab5' },
    { ct: '13(b9#11)', cn: 'C4,E4,G4,Bb4,Db5,F#5' },
    { ct: '13(b9b5)', cn: 'C4,E4,Gb4,Bb4,Db5,F#5,A5' },
    { ct: 'm(omit5)', cn: 'C4,Eb4' },
    { ct: 'm7(omit5)', cn: 'C4,Eb4,Bb4' },
    { ct: '+(b9)', cn: 'C4,E4,G#4,Db5' },
    { ct: '6sus4', cn: 'C4,F4,G4,A4' },
    { ct: 'm11b5', cn: 'C4,Eb4,Gb4,Bb4,D5,F5' },
    { ct: '7b6', cn: 'C4,E4,G4,Ab4,Bb4' },
    { ct: '7susomit5', cn: 'C4,F4,Bb4' },
    { ct: '13b9#11', cn: 'C4,E4,G4,Bb4,Db5,F#5,Ab5' },
    { ct: '#11', cn: 'C4,E4,G4,Bb4,D5,F#5' },
    { ct: 'M9#5', cn: 'C4,E4,G#4,B4,D5' },
    { ct: 'halfdim7add11', cn: 'C4,Eb4,G4,Bb4,F5' },
    { ct: 'sus4add9', cn: 'C4,F4,G4,D5' },
    { ct: 'add9addb13', cn: 'C4,E4,G4,D5,Ab5' },
    { ct: 'madd9', cn: 'C4,Eb4,G4,D5' },
    { ct: '13b5', cn: 'C4,E4,Gb4,Bb4,D5,A5' },
    { ct: 'dim7M7', cn: 'C4,Eb4,Gb4,B4' },
    { ct: 'M7add13', cn: 'C4,E4,G4,B4,D5,A5' },
    { ct: 'm7add11add13', cn: 'C4,Eb4,G4,Bb4,F5,A5' },
    { ct: 'add9b5', cn: 'C4,E4,Gb4,D5' },
    { ct: 'mM7#11', cn: 'C4,Eb4,G4,B4,D5,F#5' },
    { ct: 'm9add13', cn: 'C4,Eb4,G4,Bb4,D5,A5' },
    { ct: '5add9', cn: 'C4,E4,G4,D5' },
    { ct: 'M9b5', cn: 'C4,E4,Gb4,D5' },
    { ct: 'mM7b13', cn: 'C4,Eb4,G4,Bb4,D5,Ab5' },
    { ct: 'madd9add11', cn: 'C4,Eb4,G4,D5,F5' },
    { ct: '13b9b5', cn: 'C4,E4,Gb4,Bb4,Db5,F#5,Ab5' },
    { ct: 'sus', cn: 'C4,F4,G4' },
    { ct: 'add#11', cn: 'C4,E4,G4,F#5' },
    { ct: 'm7addM7', cn: 'C4,Eb4,G4,Bb4,B4' },
    { ct: 'halfdim7b9', cn: 'C4,Eb4,Gb4,Bb4,Db5' },
    { ct: 'M13#11', cn: 'C4,E4,G4,Bb4,D5,F#5,A5' },
    { ct: '7omit5', cn: 'C4,E4,Bb4' },
    { ct: 'M7#9', cn: 'C4,E4,G4,Bb4,D#5' },
    { ct: '13(add11)', cn: 'C4,E4,G4,Bb4,D5,F5,A5' },
    { ct: 'M7(add6)', cn: 'C4,E4,G4,A4,B4' },
    { ct: 'sus24', cn: 'C4,D4,F4' },
    { ct: 'm6M7', cn: 'C4,Eb4,G4,A4,B4' },
    { ct: 'm(M13)', cn: 'C4,Eb4,G4,Bb4,D5,A5' },
    { ct: 'm(add4)', cn: 'C4,Eb4,F4,G4' },
    { ct: 'm7b9', cn: 'C4,Eb4,G4,Bb4,Db5' },
    { ct: '(add2)', cn: 'C4,D4,E4,G4' },
    { ct: 'mM7#5', cn: 'C4, Eb4, G#4, B4' },
    { ct: 'halfdim7sus4', cn: 'C4, F4, Gb4, Bb4' },
    { ct: 'm9sus4', cn: 'C4, F4, G4, Bb4, D5' },
    { ct: 'mM7b5', cn: 'C4, Eb4, Gb4, B4' },
    { ct: 'm6add11', cn: 'C4, Eb4, G4, A4, F5' },
    { ct: '7#9b13', cn: 'C4, E4, G4, Bb4, Db5, F5' },
    { ct: 'M7#9b5', cn: 'C4, E4, Gb4, B4, D#5' },
    { ct: '13#9b5', cn: 'C4, E4, Gb4, Bb4, D#5, F#5, A5' },
    { ct: 'm9#5', cn: 'C4, Eb4, G#4, Bb4, D5' },
    { ct: 'm9M7b5', cn: 'C4, Eb4, Gb4, B4, D5' },
    { ct: 'm7M7', cn: 'C4, Eb4, G4, Bb4, B4' },
    { ct: '7#9sus4', cn: 'C4, F4, G4, Bb4, D#5' },
    { ct: 'M7b6', cn: 'C4, E4, G4, Ab4, B4' },
    { ct: 'm2', cn: 'C4, D4, Eb4, G4' },
    { ct: '6b5', cn: 'C4, E4, Gb4, A4' },
    { ct: 'msus4', cn: 'C4, Eb4, F4, G4' },
    { ct: '69(omit3)', cn: 'C4, G4, A4, D5' },
    { ct: 'm(b9)', cn: 'C4, Eb4, G4, Db5' },
    { ct: 'M7#5b5', cn: 'C4, E4, Gb4, G#4, B4' },
    { ct: '7b9#9b5', cn: 'C4, E4, Gb4, Bb4, Db5, D#5' },
    { ct: '7b9b5#5', cn: 'C4, E4, Gb4, G#4, Bb4, Db5' },
    { ct: 'Lydian(#6)', cn: 'C4, E4, G4, A#4, D5, F#5' },
    { ct: '9b13', cn: 'C4, E4, G4, Bb4, D5, Ab5' },
    { ct: '7(13)', cn: 'C4, E4, G4, Bb4, A5' },
    { ct: '#9#11', cn: 'C4, E4, G4, D#5, F#5' },
    { ct: 'm69(11)', cn: 'C4, Eb4, G4, A4, D5, F5' },
    { ct: 'm11M7', cn: 'C4, Eb4, G4, B4, D5, F5' },
    { ct: '13#9#11', cn: 'C4, E4, G4, Bb4, D#5, F#5, A5' },
    { ct: 'M7(omit3)', cn: 'C4, G4, B4' },
    { ct: '7#9(omit5)', cn: 'C4, E4, Bb4, D#5' },
    { ct: 'M7(omit5)', cn: 'C4, E4, B4' },
    { ct: 'm11omit5', cn: 'C4, Eb4, Bb4, D5, F5' },
    { ct: '13#9#5', cn: 'C4, E4, G#4, Bb4, D#5, F#5, A5' },
    { ct: 'add9omit3', cn: 'C4, G4, D5' },
    { ct: '7b9#5#11', cn: 'C4, E4, G#4, Bb4, Db5, F#5' },
    { ct: 'M7sus', cn: 'C4, F4, G4, B4' },
    { ct: 'addb13', cn: 'C4, E4, G4, Ab4' },
    { ct: 'm7add13', cn: 'C4, Eb4, G4, Bb4, Ab5' },
    { ct: 'm7addb13', cn: 'C4, Eb4, G4, Bb4, Ab5' },
    { ct: 'sus(addb9)', cn: 'C4, F4, G4, Db5' },
    { ct: 'add11', cn: 'C4, E4, G4, F5' },
    { ct: 'add9sus', cn: 'C4, F4, G4, D5' },
    { ct: 'Phrygian(add3)', cn: 'C4, E4, F4, G4, Bb4, Db5' },
    { ct: 'm9M7#11', cn: 'C4, Eb4, G4, B4, D5, F#5' },
    { ct: 'madd11', cn: 'C4, Eb4, G4, F5' },
    { ct: '(add#9)', cn: 'C4, D#4, E4, G4' },
    { ct: '9omit5', cn: 'C4, E4, Bb4, D5' },
    { ct: 'M7add11', cn: 'C4, E4, G4, B4, F5' },
    { ct: 'm7add9', cn: 'C4, Eb4, G4, Bb4, D5' },
    { ct: 'm7b5', cn: 'C4, Eb4, Gb4, Bb4' },
    { ct: 'dim(b13)', cn: 'C4, D#4, F#4, Ab4' },
    { ct: 'm7(add11)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'M7(add#11)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'M7(add9)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'sus4b9', cn: 'C4, E4, G4, Bb4' },
    { ct: 'sus4(9,13)', cn: 'C4, E4, G4, Bb4' },
    { ct: '_#5add#9', cn: 'C4, E4, G#4, D#5' },
    { ct: 'm69addM7', cn: 'C4, Eb4, G4, A4, B4, D5' },
    { ct: 'm69(#11)', cn: 'C4, Eb4, G4, A4, D5, F#5' },
    { ct: 'm11M7b5', cn: 'C4, Eb4, Gb4, B4, F5' },
    { ct: 'mM7(add9)', cn: 'C4, Eb4, G4, B4' },
    { ct: 'm6(add9)', cn: 'C4, Eb4, G4, A4, D5' },
    { ct: '7b5b9', cn: 'C4, E4, Gb4, Bb4, Db5' },
    { ct: 'dim(9)', cn: 'C4, Eb4, Gb4, Bbb4, D5' },
    { ct: 'm7(add11omit5)', cn: 'C4, Eb4, Bb4, F5' },
    { ct: '_#9', cn: 'C4, E4, G4, D#5' },
    { ct: 'mM7add11', cn: 'C4, Eb4, G4, B4, F5' },
    { ct: 'm#11', cn: 'C4, Eb4, G4, Bb4, D5, F#5' },
    { ct: 'M9sus', cn: 'C4, F4, G4, B4, D5' },
    { ct: 'M9add13', cn: 'C4, E4, G4, B4, D5, A5' },
    { ct: 'M7addb13', cn: 'C4, E4, G4, B4, Ab5' },
    { ct: 'halfdim7add13', cn: 'C4, Eb4, Gb4, Bb4, A5' },
    { ct: 'omit5', cn: 'C4, E4' },
    { ct: 'm9add#5', cn: 'C4, Eb4, G4, G#4, Bb4, D5' },
    { ct: '7add11', cn: 'C4, E4, G4, Bb4, F5' },
    { ct: '69omit5', cn: 'C4, E4, A4, D5' },
    { ct: '4(addb9)', cn: 'C4, F4, G4, Db5' },
    { ct: 'dim7add9', cn: 'C4, Eb4, Gb4, A4, D5' },
    { ct: '13b9add#5', cn: 'C4, E4, G4, Bb4, Db5, G#5, A5' },
    { ct: '5#11', cn: 'C4, G4, F#5' },
    { ct: 'addb9', cn: 'C4, E4, G4, Db5' },
    { ct: '6#9#11', cn: 'C4, E4, G4, A4, D#5, F#5' },
    { ct: 'dim7b13', cn: 'C4, E4, G4, Bb4' },
    { ct: 'sus4add13', cn: 'C4, E4, G4, Bb4' },
    { ct: 'halfdim7add9', cn: 'C4, E4, G4, Bb4' },
    { ct: '7b9b11', cn: 'C4, E4, G4, Bb4' },
    { ct: 'omit3', cn: 'C4, E4, G4, Bb4' },
    { ct: '9omit3', cn: 'C4, E4, G4, Bb4' },
    { ct: '7omit3', cn: 'C4, E4, G4, Bb4' },
    { ct: '7b9omit3', cn: 'C4, E4, G4, Bb4' },
    { ct: 'm11#5', cn: 'C4, Eb4, Ab4, Bb4, D5, F5' },
    { ct: '_#9b13', cn: 'C4, E4, G4, Eb5, Ab5' },
    { ct: '11b9#5', cn: 'C4, E4, G#4, Bb4, Db5, F5' },
    { ct: 'mM9', cn: 'C4, E4, G4, Bb4' },
    { ct: 'M7(6)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'm7(6)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'm7b13', cn: 'C4, E4, G4, Bb4' },
    { ct: '(#5)', cn: 'C4, E4, G4, Bb4' },
    { ct: '7susadd13', cn: 'C4, F4, G4, Bb4, A5' },
    { ct: 'm11b6', cn: 'C4, Eb4, G4, Ab4, Bb4, D5, F5' },
    { ct: 'M7#11(omit3)', cn: 'C4, G4, B4, F#5' },
    { ct: 'mb5', cn: 'C4, Eb4, Gb4' },
    { ct: 'm7b6', cn: 'C4, Eb4, G4, Ab4, Bb4' },
    { ct: 'sus4omit5', cn: 'C4, E4, G4, Bb4' },
    { ct: 'm(omit3)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'm(addb9)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'm6(omit5)', cn: 'C4, E4, G4, Bb4' },
    { ct: '_b9', cn: 'C4, E4, G4, Db5' },
    { ct: 'M7(69)', cn: 'C4, E4, G4, Bb4' },
    { ct: 'dimadd11', cn: 'C4, Eb4, Gb4, F5' },
    { ct: '_b9#11', cn: 'C4, E4, G4, Db5, F#5' },
    { ct: '9b5b13', cn: 'C4, E4, Gb4, D5, Ab5' },
    { ct: '4(add9)', cn: 'C4, F4, G4, D5' },
    { ct: 'M9#11(6)', cn: 'C4, E4, G4, A4, B4, D5, F#5' },
    { ct: 'm6(add11)', cn: 'C4, Eb4, G4, A4, F5' },
    { ct: '(b9)', cn: 'C4, E4, G4, Db5' },
    { ct: 'm6(M7)', cn: 'C4, Eb4, G4, A4, B4' },
    { ct: '(b5)sus4', cn: 'C4, F4, Gb4' },
    { ct: '7#9add4', cn: 'C4, E4, G4, Bb4, D#5, F5' },
    { ct: '13omit3', cn: 'C4, G4, Bb4, D5, F#5, A5' },
    { ct: 'dim7add11', cn: 'C4, Eb4, Gb4, A4, F5' },
    { ct: 'm9b13', cn: 'C4, Eb4, G4, Bb4, D5, Ab5' },
    { ct: 'mb6(add9)', cn: 'C4, Eb4, G4, Ab4, D5' },
    { ct: '9#5#11', cn: 'C4, E4, G#4, Bb4, D5, F#5' },
    { ct: '#11add9', cn: 'C4, E4, G4, D5, F#5' },
    { ct: '_#11add9', cn: 'C4, E4, G4, D5, F#5' },
    { ct: '6omit3', cn: 'C4, G4, A4' },
    { ct: '9b5omit3', cn: 'C4, Gb4, Bb4, D5' },
    { ct: '9add13', cn: 'C4, E4, G4, Bb4, D5, A5' },
    { ct: 'dim11', cn: 'C4, Eb4, Gb4, A4, D5, F5' },
    { ct: 'm11b9', cn: 'C4, Eb4, G4, Bb4, Db5, F5' },
    { ct: 'm7#5add4', cn: 'C4, Eb4, G#4, Bb4, F5' },
    { ct: '_b9sus', cn: 'C4, F4, G4, Db5' },
    { ct: '9#11omit3', cn: 'C4, G4, Bb4, D5, F#5' },
    { ct: '_b9#5sus', cn: 'C4, F4, G#4, Bb4, Db5' },
    { ct: '7b9#5sus', cn: 'C4, F4, G#4, Bb4, Db5' },
    { ct: 'M9b5add13', cn: 'C4, E4, Gb4, B4, D5, A5' },
    { ct: 'mb9add11', cn: 'C4, Eb4, G4, Db5, F5' },
  ]
  return ChordTypesCollection
})
define('utils/ChordUtils', ['jquery', 'utils/NoteUtils', 'utils/ChordTypesCollection'], function (
  $,
  NoteUtils,
  ChordTypesCollection
) {
  var ChordUtils = {}

  ChordUtils.pitchClasses = [
    'C',
    'C#',
    'Cb',
    'D',
    'D#',
    'Db',
    'E',
    'E#',
    'Eb',
    'F',
    'F#',
    'Fb',
    'G',
    'G#',
    'Gb',
    'A',
    'A#',
    'Ab',
    'B',
    'B#',
    'Bb',
  ]

  /**
   * Retrieve an list of object containing chordtypes and notes
   * @return {function} call callback with an Sring containing notes transposed like ["Cm" = "C4, Eb4, G4",...]
   * Warning, you probably will need to convert the string to array
   */
  ChordUtils.getAllChordTypeFromDB = function (callback) {
    $.ajax({
      url: 'api/ChordTypeInfoApi.php',
      dataType: 'jsonp',
      type: 'POST',
      data: {
        action: 'getAllChordNotes',
      },
      success: function (data) {
        if (typeof callback !== 'undefined') {
          if (typeof data !== 'undefined' && data.allChordNotes) {
            callback(data)
          } else {
            callback('error ' + data)
          }
        }
      },
    })
  }

  ChordUtils.getAllChordTypes = function () {
    // case we already now allchords
    if (typeof ChordUtils.allChords !== 'undefined' && typeof ChordUtils.chordTypeToNote !== 'undefined') {
      return ChordUtils.chordTypeToNote
    }
    // case a cache is available
    else if (typeof ChordTypesCollection !== 'undefined') {
      ChordUtils.chordTypeToNote = []
      // tool function, building an associative array between chordnames and chordnotes (C root)
      // Usage : chordTypeToNote['7b5'] will return ["C4", "E4", "Gb4", "Bb4"]

      var chord
      for (var i = 0, c = ChordTypesCollection.length; i < c; i++) {
        chord = ChordTypesCollection[i]
        ChordUtils.chordTypeToNote[chord.ct] = NoteUtils.transformStringNote2ArrayNote(chord.cn)
      }
      return ChordUtils.chordTypeToNote
    }
    // case we request database
    else {
      // tool function, building an associative array between chordnames and chordnotes (C root)
      // Usage : chordTypeToNote['7b5'] will return ["C4", "E4", "Gb4", "Bb4"]
      ChordUtils.chordTypeToNote = []
      ChordUtils.getAllChordTypeFromDB(function (data) {
        for (var chord in data.allChordNotes) {
          ChordUtils.chordTypeToNote[chord] = NoteUtils.transformStringNote2ArrayNote(data.allChordNotes[chord])
        }
      })
      return ChordUtils.chordTypeToNote
    }
  }

  ChordUtils.getAllChordTypesAsArray = function () {
    // case we already now allchords
    if (typeof ChordUtils.chordTypes !== 'undefined') {
      return ChordUtils.chordTypes
    } else if (typeof ChordTypesCollection !== 'undefined') {
      ChordUtils.chordTypes = []
      for (var i = 0, c = ChordTypesCollection.length; i < c; i++) {
        ChordUtils.chordTypes.push(ChordTypesCollection[i].ct)
      }
      return ChordUtils.chordTypes
    } else {
      return []
    }
  }

  ChordUtils.getAllChords = function () {
    var chordTypes = this.getAllChordTypesAsArray()
    var pitchClasses = ChordUtils.pitchClasses
    var chords = []

    for (var i = 0, c = chordTypes.length; i < c; i++) {
      if (typeof chordTypes[i] !== 'undefined') {
        for (var pClass in pitchClasses) {
          if (chordTypes[i].substring(0, 1) == '#' || chordTypes[i].substring(0, 1) == 'b')
            chordTypes[i] = '_' + chordTypes[i]
          chords.push(pitchClasses[pClass] + chordTypes[i])
        }
      }
    }
    chords.push('NC')
    chords.push('%')
    chords.push('%%')
    ChordUtils.allChords = chords
    return chords
  }
  /**
   * [string2Json description]
   * @param  {String} stringChord e.g. Am, Am9, Am/G, Am/Gm
   * @return {Object}             e.g. {p:'A' ch:'m9', bp:'G', bch:'m'}
   */
  ChordUtils.string2Json = function (stringChord) {
    function getNoteAndChordType(chordString) {
      chordString = chordString.replace(/\s/g, '') //replace all (global g) spaces (\s) by ''
      var pos
      if (chordString.charAt(1) == 'b' || chordString.charAt(1) == '#' || chordString.charAt(1) == '%') pos = 2
      else if (chordString == 'NC') pos = chordString.length
      else pos = 1

      note = chordString.substring(0, pos)
      chordType = chordString.substring(pos, chordString.length)
      return {
        note: note,
        chordType: chordType,
      }
    }

    var chordType,
      note,
      base,
      chordTypes = ChordUtils.getAllChordTypesAsArray(),
      result,
      rBase

    stringChord = stringChord.split('/')

    //we parse first part of chord e.g. in  Am7/G, we are parsing Am7
    result = getNoteAndChordType(stringChord[0])
    chordType = result.chordType
    note = result.note

    //cases where chord are wrong or empty
    if (
      chordTypes.indexOf(chordType) === -1 ||
      (ChordUtils.pitchClasses.indexOf(note) === -1 && note !== 'NC' && note.length !== 0)
    ) {
      return {
        error: true,
      }
    } else if (note.length === 0) {
      return {
        empty: true,
      }
    }

    var jsonChord = {
      p: note,
      ch: chordType,
    }
    // we parse base part, e.g. in Am7/G, we parse G (we allow also base chords, e.g. Am/Gm)
    if (stringChord.length >= 2) {
      rBase = getNoteAndChordType(stringChord[1])
      if (rBase) {
        jsonChord.bp = rBase.note
        if (rBase.chordType) {
          jsonChord.bch = rBase.chordType
        }
      }
    }
    return jsonChord
  }
  return ChordUtils
})
define('modules/core/src/ChordModel', ['utils/ChordUtils'], function (ChordUtils) {
  /**
   * Chord Model is a core model representing a leadsheet chord
   * @exports core/ChordModel
   * @param {} param is an object of parameters
   * param accept : {
   *		note: "C",				// note is a string indicating the root pitch of chord, it also can be % or %% (for repeat) or NC for No Chords
   *		chordType: "7",			// chordtype is a string indicating a chordtype
   *		base: {ChordModel},		// base is a chordModel which represent a base note
   *		parenthesis: false,		// booalean indicating if there are parenthesis or not
   *		beat: 1,				// startbeat in the current measure (start at 1)
   *		barNumber: 0			// start bar number (start at 0)
   * }
   */
  function ChordModel(param) {
    this.note = param && param.note ? param.note : ''
    this.chordType = param && param.chordType ? param.chordType : ''
    //this.base = (param && param.base) ? param.base : {};
    if (param && param.base) {
      this.setBase(param.base)
    } else {
      this.base = {}
    }
    this.parenthesis = param && typeof param.parenthesis !== 'undefined' ? param.parenthesis : false
    this.beat = param && typeof param.beat !== 'undefined' ? param.beat : 1
    this.barNumber = param && typeof param.barNumber !== 'undefined' ? param.barNumber : 0
    this.chordSymbolList = getChordSymbolList()

    function getChordSymbolList() {
      function htmlDecode(value) {
        var div = document.createElement('div')
        div.innerHTML = value
        return div.firstChild.nodeValue
      }
      var maps = {
        halfdim: '&#248;', //ø   //216 -> Ø
        //"M7":"&#916;",//Δ
        dim: '&#959;',
      }
      for (var prop in maps) {
        maps[prop] = htmlDecode(maps[prop])
      }
      return maps
    }
  }

  ChordModel.prototype.initChord = function (param) {}

  /* Basic getter setter */
  ChordModel.prototype.getNote = function () {
    return this.note
  }
  ChordModel.prototype.setNote = function (note) {
    if (typeof note === 'undefined') {
      throw 'Undefined note'
    }
    this.note = note
  }

  ChordModel.prototype.getChordType = function () {
    return this.chordType
  }

  /**
   *
   * @param {String} chordType could be undefined, e.g. in "NC" (no chord)
   */
  ChordModel.prototype.setChordType = function (chordType) {
    this.chordType = chordType
  }

  ChordModel.prototype.getBase = function () {
    return this.base
  }
  ChordModel.prototype.isEmptyBase = function () {
    return Object.keys(this.base).length === 0 ? true : false
  }

  ChordModel.prototype.setBase = function (chordBase) {
    if (typeof chordBase === 'string' && chordBase !== '') {
      this.base = new ChordModel()
      this.base.setChordFromString(chordBase)
    } else if ((chordBase === undefined || !(chordBase instanceof ChordModel)) && chordBase !== '') {
      throw "Base don't have the correct ChordModel type"
    } else {
      // if chord is a chordModel or an empty string (case empty string we are removing base)
      this.base = chordBase
    }
  }

  ChordModel.prototype.getParenthesis = function () {
    return this.parenthesis
  }
  ChordModel.prototype.setParenthesis = function (parenthesis) {
    this.parenthesis = !!parenthesis
  }

  ChordModel.prototype.getBeat = function () {
    return this.beat
  }

  ChordModel.prototype.setBeat = function (beat) {
    if (typeof beat !== 'undefined' && !isNaN(beat)) {
      this.beat = beat
      return true
    }
    return false
  }

  ChordModel.prototype.getBarNumber = function () {
    return this.barNumber
  }

  ChordModel.prototype.setBarNumber = function (barNumber) {
    if (typeof barNumber !== 'undefined' && !isNaN(barNumber)) {
      this.barNumber = Number(barNumber)
      return true
    }
    return false
  }
  /*End basic getter and setters*/

  ChordModel.prototype.isEmpty = function () {
    if (typeof this.note === 'undefined' || this.note === '') {
      return true
    }
    return false
  }

  /**
   *
   * @param  {string}  delimiter  It's the separator between note and chordtype, by default there is no delimiter : C M7
   * @param  {Boolean} isFormated If true some chords are formatted with symbols like Δ or ø
   * @return {string}             [description]
   */
  ChordModel.prototype.toString = function (delimiter, isFormated) {
    if (typeof delimiter === 'undefined') {
      delimiter = ''
    }
    if (typeof isFormated === 'undefined') {
      isFormated = true
    }

    var chordType = this.getChordType()
    if (typeof chordType !== 'undefined') {
      if (isFormated) {
        chordType = this.formatChordType(chordType)
      }
    } else {
      chordType = ''
    }

    var string = ''
    if (!this.isEmpty()) {
      string = this.getNote() + delimiter + chordType
    }

    var base = this.getBase()
    if (base instanceof ChordModel && base.getNote() !== '') {
      var baseChordType = base.getChordType()
      if (typeof baseChordType !== 'undefined') {
        if (isFormated) {
          baseChordType = this.formatChordType(baseChordType)
        }
      } else {
        baseChordType = ''
      }
      string += '/' + base.getNote() + delimiter + baseChordType
    }

    if (this.getParenthesis()) {
      string = '(' + string + ')'
    }

    return string
  }

  ChordModel.prototype.serialize = function () {
    var chordObj = {}
    chordObj.note = this.note
    chordObj.chordType = this.chordType

    if (this.isEmptyBase() !== true) {
      chordObj.base = this.base.toString()
    }
    chordObj.parenthesis = this.parenthesis
    chordObj.beat = this.beat
    chordObj.barNumber = this.barNumber
    return chordObj
  }

  ChordModel.prototype.clone = function () {
    return new ChordModel(this.serialize())
  }

  /*
   * The function transforms a chordType String to symbols according chordSymbolList maps
   * Example: halfdim become ø
   */
  ChordModel.prototype.formatChordType = function (chordTypeName) {
    if (typeof chordTypeName === 'undefined') {
      return ''
    }
    for (var props in this.chordSymbolList) {
      chordTypeName = chordTypeName.replace(props, this.chordSymbolList[props])
    }
    return chordTypeName
  }

  ChordModel.prototype.unformatChordType = function (chordTypeName) {
    if (typeof chordTypeName === 'undefined') {
      return ''
    }
    for (var props in this.chordSymbolList) {
      chordTypeName = chordTypeName.replace(this.chordSymbolList[props], props)
    }
    return chordTypeName
  }
  /**
   * Compare current ChordModel to a chord JSON
   * @param  {Object} chordJson {p: 'F', ch: 'm7', pb: 'C', pch: 'm7'}  (pch is almost never used)
   * @return {Boolean}
   */
  ChordModel.prototype.equalsTo = function (chordJson) {
    if (
      this.getNote() === chordJson.p &&
      ((!this.getChordType() && !chordJson.ch) || //either both base chord types don't exists
        this.getChordType() === chordJson.ch) // either they are equal
    ) {
      if (this.isEmptyBase() && !chordJson.bp) {
        return true
      } else if (!this.isEmptyBase() && chordJson.bp) {
        if (this.getBase().getNote() == chordJson.bp) {
          if (!this.getBase().getChordType() && !chordJson.bch) {
            //either both base chord types don't exists
            return true
          } else if (this.getBase().getChordType() === chordJson.bch) {
            //either they are equal
            return true
          }
        }
      }
    }
    return false
  }

  /**
   * Set chord from a string in the format as C#m7 or C7/G
   * @param {string} format as C#m7 or C7/G
   */
  ChordModel.prototype.setChordFromString = function (stringChord) {
    var jsonChord = ChordUtils.string2Json(stringChord)
    this.note = jsonChord.p ? jsonChord.p : ''
    this.chordType = jsonChord.ch ? jsonChord.ch : ''
    this.base = {}
    if (jsonChord.bp || jsonChord.bch) {
      this.base = new ChordModel()
      if (jsonChord.bp) {
        this.base.setNote(jsonChord.bp)
      }
      if (jsonChord.bch) {
        this.base.setChordType(jsonChord.bch)
      }
    }
    this.parenthesis = typeof jsonChord.parenthesis !== 'undefined' ? jsonChord.parenthesis : false
  }
  return ChordModel
})
/**
 * Chord manager represents a list of chords, it's a component of SongModel
 * @exports core/ChordManager
 */
define('modules/core/src/ChordManager', ['modules/core/src/ChordModel', 'modules/core/src/SongBarsIterator'], function (
  ChordModel,
  SongBarsIterator
) {
  function ChordManager(chords) {
    this.chords = chords ? chords : [] // array of chordModel
  }

  /**
   * Interface functions (this functions are also in NoteManagerModel  )
   * @interface getTotal
   */
  ChordManager.prototype.getTotal = function () {
    return this.chords.length
  }

  ChordManager.prototype.isEmpty = function () {
    return this.chords.length === 0
  }

  ChordManager.prototype.getChords = function (from, to) {
    return this.chords.slice(from, to)
  }

  ChordManager.prototype.setAllChords = function (chords) {
    this.chords = chords
  }

  ChordManager.prototype.getChord = function (index) {
    if (typeof index !== 'undefined' && !isNaN(index)) {
      if (this.chords[index]) {
        return this.chords[index]
      }
    }
    return undefined
  }

  ChordManager.prototype.getChordIndex = function (chord) {
    if (typeof chord === 'undefined' || !(chord instanceof ChordModel)) {
      throw 'Chord must be a ChordModel'
    }
    for (var i = 0, c = this.chords.length; i < c; i++) {
      if (JSON.stringify(this.getChord(i)) === JSON.stringify(chord)) {
        return i
      }
    }
    return undefined
  }

  /**
   * @param  {SongModel} song
   * @return {Array}      Array in which each position corresponds the chord index, and the value is the beat number. e.g
   *                      for song like  4/4| Gm C7 | Dm G7 |(3/4) CM7 | FM7  values would be [1, 3, 5, 7, 9, 12]
   */
  ChordManager.prototype.getBeatsBasedChordIndexes = function (song) {
    var indexesChords = []
    var songIt = new SongBarsIterator(song)
    var barEndBeat
    var barStartBeat = 1
    var iBar, beat
    var iChord = 0
    var offsetBar, chord, beatInc
    while (songIt.hasNext()) {
      //barEndBeat = barStartBeat + songIt.getBarTimeSignature().getQuarterBeats();
      iBar = songIt.getBarIndex()
      beatInc = 4 / songIt.getBarTimeSignature().getBeatUnit()

      while (iChord < this.chords.length && this.chords[iChord].getBarNumber() <= iBar) {
        chord = this.chords[iChord]
        offsetBar = (chord.getBeat() - 1) * beatInc
        beat = barStartBeat + offsetBar
        indexesChords[iChord] = beat
        iChord++
      }
      barStartBeat += songIt.getBarTimeSignature().getQuarterBeats()
      songIt.next()
      offsetBar = 0
    }
    return indexesChords
  }
  /**
   * @param  {SongModel} song
   * @param  {Number} startBeat
   * @param  {Number} endBeat
   * @param  {Array} arrBeatChords, array representing the starting beat of all chords in a song.
   *                               If not specified, it's calculated inside the function
   * @return {Array}               Array of objects representing chords between startBeat and endBeat in the
   *                               following format: {index: 0, beat: 1}, where index is the global chord index, and beat is the beat offset from startBeat, so it is 0 based
   */
  ChordManager.prototype.getChordsRelativeToBeat = function (song, startBeat, endBeat, arrBeatChords) {
    arrBeatChords = arrBeatChords || this.getBeatsBasedChordIndexes(song)

    var selectedChords = []
    for (var i = 0; i < arrBeatChords.length; i++) {
      if (arrBeatChords[i] >= startBeat && arrBeatChords[i] < endBeat) {
        selectedChords.push({
          index: i,
          beat: arrBeatChords[i] - startBeat,
        })
      }
    }
    return selectedChords
  }

  /**
   * @param  {SongModel} song
   * @param  {Number} beat 	represents beat number in 'quarter beats'
   * @return {Object}       {beatNumber:1, barNumber:1}
   */
  ChordManager.prototype.getBarNumAndBeatFromBeat = function (song, beat) {
    if (!beat) {
      throw 'ChordManager - getBarNumAndBeatFromBeat: wrong parameters'
    }
    var songIt = new SongBarsIterator(song)
    var startBeat = 1
    var endBeat, incBeat, offset
    while (songIt.hasNext()) {
      endBeat = startBeat + songIt.getBarTimeSignature().getQuarterBeats()
      if (endBeat > beat) {
        offset = beat - startBeat
        incBeat = 4 / songIt.getBarTimeSignature().getBeatUnit()

        return {
          beatNumber: Math.round(offset / incBeat) + 1,
          barNumber: songIt.getBarIndex(),
          notExactBeat: offset !== parseInt(offset, 10), //if offset is not integer, it means that 'beat' is not starting at an exact beat of bar
        }
      }
      songIt.next()
      startBeat = endBeat
    }
    return {
      exceedsSongLength: true,
    }
  }
  //not needed
  /*ChordManager.prototype.getBeatFromBarNumAndBeat = function(song, barNumAndBeat) {
			var songIt = new SongBarsIterator(song);
			var startBeat = 1;
			var incBeat, offsetBeat;
			while (songIt.hasNext()){

				if (songIt.getBarIndex() === barNumAndBeat.barNum){
					incBeat = 4 / songIt.getBarTimeSignature().getBeatUnit();
					offsetBeat = (barNumAndBeat.beat - 1) * incBeat;
					return 

				}

				songIt.next();
				startBeat += songIt.getBarTimeSignature().getQuarterBeats();
			}
		};*/

  /**
   * Set a new chord to a specific index, if chords[index] already have a chord it will replace it
   * @param {ChordModel} chord
   * @param {int} index
   */
  ChordManager.prototype.setChord = function (chord, index) {
    if (
      typeof chord === 'undefined' ||
      !(chord instanceof ChordModel) ||
      typeof index === 'undefined' ||
      isNaN(index) ||
      index < 0
    ) {
      throw 'Wrong Parameters'
    }
    this.chords[index] = chord
  }

  /**
   * Add a new chord at the end of chords array, if chord is not set, it create a new instance of chordModel
   * @param {ChordModel} chord
   */
  ChordManager.prototype.addChord = function (chord) {
    if (typeof chord !== 'undefined' && chord instanceof ChordModel) {
      this.chords.push(chord)
    } else {
      this.chords.push(new ChordModel())
    }
    this._sortChordsList()
  }

  /**
   * Search and remove a chord from the array, chordModel is destroyed
   * @param  {ChordModel} chord
   */
  ChordManager.prototype.removeChord = function (chord) {
    if (typeof chord !== 'undefined' && !(chord instanceof ChordModel)) {
      throw 'Chord must be a ChordModel'
    }
    var chordIndex = this.getChordIndex(chord)
    this.removeChordByIndex(chordIndex)
  }

  /**
   * Remove a chord from the array based on it's index, chordModel is destroyed
   * @param  {int} index
   */
  ChordManager.prototype.removeChordByIndex = function (index) {
    if (typeof index === 'undefined' || isNaN(index) || index < 0) {
      throw 'Index must be a int in removeChordByIndex'
    }
    if (this.chords[index]) {
      var deletedChords = this.chords.splice(index, 1)
    }
  }

  /**
   * Functions changes bar number of each chords that is equal or greater than barNumber
   * @param  {Int} inc       Increment bar number (usually it's 1 or -1)
   * @param  {Int} barNumber start bar from which we start to increment
   */
  ChordManager.prototype.incrementChordsBarNumberFromBarNumber = function (inc, barNumber) {
    if (typeof barNumber !== 'undefined' && !isNaN(barNumber) && barNumber >= 0) {
      var currentChord
      for (var i = 0, c = this.chords.length; i < c; i++) {
        currentChord = this.chords[i]
        if (currentChord.getBarNumber() >= barNumber) {
          currentChord.setBarNumber(currentChord.getBarNumber() + inc)
        }
      }
    }
  }

  /**
   * Return an array of chords that are in a bar defined by barNumber argument
   * @param  {int} barNumber
   */
  ChordManager.prototype.getChordsByBarNumber = function (barNumber) {
    var chordsByBarNumber = []
    if (typeof barNumber !== 'undefined' && !isNaN(barNumber) && barNumber >= 0) {
      var currentChord
      for (var i = 0, c = this.chords.length; i < c; i++) {
        currentChord = this.chords[i]
        if (currentChord.getBarNumber() === barNumber) {
          chordsByBarNumber.push(currentChord)
        }
      }
    }
    return chordsByBarNumber
  }

  /**
   * Remove all chords in a bar
   * @param  {int} barNumber
   */
  ChordManager.prototype.removeChordsByBarNumber = function (barNumber) {
    if (typeof barNumber !== 'undefined' && !isNaN(barNumber) && barNumber >= 0) {
      var currentChord
      for (var i = this.chords.length - 1; i >= 0; i--) {
        currentChord = this.chords[i]
        if (currentChord.getBarNumber() === barNumber) {
          this.removeChordByIndex(i)
        }
      }
    }
  }
  /**
   *
   * Remove all chords between 2 positions
   * @param  {int} barNumberStart [description]
   * @param  {int} beatStart      [description]
   * @param  {int} barNumberEnd  [description]
   * @param  {int} beatEnd        [description]
   */
  ChordManager.prototype.removeChordsBetweenPositions = function (barNumberStart, beatStart, barNumberEnd, beatEnd) {
    if (
      !isNaN(barNumberStart) &&
      barNumberStart >= 0 &&
      !isNaN(beatStart) &&
      beatStart >= 1 &&
      !isNaN(barNumberEnd) &&
      barNumberEnd >= 0 &&
      !isNaN(beatEnd) &&
      beatEnd >= 1
    ) {
      var numStart = barNumberStart * 1000 + beatStart // bar 4 beat 3 become 4003
      var numEnd = barNumberEnd * 1000 + beatEnd // bar 5 beat 1 become 5001
      var numCurrent
      var currentChord
      for (var i = this.chords.length - 1; i >= 0; i--) {
        currentChord = this.chords[i]
        numCurrent = currentChord.getBarNumber() * 1000 + currentChord.getBeat()
        if (numStart <= numCurrent && numCurrent <= numEnd) {
          this.removeChordByIndex(i)
        }
      }
    }
  }

  /**
   * Return a chord that is matching correct Bar and beat number
   * @param  {ChordModel} chord or undefined if no chord match
   */
  ChordManager.prototype.searchChordByBarAndBeat = function (barNumber, beat) {
    if (!isNaN(barNumber) && barNumber >= 0 && !isNaN(beat) && beat >= 0) {
      var currentChord
      for (var i = 0, c = this.chords.length; i < c; i++) {
        currentChord = this.chords[i]
        if (currentChord.getBarNumber() === barNumber && currentChord.getBeat() === beat) {
          return currentChord
        }
      }
    }
    return undefined
  }

  /**
   * @interface cloneElems
   *
   * returns a copy of the chords from, pos1, to pos2.
   * @param  {Integer} pos1
   * @param  {Integer} pos2
   * @return {ChordModel}      return a new Chordmodel
   */
  ChordManager.prototype.cloneElems = function (pos1, pos2) {
    var newChords = []
    var chordsToClone = this.getChords(pos1, pos2)
    chordsToClone.forEach(function (chord) {
      var cChord = chord.clone()
      newChords.push(cChord)
    })
    return newChords
  }

  /**
   * Return the duration of a chord in beat
   * @param  {songModel} current songModel in which the chord is
   * @param  {int} index of chord in this.chords
   * @return {int} number of beat the chord last
   */
  ChordManager.prototype.getChordDuration = function (songModel, index) {
    if (typeof songModel === 'undefined' || typeof index === 'undefined' || isNaN(index)) {
      throw 'ChordManager - getChordDuration - wrong arguments'
    }
    if (typeof this.chords[index] === 'undefined') {
      return undefined
    }

    var currentBn = this.chords[index].getBarNumber()
    var currentBeat = this.chords[index].getBeat()
    var beats = songModel.getTimeSignatureAt(currentBn).getBeats()
    var nextBn, nextBeat
    if (typeof this.chords[index + 1] !== 'undefined') {
      nextBn = this.chords[index + 1].getBarNumber()
      nextBeat = this.chords[index + 1].getBeat()
    } else {
      // case last chords, we set next to the end
      var sectionNumber = songModel.getSectionNumberFromBarNumber(currentBn)
      nextBn =
        songModel.getStartBarNumberFromSectionNumber(sectionNumber) +
        songModel.getSection(sectionNumber).getNumberOfBars()
      nextBeat = 1
    }
    var duration = 0
    if (nextBn === currentBn) {
      // if chord are on the same bar
      duration = nextBeat - currentBeat
    } else if (nextBn > currentBn) {
      duration = beats * (nextBn - currentBn) + nextBeat - currentBeat
      // TODO test duration 2, it's probably more correct because it take into account time modification change
      //duration2 = songModel.getStartBeatFromBarNumber(nextBn-1) + songModel.getTimeSignatureAt(nextBn-1).getBeats() + nextBeat - songModel.getStartBeatFromBarNumber(currentBn) - currentBeat;
      //console.log(duration, duration2);
    }
    return duration
  }

  /**
   * returns the index of the chord in the demanded position. If there is no chord with that exact position , it returns the closest previous one (or the following one, depending on 'next' param)
   * returns also if it found the exact one or not
   * @param  {Object} pos {	numBar: valNumBar,
   *		                    numBeat: valNumBeat}
   * @param  {boolean} next if true, when there is no chord found at the exact position we get the next one, if false or undefined, we get the previous one
   * @return {Object} {
   *         index: number
   *         exact: boolean
   * }
   */
  ChordManager.prototype.getChordIndexByPosition = function (pos, next) {
    function equalPosition(pos, chord) {
      return pos.numBar == chord.getBarNumber() && pos.numBeat == chord.getBeat()
    }

    //greater than
    function posGtChordPos(pos, chord) {
      return pos.numBar > chord.getBarNumber() || (pos.numBar == chord.getBarNumber() && pos.numBeat > chord.getBeat())
    }

    //less than
    function posLtChordPos(pos, chord) {
      return pos.numBar < chord.getBarNumber() || (pos.numBar == chord.getBarNumber() && pos.numBeat < chord.getBeat())
    }

    var chords = this.getChords()
    var r
    for (var i = 0, c = chords.length; i < c; i++) {
      if (equalPosition(pos, chords[i])) {
        r = 'equal'
        break
      } else if (posGtChordPos(pos, chords[i])) {
        if (i + 1 == chords.length || posLtChordPos(pos, chords[i + 1])) {
          r = 'greater'
          break
        }
      }
    }
    if (next && r != 'equal') i++
    return {
      index: i,
      exact: r == 'equal',
    }
  }

  ChordManager.prototype.getChordsAsString = function () {
    var strChords = []
    for (var i = 0; i < this.chords.length; i++) {
      strChords.push(this.chords[i].toString())
    }
    return strChords
  }

  ChordManager.prototype._sortChordsList = function () {
    this.chords.sort(function (a, b) {
      return a.barNumber * 1000 + a.beat - (b.barNumber * 1000 + b.beat)
    })
  }

  /**
   * getBeatIntervalByIndexes return the beat interval between chords[start] and chords[end] + chords[end] duration
   * @interface getBeatIntervalByIndexes
   * @param  {Number} start
   * @param  {Number} end
   * @return {Array}
   */
  ChordManager.prototype.getBeatIntervalByIndexes = function (songModel, start, end) {
    if (start === undefined || isNaN(start) || end === undefined || isNaN(end)) {
      throw 'Start and End parameters should be number'
    }
    var startChord = this.getChord(start)
    var endChord = this.getChord(end)
    var startBeat = songModel.getStartBeatFromBarNumber(startChord.getBarNumber()) - 1 + startChord.getBeat()
    var endBeat =
      songModel.getStartBeatFromBarNumber(endChord.getBarNumber()) +
      songModel.getTimeSignatureAt(endChord.getBarNumber()).getBeats()
    return [startBeat, endBeat]
  }

  /**
   * Return the index of numberOfChords chords before and after the selected chords
   * @param  {Array} cursor cursor array containing position [1,3]
   * @param  {Integer} numberOfChords indicate how many chords you want to add on the left and right of your context
   * @return {Array}                Return an array that contain new positions of chord
   */
  ChordManager.prototype.getContextOfSelectedChords = function (cursor, numberOfChords) {
    var leftContext = []
    var rightContext = []
    for (var i = 1; i <= numberOfChords; i++) {
      if (cursor[0] - i >= 0) {
        leftContext.push(cursor[0] - i)
      }
      if (cursor[1] + i < this.chords.length) {
        rightContext.push(cursor[1] + i)
      }
    }
    return [leftContext, rightContext]
  }

  /**
   * Function look which chords have their startbeat between startBeat and EndBeat
   * It returns an array of 2 chords index, first index is the first chord that match, second is the last chord that match (it can be the same)
   * by beat interval without including the last beat (just like in notes).
   * E.g.: in a 4/4 song, with one chord per bar,  getIndexesStartingBetweenBeatInterval(1,6) would return [0,0]
   * @interface
   * @param  {Number} startBeat
   * @param  {Number} endBeat
   * @return {Array}  [indexStart, indexEnd]
   */
  /*ChordManager.prototype.getIndexesStartingBetweenBeatInterval = function(songModel, startBeat, endBeat) {
			if (typeof startBeat === "undefined" || isNaN(startBeat) || typeof endBeat === "undefined" || isNaN(endBeat)) {
				throw 'Start and End parameters should be number';
			}
			var pos1 = songModel.getPositionFromBeat(startBeat);
			var pos2 = songModel.getPositionFromBeat(endBeat);
			var index1 = this.getChordIndexByPosition(pos1, true);
			var index2 = this.getChordIndexByPosition(pos2);
			if (index2.exact) index2.index--;
			return [index1.index, index2.index];
		};*/

  return ChordManager
})
define('modules/core/src/SongModel', [
  'modules/core/src/NoteManager',
  'modules/core/src/BarManager',
  'modules/core/src/ChordManager',
  'modules/core/src/TimeSignatureModel',
  'modules/core/src/SongBarsIterator',
], function (NoteManager, BarManager, ChordManager, TimeSignatureModel, SongBarsIterator) {
  /**
   * SongModel is the main model to represent song, it contains notes, chords and bars components, also contain section, composer name etc.
   * @exports core/SongModel
   */
  function SongModel(param) {
    this.init(param)
  }

  SongModel.prototype.init = function (params) {
    params = params || {}
    this.title = params.title || ''
    this.composers = params.composers || []
    this.style = params.style || ''
    this.source = params.source || ''
    this.tempo = params.tempo || 120
    this.tonality = params.tonality || 'C'
    this.timeSignature = params.timeSignature || new TimeSignatureModel('4/4')
    this.sections = params.sections || []
    this.components = params.components || []

    this.addComponent('notes', new NoteManager())
    this.addComponent('bars', new BarManager())
  }

  ///////////////////////////////
  // Basic getters and setters //
  ///////////////////////////////

  SongModel.prototype.getTitle = function () {
    return this.title
  }
  SongModel.prototype.setTitle = function (title) {
    title = title || 'Untitled'
    this.title = title
  }

  SongModel.prototype.getComposer = function (i) {
    i = i || 0
    return this.composers[i]
  }
  SongModel.prototype.setComposer = function (composer) {
    composer = composer || 'No Composer'
    this.composers[0] = composer
  }
  SongModel.prototype.addComposer = function (composer) {
    if (typeof composer !== 'undefined') {
      this.composers.push(composer)
      return true
    }
    return false
  }
  /*SongModel.prototype.clearComposers = function(composer) {
		if (typeof composer !== "undefined") {
			this.composers = [];
			return true;
		}
		return false;
	};*/

  SongModel.prototype.getStyle = function () {
    return this.style
  }

  SongModel.prototype.setStyle = function (style) {
    if (typeof style === 'undefined') {
      return
    }
    this.style = style
  }

  SongModel.prototype.getSource = function () {
    return this.source
  }

  SongModel.prototype.setSource = function (source) {
    if (typeof source !== 'undefined') {
      this.source = source
      return true
    }
    return false
  }

  SongModel.prototype.setTempo = function (tempo) {
    if (typeof tempo === 'undefined' || isNaN(tempo) || tempo < 0) {
      return
    }
    this.tempo = tempo
  }

  SongModel.prototype.getTempo = function () {
    return this.tempo
  }

  SongModel.prototype.setTonality = function (tonality) {
    if (typeof tonality === 'undefined') {
      return
    }
    this.tonality = tonality
  }

  SongModel.prototype.getTonality = function () {
    return this.tonality
  }

  /**
   * Get the tonality of a bar by looping for each previous bar or by default on song tonality
   * (not called for the moment)
   * @param  {int} barNumber
   * @return {string} eg. C, Bb etc
   */
  SongModel.prototype.getKeySignatureAt = function (barNumber) {
    var barsIt = new SongBarsIterator(this)
    barsIt.setBarIndex(barNumber)
    return barsIt.getBarKeySignature()
  }

  SongModel.prototype.setTimeSignature = function (timeSignature) {
    if (typeof timeSignature === 'undefined') {
      this.timeSignature = new TimeSignatureModel('4/4')
    } else {
      this.timeSignature = new TimeSignatureModel(timeSignature)
    }
  }

  SongModel.prototype.getTimeSignature = function () {
    return this.timeSignature
  }

  /*
   * GetTimeSignatureAt returns the time signature at one precise moment defined by the barNumber.
   * It should not be used inside a loop iterating bars, SongBarsIterator should be used instead in that case
   * @param  {int} barNumber
   * @return {timeSignatureModel} currentTimeSignature like 3/4
   */
  SongModel.prototype.getTimeSignatureAt = function (barNumber) {
    var barsIt = new SongBarsIterator(this)
    barsIt.setBarIndex(barNumber)
    return barsIt.getBarTimeSignature()
  }

  /**
   * @param  {Integer} index  index of the section
   * @return {SectionModel}
   */
  SongModel.prototype.getSection = function (index) {
    if (isNaN(index) || index < 0 || index > this.sections.length) {
      throw 'SongModel - getSection - invalid index :' + index
    }
    return this.sections[index]
  }
  SongModel.prototype.getSections = function () {
    return this.sections
  }
  /**
   * addSection can be used on constructing a song (e.g. importing from MusicCSLJson)
   * @param {SectionModel} sectionsItem
   * @param {Integer} index
   */
  SongModel.prototype.addSection = function (sectionsItem, index) {
    if (index === undefined) {
      this.sections.push(sectionsItem)
    } else {
      this.sections.splice(index, 0, sectionsItem)
    }
  }
  SongModel.prototype.removeSection = function (sectionIndex) {
    if (typeof sectionIndex === 'undefined' || isNaN(sectionIndex) || sectionIndex < 0) {
      throw 'SongModel - removeSection - invalid sectionIndex ' + sectionIndex
    }
    this.sections.splice(sectionIndex, 1)
  }

  /**
   * gets component (either chords or notes)
   * @param  {String} componentTitle must be "chords" or "notes" or "bars"
   * @return {NoteManager | ChordManager}
   */
  SongModel.prototype.getComponent = function (componentTitle) {
    if (this.components.hasOwnProperty(componentTitle)) return this.components[componentTitle]
    else return undefined
  }

  SongModel.prototype.addComponent = function (componentTitle, componentItem) {
    if (!componentItem) return false
    this.components[componentTitle] = componentItem
    return true
  }

  /**
   * Function has to be called inside an iteration, it checks if there is a timesignature change in current bar
   * if not, it returns the currentBeats (calculated previously and sent as parameter)
   * @param  {Number} index
   * @param  {Number}
   * @return {Number}
   */
  SongModel.prototype.getBarNumBeats = function (numBar, currentBeats) {
    var barTimeSig = this.getComponent('bars').getBar(numBar).getTimeSignatureChange()

    if (numBar === 0 && !barTimeSig) {
      barTimeSig = this.getTimeSignature()
    }
    if (!barTimeSig && !currentBeats) {
      throw 'bad use: either song is not well formatted, either currentBeats is not sent'
    }

    return barTimeSig ? barTimeSig.getQuarterBeats() : currentBeats
  }

  /**
   * get component using unfolded song structure
   * @param  {String} componentTitle must be "chords" or "notes"
   * @return {array} array of component (noteModel, chordModel)
   */
  SongModel.prototype.getUnfoldedSongComponents = function (componentTitle) {
    var song = []
    if (typeof componentTitle === 'undefined') {
      componentTitle = undefined
    }
    var barsIndex = this.getUnfoldedSongStructure()
    for (var i = 0; i < barsIndex.length; i++) {
      song.push(this.getComponentsAtBarNumber(barsIndex[i], componentTitle))
    }
    return song
  }

  /**
   * Returns an array of index of bars when song if unfolded.
   * like getUnfoldedSongSection() but for the whole song
   * @return {array}
   */
  SongModel.prototype.getUnfoldedSongStructure = function () {
    var pointerBarNumberStructure = []
    for (var i = 0, c = this.getSections().length; i < c; i++) {
      pointerBarNumberStructure = pointerBarNumberStructure.concat(this.getUnfoldedSongSection(i))
    }
    return pointerBarNumberStructure
  }

  /**
   * Returns an array containing index of bars in an unfolded song
   *	e.g.: [	0, 1, 2, 3, 4, 5, 6, 7,
   *			0, 1, 2, 3, 4, 5, 8, 9]
   * @return {array}
   */
  SongModel.prototype.getUnfoldedSongSection = function (sectionNumber) {
    if (typeof sectionNumber !== 'undefined' && !isNaN(sectionNumber)) {
      var bm = this.getComponent('bars')
      var section = this.getSection(sectionNumber)
      var repeat = section.getRepeatTimes()
      var whileSecurity = 0
      var startBar, endBar
      var currentRepeatedPart = 0
      var repeatedPart = []
      var pointerBarNumberStructure = []
      var endingBar
      while (repeat >= 0 || whileSecurity > 1000) {
        whileSecurity++
        // looping in all sections repeat
        repeatedPart = []
        currentRepeatedPart = 0
        startBar = this.getStartBarNumberFromSectionNumber(sectionNumber)
        endBar = startBar + section.getNumberOfBars()
        for (var barNumber = startBar; barNumber < endBar; barNumber++) {
          endingBar = parseInt(bm.getBar(barNumber).getEnding(), 10)
          // case there is an ending
          if (!isNaN(endingBar) && endingBar > 0) {
            currentRepeatedPart = endingBar
            repeat--
          }
          // case there is no ending found yet, we save this part
          if (currentRepeatedPart === 0) {
            repeatedPart.push(barNumber)
          }
          // case there is an ending, we add saved part to begining
          if (!isNaN(endingBar) && endingBar > 1) {
            pointerBarNumberStructure = pointerBarNumberStructure.concat(repeatedPart)
          }
          pointerBarNumberStructure.push(barNumber)
        }
        repeat--
      }
      return pointerBarNumberStructure
    }
  }

  /**
   * Function return the start bar number of any section, first bar is 0
   * @param  {int} sectionNumber
   * @return {int} start Bar Number of section
   */
  SongModel.prototype.getStartBarNumberFromSectionNumber = function (sectionNumber) {
    if (isNaN(sectionNumber)) {
      throw 'SongModel - getStartBarNumberFromSectionNumber - sectionNumber is not a number: ' + sectionNumber
    }
    var barNumber = 0
    for (var i = 0; i < sectionNumber; i++) {
      barNumber += this.getSection(i).getNumberOfBars()
    }
    return barNumber
  }

  /**
   * Returns the section number in which the bar is
   * @param  {int} barNumber
   * @return {int} section number (index) start at 0
   */
  SongModel.prototype.getSectionNumberFromBarNumber = function (barNumber) {
    if (barNumber === undefined || isNaN(barNumber) || barNumber < 0) {
      throw 'SongModel - getSectionNumberFromBarNumber - barNumber is not a number: ' + barNumber
    }
    var sections = this.getSections()
    var sumBar = 0
    for (var i = 0; i < sections.length; i++) {
      sumBar += sections[i].getNumberOfBars()
      if (sumBar > barNumber) {
        return i
      }
    }
    return undefined
  }

  /**
   * Function return the number of beat before a bar number in a folded song
   * @param  {int} barNumber is the number of bar you want to have the first beat
   * @return {int} number of beat to reach realBarNumber
   */
  SongModel.prototype.getStartBeatFromBarNumber = function (barNumber) {
    var numberOfBeats = 1
    if (typeof barNumber !== 'undefined' && !isNaN(barNumber) && barNumber >= 0) {
      for (var i = 0; i < barNumber; i++) {
        numberOfBeats += this.getTimeSignatureAt(i).getQuarterBeats()
      }
    }
    return numberOfBeats
  }

  /**
   * Get number of bars of the whole song
   * @return {int} length of the song in bars
   */
  SongModel.prototype.getNumberOfBars = function () {
    var barNumber = 0
    for (var i = 0, c = this.sections.length; i < c; i++) {
      barNumber += this.sections[i].getNumberOfBars()
    }
    return barNumber
  }

  /**
   * Compute song length in beats
   * @return {int} length of the song in beats
   */
  SongModel.prototype.getSongTotalBeats = function () {
    var numberOfBeats = 0
    var bm = this.getComponent('bars')
    var currentNumberBeatsByBar = this.getTimeSignature().getQuarterBeats()
    var barNumber = 0
    for (var i = 0, c = this.sections.length; i < c; i++) {
      for (var j = 0, v = this.sections[i].getNumberOfBars(); j < v; j++) {
        if (
          typeof bm.getBar(barNumber) !== 'undefined' &&
          typeof bm.getBar(barNumber).getTimeSignatureChange() !== 'undefined'
        ) {
          currentNumberBeatsByBar = bm.getBar(barNumber).getTimeSignatureChange().getQuarterBeats()
        }
        numberOfBeats += currentNumberBeatsByBar
        barNumber++
      }
    }
    return numberOfBeats
  }

  /**
   * Returns all components in a given bar number, componentTitle attriubtes is a filter for component title (eg chords, notes...)
   * @param  {int} barNumber
   * @param  {string} componentTitle will filter all the result depending the type (chords, notes...)
   * @return {array} it returns an array of the direct object
   */
  SongModel.prototype.getComponentsAtBarNumber = function (barNumber, componentTitle) {
    var components = []

    if (!componentTitle || !this.components.hasOwnProperty(componentTitle)) {
      throw 'the item is matching not known type in getComponentsAtBarNumber'
    }

    var modelManager = this.components[componentTitle]
    if (typeof ChordManager !== 'undefined' && modelManager instanceof ChordManager) {
      var chords = modelManager.getChordsByBarNumber(barNumber)
      for (var i = 0; i < chords.length; i++) {
        components.push(chords[i])
      }
    } else if (typeof NoteManager !== 'undefined' && modelManager instanceof NoteManager) {
      var notes = components.concat(modelManager.getNotesAtBarNumber(barNumber, this))
      for (var j = 0; j < notes.length; j++) {
        components.push(notes[j])
      }
    }
    return components
  }

  /**
   * gets divisions between beats depending on bars. Useful when filling gaps with silences in noteManager within several bars
   * @param  {Integer} startBeat
   * @param  {Integer} endBeat
   * @return {Array}           returns duration of each division (check usage in testSongModel)
   */
  SongModel.prototype.getBarDivisionsBetweenBeats = function (startBeat, endBeat) {
    var lastTotalBeat = this.getSongTotalBeats() + 1
    if (startBeat < 1) startBeat = 1
    if (endBeat > lastTotalBeat) endBeat = lastTotalBeat
    var divisions = []
    var residualBeat = startBeat - Math.floor(startBeat)
    var duration = endBeat - startBeat
    if (residualBeat !== 0) {
      var firstSilenceDur = 1 - residualBeat
      if (duration >= firstSilenceDur) {
        divisions.push(firstSilenceDur)
        startBeat += firstSilenceDur
      }
    }

    var songIt = new SongBarsIterator(this)
    var currentBeat = startBeat,
      nextBarBeat = 1,
      currentBarBeat, //bar boundaries (in iteration)
      endDivisionBeat,
      startDivisionBeat //division boundaries

    while (songIt.hasNext()) {
      // we set bar boundaries
      currentBarBeat = nextBarBeat
      nextBarBeat = currentBarBeat + songIt.getBarTimeSignature().getQuarterBeats()

      //we check current bar is within start and end beats sent to the function as params
      if (nextBarBeat > currentBeat && currentBarBeat < endBeat) {
        endDivisionBeat = endBeat < nextBarBeat ? endBeat : nextBarBeat
        startDivisionBeat = currentBeat > currentBarBeat ? currentBeat : currentBarBeat
        divisions.push(endDivisionBeat - startDivisionBeat)
      }
      songIt.next()
    }
    return divisions
  }

  /**
   * Alias for init function, it can be more adapted to some situations
   */
  SongModel.prototype.clear = function () {
    this.init()
  }

  SongModel.prototype.clone = function () {
    var songModelCloned = jQuery.extend(true, new SongModel(), this)
    return songModelCloned
  }

  /**
   * Function test if unfolding system can be call
   * @return {Boolean} indicate if it can be unfolded or not
   */
  SongModel.prototype.canBeUnfold = function () {
    var bm = this.getComponent('bars')
    var barNumber = bm.getTotal()
    var currentBar
    for (var i = 0; i < barNumber; i++) {
      currentBar = bm.getBar(i)
      var currentLabel = currentBar.getLabel()
      var currentSublabel = currentBar.getSublabel()
      if (
        (typeof currentLabel !== 'undefined' && currentLabel !== '') ||
        (typeof currentSublabel !== 'undefined' && currentSublabel !== '')
      ) {
        return false
      }
    }
    return true
  }

  /**
   * Unfold the current songModel and return it
   * Be carefull, segno and coda are not yet supported, you can call canBeUnfold function to test if songModel is supported
   * If you need a new version of the song unfolded use songModel.clone before
   * @return {SongModel} current unfolded songmodel
   */
  SongModel.prototype.unfold = function () {
    function getUnfoldedNotes(oldSong) {
      var barNotes = oldSong.getUnfoldedSongComponents('notes')
      var newNoteMng = new NoteManager()
      for (var i in barNotes) {
        newNoteMng.addNotes(barNotes[i])
      }
      return newNoteMng.getNotes()
    }

    function getUnfoldedChords(oldSong) {
      var newChords = []
      var chord
      var barChords = oldSong.getUnfoldedSongComponents('chords')
      for (var i in barChords) {
        for (var j in barChords[i]) {
          chord = barChords[i][j].clone()
          chord.setBarNumber(i)
          newChords.push(chord)
        }
      }
      return newChords
    }

    function getUnfoldedSectionsAndBars(oldSong) {
      var i,
        c,
        j,
        section,
        pointerBarNumberStructure,
        newSections = [],
        newBars = [],
        barMng = oldSong.getComponent('bars')

      for (i = 0, c = oldSong.getSections().length; i < c; i++) {
        section = oldSong.getSection(i)
        pointerBarNumberStructure = oldSong.getUnfoldedSongSection(i)
        newSections.push(section.cloneUnfolded(pointerBarNumberStructure.length))

        for (j = 0; j < pointerBarNumberStructure.length; j++) {
          newBars.push(barMng.getBar(pointerBarNumberStructure[j]).clone(true))
        }
      }
      return {
        newBars: newBars,
        newSections: newSections,
      }
    }

    var oldSong = this.clone()
    // Copy basic song data.
    this.clear()
    this.setTitle(oldSong.getTitle())
    this.composers = oldSong.composers
    this.setStyle(oldSong.getStyle())
    this.setSource(oldSong.getSource())
    this.setTempo(oldSong.getTempo())
    this.setTonality(oldSong.getTonality())
    this.setTimeSignature(oldSong.getTimeSignature().toString())

    // BARS and SECTIONS
    var r = getUnfoldedSectionsAndBars(oldSong)

    var barMng = new BarManager()
    barMng.setBars(r.newBars)

    this.sections = []
    for (var i in r.newSections) {
      this.addSection(r.newSections[i])
    }

    //NOTES
    var noteMng = new NoteManager()
    noteMng.setNotes(getUnfoldedNotes(oldSong))

    //CHORDS
    var chordMng = new ChordManager()
    chordMng.setAllChords(getUnfoldedChords(oldSong))

    this.addComponent('notes', noteMng)
    this.addComponent('chords', chordMng)
    this.addComponent('bars', barMng)

    return this
  }

  return SongModel
})

define('text!modules/ChordEdition/src/ChordEditionTemplate.html', [], function () {
  return '<div id="edit_chords_second_level">\n\t<!--\n\t<div id="edit_chords_container">\n\t\t<div id="edit_each_chords_container">\n\t\t\t<div class="current_button" title="Show (V)" id="chord-visibility">\n\t\t\t\t<img src="/modules/ChordEdition/img/show.png" id="show_chord" alt="show" />\n\t\t\t\t<img src="/modules/ChordEdition/img/hide.png" id="hide_chord" alt="hide" />\n\t\t\t</div>\n\t\t\t<div class="current_button" title="Remove chord (Del)" id="delete_chord"><img src="/modules/ChordEdition/img/remove.png" alt="delete" /></div>\n\t\t\t<div class="current_button" title="Add chord (Space)" id="add_chord"><img src="/modules/ChordEdition/img/add.png" alt="add" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tChords\n\t\t</div>\n\t</div>\n\t-->\n\n\t<div id="selection_container">\n\t\t<div id="edit_each_selection_container">\n\t\t\t<div class="current_button" title="Copy (Ctrl+C)" id="copy_chord"><img src="{{imgPath}}/copy.png" alt="copy" /></div>\n\t\t\t<div class="current_button" title="Paste (Ctrl+V)" id="paste_chord"><img src="{{imgPath}}/paste.png" alt="paste" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tSelection\n\t\t</div>\n\t</div>\n\t<!--<div id="chord_helper_container"> <div id="chord_helper_container_chordName">No chord selected</div> <canvas height="100" width="180" id="chordTypeCanvas"></canvas></div>-->\n</div>'
})

define('modules/ChordEdition/src/ChordEditionView', [
  'jquery',
  'mustache',
  'modules/core/src/SongModel',
  'utils/UserLog',
  'pubsub',
  'text!modules/ChordEdition/src/ChordEditionTemplate.html',
], function ($, Mustache, SongModel, UserLog, pubsub, ChordEditionTemplate) {
  /**
   * ChordEditionView creates chord edition template and link event from html to controller
   * @exports ChordEdition/ChordEditionView
   */
  function ChordEditionView(cursor, imgPath) {
    this.cursor = cursor
    this.el = undefined
    this.imgPath = imgPath
    this.initKeyboard()
    this.render()
  }

  ChordEditionView.prototype.render = function () {
    this.el = Mustache.render(ChordEditionTemplate, {
      imgPath: this.imgPath,
    })
  }

  /**
   * Function called by MainMenuView
   */
  ChordEditionView.prototype.initController = function () {
    $('#copy_chord').click(function () {
      fn = 'copyChords'
      $.publish('ChordEditionView', fn)
    })
    $('#paste_chord').click(function () {
      fn = 'pasteChords'
      $.publish('ChordEditionView', fn)
    })
  }

  ChordEditionView.prototype.initKeyboard = function () {
    $.subscribe('updown-arrows', function (el, inc, evt) {
      fn = 'setChordPitch'
      if (evt.shiftKey) {
        $.publish('ChordEditionView', [fn, inc])
      }
    })
    $.subscribe('enter-key', function (el) {
      fn = 'toggleEditChord'
      $.publish('ChordEditionView', fn)
    })
    $.subscribe('ctrl-c-key', function (el) {
      fn = 'copyChords'
      $.publish('ChordEditionView', fn)
    })
    $.subscribe('ctrl-v-key', function (el) {
      fn = 'pasteChords'
      $.publish('ChordEditionView', fn)
    })
    $.subscribe('supr-key', function (el) {
      fn = 'deleteChords'
      $.publish('ChordEditionView', fn)
    })
  }

  ChordEditionView.prototype.isEditMode = function (mode) {
    if (this.editMode === mode) {
      return true
    }
    return false
  }

  return ChordEditionView
})
define('modules/ChordEdition/src/ChordSpaceView', ['jquery', 'pubsub', 'modules/Edition/src/ElementView'], function (
  $,
  pubsub,
  ElementView
) {
  /**
   * ChordSpaceView is represented as a rectangle on each beat on top of bars, it create an input where user can select a chord label
   * This object is created by ChordSpaceManager
   * @exports ChordEdition/ChordSpaceView
   */
  function ChordSpaceView(viewer, position, barNumber, beatNumber, viewerScaler) {
    this.viewer = viewer
    this.position = position
    this.barNumber = barNumber
    this.beatNumber = beatNumber
    this.scaler = viewerScaler
  }
  /**
   * @interface
   */
  ChordSpaceView.prototype.isInPath = function (coords) {
    return ElementView.isInPath(coords, this.position, this.scaler)
  }
  /**
   * @interface
   */
  ChordSpaceView.prototype.isBetweenYs = function (coords) {
    return ElementView.isBetweenYs(coords, this.position, this.scaler)
  }
  /**
   * @interface
   */
  ChordSpaceView.prototype.getArea = function () {
    return this.position
  }

  /**
   * @interface
   *
   * @param  {CanvasContext} ctx
   * @param  {Number} marginTop   [description]
   * @param  {Number} marginRight [description]
   */
  ChordSpaceView.prototype.draw = function (ctx, marginTop, marginRight) {
    var style = ctx.fillStyle
    ctx.fillStyle = '#0099FF'
    ctx.globalAlpha = 0.2
    ctx.fillRect(
      this.position.x,
      this.position.y - marginTop,
      this.position.w - marginRight,
      this.position.h + marginTop
    )
    ctx.fillStyle = style
    ctx.globalAlpha = 1
  }

  ChordSpaceView.prototype._getChordAtThisPosition = function (songModel) {
    return songModel.getComponent('chords').searchChordByBarAndBeat(this.barNumber, this.beatNumber)
  }
  return ChordSpaceView
})
define('modules/Cursor/src/CursorModel', ['jquery', 'pubsub'], function ($, pubsub) {
  /**
   * Cursor consists of a pos array that contains index start and index end of position
   * @exports Cursor/CursorModel
   * @param {Int|Array|Object} listElements allows to get size of a list, must be an int, or an array, or an object, if it's an object then getTotal function will be called to get list length
   * @param {Array} optCursor gets a cursor as an array of two positions [start,end]
   */
  function CursorModel(listElements, id, optCursor, isEditable) {
    this.listElements = listElements
    optCursor = optCursor || [0, 0]
    if (!(optCursor instanceof Array)) optCursor = [optCursor, optCursor]

    this.sideSelected = 1
    this.id = typeof id !== 'undefined' ? id : ''
    this.isEditable = typeof isEditable !== 'undefined' ? isEditable : true
    this.setPos(optCursor)
    // this.color = color || "#0099FF";
  }

  CursorModel.prototype.getPos = function () {
    return this.pos
  }

  /**
   * @param {Array} gives the position of the note of the cursor pos can be an array [start,end]
   * or a single value that will be converted to an array [value, value]
   */
  CursorModel.prototype.setPos = function (pos) {
    if (!(pos instanceof Array)) pos = [pos, pos]
    if (isNaN(pos[0])) {
      return //in the case we are setting position from audio playing, we check the cursor really exists, if not we do not optate
    }

    pos = this._checkPosition(pos)
    this.pos = pos
    $.publish('CursorModel-setPos', [this.pos, this.id])
  }

  CursorModel.prototype.getStart = function () {
    return this.pos[0]
  }

  CursorModel.prototype.getEnd = function () {
    return this.pos[1]
  }

  /**
   * Set only one element of the position eg setIndexPos(0, 3), setIndexPos(1, 4)
   * @param {int} index must be 0 or 1, 0 mean you want to change start, 1 mean you want to change end
   * @param {int} pos   cursor position
   */
  CursorModel.prototype.setIndexPos = function (index, pos) {
    if ((index !== 0 && index !== 1) || isNaN(pos)) {
      throw 'CursorModel - setIndexPos, arguments not well defined ' + 'index:' + index + ' - pos:' + pos
    }
    pos = this._checkPosition(pos)[0]
    this.pos[index] = pos
    $.publish('CursorModel-setPos', [this.pos, this.id])
  }

  /**
   * This function checks that a position is valid, it means that it's between 0 and listLength
   * @param  {Int|Array} position can be a int or an array of two Int
   * @return {Array}     A new position array clamped
   */
  CursorModel.prototype._checkPosition = function (position) {
    function isFloat(n) {
      return n === Number(n) && n % 1 !== 0
    }
    if (!(position instanceof Array)) position = [position, position]
    var numElems = this.getListLength()
    for (var i = 0; i < position.length; i++) {
      if (position[i] < 0) position[i] = 0
      if (position[i] >= numElems) {
        position[i] = isFloat(numElems) ? numElems - 0.01 : numElems - 1
      }
    }
    return position
  }

  /**
   * normally after deleting, if cursor points to an unexisting note, it moves to the last one existing
   */
  CursorModel.prototype.revisePos = function () {
    for (var i in this.pos) {
      if (this.pos[i] >= this.getListLength()) this.setIndexPos(i, this.getListLength() - 1)
    }
  }

  CursorModel.prototype.selectAll = function () {
    this.setPos([0, this.getListLength() - 1])
  }
  /**
   * expands (= moves just one side of the cursor)
   * @param  {int} inc      -1 or 1, expand to left or right
   */
  CursorModel.prototype.expand = function (inc) {
    if (this.pos[1] === this.pos[0]) {
      this.sideSelected = inc > 0 ? 1 : 0
    }
    var newPos = this.pos[this.sideSelected] + inc
    if (newPos < 0) {
      newPos = 0
    }
    if (newPos >= this.getListLength()) {
      newPos = this.getListLength() - 1
    }
    this.setIndexPos(this.sideSelected, newPos)
  }

  /*	CursorModel.prototype.getRelativeCursor = function(index) {
			var newSelected = [this.pos[0] - index, this.pos[1] - index];
			return new CursorModel(newSelected);
		};*/

  CursorModel.prototype.reset = function () {
    this.setPos([0, 0])
  }

  CursorModel.prototype.increment = function (inc) {
    inc = inc || 1
    this.setIndexPos(0, (this.pos[0] += inc))
    this.setIndexPos(1, (this.pos[1] += inc))
  }

  CursorModel.prototype.setListElements = function (listElements) {
    this.listElements = listElements
  }

  CursorModel.prototype.getListLength = function () {
    if (typeof this.listElements === 'object') {
      return this.listElements.getTotal()
    }
    if (this.listElements.constructor === Array) {
      return this.listElements.length
    }
    if (this.listElements.constructor === Number) {
      return this.listElements
    }
  }

  CursorModel.prototype.setEditable = function (isEditable) {
    if (!isEditable) {
      this.setPos(null)
    }
    this.isEditable = !!isEditable
  }

  CursorModel.prototype.getEditable = function () {
    return this.isEditable
  }

  return CursorModel
})
define('modules/converters/MusicCSLJson/src/ChordModel_CSLJson', ['modules/core/src/ChordModel'], function (
  ChordModel
) {
  var ChordModel_CSLJson = {}

  ChordModel_CSLJson.importFromMusicCSLJSON = function (JSONChord) {
    var chordModel = new ChordModel()
    chordModel.setNote(JSONChord.p)
    chordModel.setChordType(JSONChord.ch)
    chordModel.setParenthesis(JSONChord.parenthesis)
    chordModel.setBeat(JSONChord.beat)
    if (JSONChord.hasOwnProperty('bp') && JSONChord.bp.length !== 0) {
      var chordModelBase = new ChordModel()
      chordModelBase.setNote(JSONChord.bp)
      chordModelBase.setChordType(JSONChord.bch)
      chordModel.setBase(chordModelBase)
    }
    if (JSONChord.barNumber != null) {
      chordModel.barNumber = JSONChord.barNumber
    }
    return chordModel
  }

  ChordModel_CSLJson.exportToMusicCSLJSON = function (chordModel, withNumMeasure) {
    if (withNumMeasure === undefined) withNumMeasure = false
    var chord = {}
    if (typeof chordModel !== 'undefined' && chordModel instanceof ChordModel) {
      chord.p = chordModel.getNote()
      chord.ch = chordModel.getChordType()
      if (chordModel.getParenthesis()) chord.parenthesis = chordModel.getParenthesis()

      chord.beat = chordModel.getBeat()
      if (!chordModel.isEmptyBase()) {
        chordBase = chordModel.getBase()
        if (chordBase instanceof ChordModel) {
          chord.bp = ''
          if (chordBase.getNote() !== 'undefined') {
            chord.bp = chordBase.getNote()
          }
          chord.bch = ''
          if (chordBase.getChordType() !== 'undefined') {
            chord.bch = chordBase.getChordType()
          }
        }
      }
      if (withNumMeasure) chord.barNumber = chordModel.barNumber
    }
    return chord
  }

  return ChordModel_CSLJson
})
define('modules/ChordEdition/src/ChordSpaceManager', [
  'modules/core/src/SongModel',
  'modules/core/src/ChordModel',
  'modules/ChordEdition/src/ChordSpaceView',
  'modules/Cursor/src/CursorModel',
  'modules/converters/MusicCSLJson/src/ChordModel_CSLJson',
  'utils/UserLog',
  'modules/Edition/src/ElementManager',
  'jquery',
  'pubsub',
], function (
  SongModel,
  ChordModel,
  ChordSpaceView,
  CursorModel,
  ChordModel_CSLJson,
  UserLog,
  ElementManager,
  $,
  pubsub
) {
  /**
   * ChordSpaceManager creates and manages an array of chord space which is represented as a rectangle on each beat on top of bars
   * @param {SongModel}  songModel
   * @param {CursorModel}  cursor
   * @param {LSViewer}  viewer
   * @param {Boolean} isEnabled         boolean that tells if it is initially enabled
   * @param {ChordSpaceEdition}  chordSpaceEdition object enables edition of chords
   * @param {String}  mode              values:
   *                                    	ALL_CHORD_SPACES creates a chord space on each beat of the song (some chord space will be empty, others will have a chord)
   *                                    	ONLY_CHORDS 	 creates chord spaces only in beats in which there are chords
   * @exports ChordEdition/ChordSpaceManager
   */
  function ChordSpaceManager(songModel, cursor, viewer, isEnabled, chordSpaceEdition, mode) {
    if (!songModel || !cursor) {
      throw 'ChordSpaceManager missing params'
    }
    this.CL_NAME = 'ChordsCursor'
    this.CL_TYPE = 'CURSOR'
    this.songModel = songModel
    this.cursor = cursor
    this.chordSpaces = []
    this.elemMng = new ElementManager()
    this.initSubscribe()
    this.enabled = !!isEnabled
    this.viewer = viewer
    this.mode = mode || 'ALL_CHORD_SPACES'
    if (this.mode === 'ALL_CHORD_SPACES') {
      this.MARGIN_TOP = 5
      this.MARGIN_RIGHT = 5
    } else {
      this.MARGIN_TOP = 3
      this.MARGIN_RIGHT = -2
    }
    if (chordSpaceEdition) {
      if (mode === 'ONLY_CHORDS') {
        throw 'ChordSpaceManager: edition in ONLY_CHORDS mode not implemented yet (change mode or do not send ChordSpaceEdition object)'
      }
      this.chordSpaceEdition = chordSpaceEdition
      this.chordSpaceEdition.setMargins(this.MARGIN_RIGHT, this.MARGIN_TOP)
    }
  }

  /**
   * Subscribe to view events
   */
  ChordSpaceManager.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('LSViewer-drawEnd', function (el, viewer) {
      if (typeof viewer.canvasLayer === 'undefined') {
        return
      }
      viewer.canvasLayer.addElement(self)

      self.chordSpaces =
        self.mode === 'ONLY_CHORDS' ? self.createFilledChordSpaces(viewer) : self.createAllChordSpaces(viewer)
      if (self.chordSpaces.length === 0) {
        throw 'chordSpace could not be created, probably ChordSpaceManager is on mode ONLY_CHORDS, and LSViewer.SAVE_CHORDS is false'
      }
      self.cursor.setListElements(self.chordSpaces.length)
      viewer.canvasLayer.refresh()
    })

    $.subscribe('ChordSpaceView-updateChord', function (el, chordJson, chordModel, chordSpace) {
      self.updateChord(chordJson, chordModel, chordSpace)
      $.publish('ToViewer-draw', self.songModel)
    })
    // cursor view subscribe
    $.subscribe('Cursor-moveCursorByElement-chords', function (el, inc) {
      self.moveCursorByBar(inc)
    })
    $.subscribe('ctrl-a', function () {
      self.enable()
      self.cursor.selectAll()
      self.viewer.canvasLayer.refresh()
    })
  }
  ChordSpaceManager.prototype.getType = function () {
    return this.CL_TYPE
  }
  /**
   * Function return several areas to indicate which notes are selected, usefull for cursor or selection
   * @param  {Array} Array with initial position and end position as integer
   * @return {Array}, return array of object in this form: {area.x, area.y, area.xe, area.ye}
   */
  ChordSpaceManager.prototype.createAllChordSpaces = function (viewer) {
    var chordSpace = []
    if (typeof viewer.vxfBars === 'undefined') {
      return
    }
    var xi, yi, xe, ye
    var beatsInBar
    var decalX
    var widthBeat
    var area
    for (var i = 0, c = viewer.vxfBars.length; i < c; i++) {
      beatsInBar = viewer.vxfBars[i].timeSignature.getBeats()
      widthBeat = viewer.vxfBars[i].barDimensions.width / beatsInBar
      for (var j = 0; j < beatsInBar; j++) {
        area = {
          x: viewer.vxfBars[i].barDimensions.left + widthBeat * j,
          y: viewer.vxfBars[i].barDimensions.top - 17,
          w: widthBeat,
          h: 20,
        }
        chordSpace.push(new ChordSpaceView(viewer, area, i, j + 1, viewer.scaler))
      }
    }
    return chordSpace
  }

  ChordSpaceManager.prototype.createFilledChordSpaces = function (viewer) {
    var chordSpace = []
    for (var i = 0; i < viewer.chordViews.length; i++) {
      chordSpace.push(new ChordSpaceView(viewer, viewer.chordViews[i], i, i, viewer.scaler))
    }
    return chordSpace
  }
  /**
   * @interface
   *
   * @param  {Object} coords [description]
   */
  ChordSpaceManager.prototype.getYs = function (coords) {
    return this.elemMng.getYs(this.chordSpaces, coords)
  }

  /**
   * @interface
   * @param  {Object} coords
   * @param  {Integer} ini
   * @param  {Integer} end
   * @param  {Boolean} clicked
   * @param  {Boolean} mouseUp, (never used but needed to keep parameter order)
   * @param  {Boolean} ctrlPressed
   */
  ChordSpaceManager.prototype.onSelected = function (coords, ini, end, clicked, mouseUp, ctrlPressed) {
    var posCursor = this.elemMng.getElemsInPath(this.chordSpaces, coords, ini, end, this.getYs(coords))

    if (ctrlPressed) {
      posCursor = this.elemMng.getMergedCursors(posCursor, this.cursor.getPos())
    }

    if (posCursor[0] !== null) {
      this.cursor.setPos(posCursor)
    }
    // if event was clicked and we just selected one chord, we draw the pull down
    if (posCursor[0] == posCursor[1] && clicked) {
      var position = this.cursor.getPos()
      position = position[0]
      if (this.chordSpaceEdition) {
        this.chordSpaceEdition.drawEditableChord(this.chordSpaces[position], this.cursor)
      }
    }
  }

  /**
   * @interface
   *
   * @param  {CanvasContext} ctx
   */
  ChordSpaceManager.prototype.drawCursor = function (ctx) {
    var self = this

    function drawChordSpaceBorders(ctx) {
      for (var j = 0; j < self.chordSpaces.length; j++) {
        var position = self.chordSpaces[j].getArea()

        ctx.strokeStyle = '#999999'
        ctx.strokeRect(
          position.x,
          position.y - self.MARGIN_TOP,
          position.w - self.MARGIN_RIGHT,
          position.h + self.MARGIN_TOP
        )
      }
    }
    var pos = this.cursor.getPos()
    if (pos[0] !== false) {
      for (var i = pos[0]; i <= pos[1]; i++) {
        this.chordSpaces[i].draw(ctx, self.MARGIN_TOP, self.MARGIN_RIGHT)
      }
    }
    if (this.mode === 'ALL_CHORD_SPACES') {
      drawChordSpaceBorders(ctx)
    }
  }
  /**
   * @interface
   *
   * @return {Boolean}
   */
  ChordSpaceManager.prototype.isEnabled = function () {
    return this.enabled
  }

  /**
   * @interface
   */
  ChordSpaceManager.prototype.enable = function () {
    this.enabled = true
  }

  /**
   * @interface
   */
  ChordSpaceManager.prototype.disable = function () {
    if (this.chordSpaceEdition) {
      this.chordSpaceEdition.undrawEditableChord()
    }
    this.enabled = false
  }

  /**
   * @interface
   * @param  {Object} coords {x: xval, y: yval}}
   * @return {Boolean}
   */
  ChordSpaceManager.prototype.inPath = function (coords) {
    return !!this.getChordsInPath(coords)
  }
  /**
   * @interface
   */
  ChordSpaceManager.prototype.setCursorEditable = function (bool) {
    this.cursor.setEditable(bool)
  }

  ChordSpaceManager.prototype.updateChord = function (chordJson, chordModel, chordSpace) {
    var chordMng = this.songModel.getComponent('chords')
    chordJson.beat = chordSpace.beatNumber
    chordJson.barNumber = chordSpace.barNumber

    if (chordModel === undefined) {
      //adding new chord
      var chordModel = ChordModel_CSLJson.importFromMusicCSLJSON(chordJson)
      chordMng.addChord(chordModel)
    } else if (chordJson.empty) {
      chordMng.removeChord(chordModel)
    } else {
      var i = chordMng.getChordIndex(chordModel)
      chordModel = ChordModel_CSLJson.importFromMusicCSLJSON(chordJson)
      chordMng.setChord(chordModel, i)
    }
    $.publish('ToHistory-add', 'Update Chords ' + chordModel.toString())
  }

  ChordSpaceManager.prototype.getChordsInPath = function (coords) {
    return this.elemMng.getElemsInPath(this.chordSpaces, coords)
  }

  ChordSpaceManager.prototype.moveCursorByBar = function (inc) {
    var barNum = this.chordSpaces[this.cursor.getPos()[0]].barNumber
    var startBeat = this.songModel.getStartBeatFromBarNumber(barNum + inc) - 1

    if (barNum === 0 && inc === -1) {
      this.cursor.setPos(0)
    } else {
      this.cursor.setPos(startBeat)
      this.drawEditableChord()
    }
  }

  return ChordSpaceManager
})
define('modules/Edition/src/HtmlInputElement', ['jquery'], function ($) {
  /**
   * Class for creating html inputs and deleting them
   * @exports Edition/HtmlInputElement
   * @param {LSViewer} viewer
   * @param {String} className
   * @param {Object} position    e.g.{x:23, y:23, w:10, h:10º}
   * @param {Integer} marginTop
   * @param {Integer} marginRight
   */
  function HtmlInputElement(viewer, className, position, marginTop, marginRight) {
    if (!viewer || !className) {
      throw 'HtmlInputElement - wrong params'
    }
    this.viewer = viewer
    this.className = className
    this.containerId = $(this.viewer.divContainer).attr('id')
    this.init(position, marginTop, marginRight)
  }
  HtmlInputElement.prototype.init = function (position, marginTop, marginRight) {
    marginTop = marginTop || 0
    marginRight = marginRight || 0

    var offset = $('#' + this.containerId + ' canvas').offset()
    if (typeof offset === 'undefined' || isNaN(offset.top) || isNaN(offset.left)) {
      offset = {
        top: 0,
        left: 0,
      }
    }
    var pos = this.viewer.scaler.getScaledObj(position),
      top = pos.y - marginTop - 1,
      left = pos.x + offset.left + window.pageXOffset - 1,
      width = pos.w - marginRight,
      height = pos.h + marginTop

    this.input = $('<input/>')
      .attr({
        type: 'text',
        style:
          'position:absolute; z-index: 11000;left:' +
          left +
          'px;top:' +
          top +
          'px; width:' +
          width +
          'px; height:' +
          height +
          'px',
        class: this.className,
      })
      .prependTo('#' + this.containerId)
  }
  HtmlInputElement.prototype.remove = function () {
    $('#' + this.containerId + ' .' + this.className).remove()
  }
  return HtmlInputElement
})
define('modules/ChordEdition/src/ChordSpaceEdition', [
  'jquery',
  'pubsub',
  'jquery_autocomplete',
  'utils/UserLog',
  'modules/Edition/src/HtmlInputElement',
  'utils/ChordUtils',
], function ($, pubsub, jquery_autocomplete, UserLog, HtmlInputElement, ChordUtils) {
  function ChordSpaceEdition(songModel, viewer) {
    this.songModel = songModel
    this.viewer = viewer
  }

  ChordSpaceEdition.prototype.setMargins = function (marginRight, marginTop) {
    this.marginRight = marginRight
    this.marginTop = marginTop
  }

  ChordSpaceEdition.prototype.drawEditableChord = function (chordSpaceView, cursor) {
    this.undrawEditableChord()
    var position = cursor.getPos()
    position = position[0]
    this.htmlInput = this.createHtmlInput(chordSpaceView)
  }
  ChordSpaceEdition.prototype.undrawEditableChord = function () {
    if (this.htmlInput) {
      this.htmlInput.input.devbridgeAutocomplete('dispose')
      this.htmlInput.remove()
    }
  }
  ChordSpaceEdition.prototype.createHtmlInput = function (chordSpaceView) {
    // Get chord value
    var chord = chordSpaceView._getChordAtThisPosition(this.songModel)
    var inputVal = chord ? chord.toString('', false) : ''

    //we create html input, jquery object is in htmlInput.input (did not do getter because don't believe anymore in plain getters in javascript)
    var htmlInput = new HtmlInputElement(
      this.viewer,
      'chordSpaceInput',
      chordSpaceView.getArea(),
      this.marginTop,
      this.marginRight
    )

    var input = htmlInput.input
    // We create auto complete input
    var chordTypeList = ChordUtils.allChords !== undefined ? ChordUtils.allChords : ChordUtils.getAllChords()

    this.createAutocomplete(chordSpaceView, input, this.songModel, chordTypeList, inputVal)

    return htmlInput
  }
  ChordSpaceEdition.prototype.createAutocomplete = function (chordSpaceView, input, songModel, list, inputVal) {
    var self = this
    // input.select();
    input.devbridgeAutocomplete({
      lookup: list,
      maxHeight: 200,
      lookupLimit: 40,
      width: 140,
      triggerSelectOnValidInput: false,
      showNoSuggestionNotice: true,
      autoSelectFirst: true,
      delimiter: '/',
      // You may need to modify that if at first it appears incorrectly, it's probably because ur element is not absolute position
      // 'appendTo': myAbsolutedPositionElement, // dom or jquery (see devbridgeAutocomplete doc)
      noSuggestionNotice: 'No Chord match',
      lookupFilter: function (suggestion, originalQuery, queryLowerCase) {
        return suggestion.value.indexOf(originalQuery) !== -1
      },
      onSelect: function () {
        self.onChange(chordSpaceView, $(input).val())
        //input.devbridgeAutocomplete('dispose');
      },
    })

    input.focus() // this focus allow setting cursor on end carac
    input.val(inputVal)
    input.focus() // this focus launch autocomplete directly when value is not empty
    input.select() // we select text so that is easier to edit

    // on blur event we change the value, blur is launched when we enter and click somewhere else
    input.on('blur', function () {
      self.onChange(chordSpaceView, $(this).val())
      // input.devbridgeAutocomplete('dispose');
    })
    // on tab call (tab doesn't trigger blur event)
    input.keydown(function (e) {
      var code = e.keyCode || e.which
      if (code == '9') {
        //console.log('tab');
        self.onChange(chordSpaceView, $(this).val())
        input.devbridgeAutocomplete('dispose')
      }
    })
    // We use a filter function to make it easier for user to enter chords
    input.on('input propertychange paste', function () {
      $(this).val(self.filterFunction($(this).val()))
    })
  }

  ChordSpaceEdition.prototype.onChange = function (chordSpaceView, newChordString) {
    var currentChord = chordSpaceView._getChordAtThisPosition(this.songModel)
    var chordJson = ChordUtils.string2Json(newChordString)

    var removingChord = !!(chordJson.empty && currentChord !== undefined)
    var noUpdateToEmptyChord = !!(chordJson.empty && currentChord === undefined)
    var addingNewChord = !chordJson.empty && currentChord === undefined

    if (chordJson.error) {
      UserLog.logAutoFade('error', 'Chord "' + newChordString + '" not well formated')
    } else if (!noUpdateToEmptyChord && (removingChord || addingNewChord || !currentChord.equalsTo(chordJson))) {
      //last condition refers to when we are modifying existing chord
      $.publish('ChordSpaceView-updateChord', [chordJson, currentChord, chordSpaceView])
    }
  }

  /**
   * Set to upper case first notes, add a lot of replacement for french or not keyboard
   * @param  {String} s input string
   * @return {String}   output string
   */
  ChordSpaceEdition.prototype.filterFunction = function (s) {
    function indexesOf(source, find) {
      var result = []
      for (i = 0; i < source.length; ++i) {
        if (source.substring(i, i + find.length) == find) {
          result.push(i)
        }
      }
      return result
    }
    s = s.replace(/^[a-z]/, function (m) {
      return m.toUpperCase()
    })
    s = s.replace(/\/[a-z]/, function (m) {
      return m.toUpperCase()
    })
    s = s.replace('-', 'm')
    s = s.replace('è', '7')
    s = s.replace('ç', '9')
    s = s.replace('0', 'halfdim7')
    s = s.replace('<', '|')
    s = s.replace('.', 'dim7')
    s = s.replace('*', 'M7')
    s = s.replace('mm', 'mM')
    if (s.substring(0, 1) == '5') {
      s = s.replace('5', '%')
    }

    // replace 3 by # always except if it comes after 1 (e.g. A13) or after t (e.g. AM7(omit3) )
    var indexes = indexesOf(s, '3')
    for (var i in indexes) {
      if (s.charAt(indexes[i] - 1) != 1 && s.charAt(indexes[i] - 1) != 't') {
        s = s.substr(0, indexes[i]) + '#' + s.substr(indexes[i] + 1)
      }
    }

    s = s.replace(/^(.+)(p|²)$/, '($1)') // parenthesis and ²
    return s
  }

  return ChordSpaceEdition
})
define('modules/ChordEdition/src/ChordEdition', [
  'modules/ChordEdition/src/ChordEditionController',
  'modules/ChordEdition/src/ChordEditionView',
  'modules/ChordEdition/src/ChordSpaceManager',
  'modules/ChordEdition/src/ChordSpaceEdition',
], function (ChordEditionController, ChordEditionView, ChordSpaceManager, ChordSpaceEdition) {
  /**
   * ChordEdition constructor
   * @exports ChordEdition
   */
  function ChordEdition(songModel, cursorModel, viewer, imgPath) {
    var chordSpaceEdition = new ChordSpaceEdition(songModel, viewer)
    this.chordSpaceMng = new ChordSpaceManager(songModel, cursorModel, viewer, false, chordSpaceEdition)

    this.view = new ChordEditionView(cursorModel, imgPath)
    this.controller = new ChordEditionController(songModel, cursorModel, this.chordSpaceMng)
  }
  return ChordEdition
})
define('modules/core/src/SectionModel', [], function () {
  /**
   * Section fundamental model
   * @exports core/SectionModel
   */
  function SectionModel(params) {
    params = params || {}

    this.setName(params.name)
    this.setRepeatTimes(params.repeatTimes)
    this.setNumberOfBars(params.numberOfBars)
    this.setStyle(params.style)
    this.setTimeSignature(params.timeSignature)
  }

  /////////////////////////
  // Basic getters setters //
  /////////////////////////

  SectionModel.prototype.setName = function (name) {
    /*using 'name !== undefined' instead of 'typeof "undefined"', because then (ternary if) everything is in same line, 
		and it is more readable like this*/
    this.name = name !== undefined ? name : ''
  }

  SectionModel.prototype.getName = function () {
    return this.name
  }

  // Carefull, if a section is played 2 times, repeatTimes = 1
  SectionModel.prototype.setRepeatTimes = function (repeatTimes) {
    if (repeatTimes === undefined || repeatTimes === 'open') {
      repeatTimes = 0
    }
    if (repeatTimes < 0) {
      throw 'repeatTimes cannot be negative'
    }
    this.repeatTimes = parseInt(repeatTimes, 10)
  }

  SectionModel.prototype.getRepeatTimes = function () {
    return this.repeatTimes
  }

  SectionModel.prototype.setNumberOfBars = function (numberOfBars) {
    this.numberOfBars = numberOfBars !== undefined ? numberOfBars : 0
  }

  SectionModel.prototype.getNumberOfBars = function () {
    return this.numberOfBars
  }

  SectionModel.prototype.setStyle = function (style) {
    this.style = style !== undefined ? style : ''
  }

  SectionModel.prototype.getStyle = function () {
    return this.style
  }

  SectionModel.prototype.setTimeSignature = function (timeSignature) {
    this.timeSignature = timeSignature !== undefined ? timeSignature : undefined
    // empty timeSignature means it doesn't change from previous
  }

  SectionModel.prototype.getTimeSignature = function () {
    return this.timeSignature
  }
  /**
   * returns the unfolded section
   * @param  {Number} numBars the number of bars of the unfolded section. This can be calculated by SongModel.getUnfoldedSongSection.
   * @return {SectionModel}
   */
  SectionModel.prototype.cloneUnfolded = function (numBars) {
    if (!numBars) throw 'SectionModel - cloneUnfolded: numBars not valid :' + numBars
    return new SectionModel({
      name: this.name,
      numberOfBars: numBars,
      style: this.style,
      timeSignature: this.timeSignature,
    })
  }

  return SectionModel
})
define('modules/chordSequence/src/SongView_chordSequence', [
  'jquery',
  'modules/core/src/SongModel',
  'modules/core/src/SectionModel',
  'modules/core/src/BarManager',
  'modules/core/src/BarModel',
  'modules/core/src/ChordManager',
  'modules/core/src/ChordModel',
], function ($, SongModel, SectionModel, BarManager, BarModel, ChordManager, ChordModel) {
  /**
   * SongView_chordSequence is a text view created from SongModel that display mainly chords.
   * This view is usefull for musicians who use only a chord grid to play.
   * @exports ChordSequence
   */
  function SongView_chordSequence(parentHTML, songModel, option) {
    option = option || {}
    this.el = parentHTML
    // songModel
    this.songModel = typeof songModel !== 'undefined' && songModel instanceof SongModel ? songModel : undefined

    // display general option
    this.displayTitle = typeof option.displayTitle !== 'undefined' ? option.displayTitle : true
    this.classTitle = typeof option.classTitle !== 'undefined' ? option.classTitle : 'song_view-title'
    this.displayComposer = typeof option.displayComposer !== 'undefined' ? option.displayComposer : true
    this.displayBar = typeof option.displayBar !== 'undefined' ? option.displayBar : true
    this.delimiterBar = typeof option.delimiterBar !== 'undefined' ? option.delimiterBar : '|'
    this.delimiterNewLine = typeof option.delimiterNewLine !== 'undefined' ? option.delimiterNewLine : '<br />'
    this.delimiterBeat = typeof option.delimiterBeat !== 'undefined' ? option.delimiterBeat : ''
    this.displaySection = typeof option.displaySection !== 'undefined' ? option.displaySection : true
    this.fillEmptyBar = typeof option.fillEmptyBar !== 'undefined' ? option.fillEmptyBar : true
    this.fillEmptyBarCharacter =
      typeof option.fillEmptyBarCharacter !== 'undefined' ? option.fillEmptyBarCharacter : '%'
    this._initSubscribe()
  }

  SongView_chordSequence.prototype._initSubscribe = function () {
    var self = this
    $.subscribe('ToViewer-draw', function (el, songModel) {
      self.draw()
    })
  }

  SongView_chordSequence.prototype.draw = function () {
    var txt = ''
    if (typeof this.songModel !== 'undefined') {
      if (this.displayTitle === true) {
        txt += '<span class="song_view-title">' + this.songModel.getTitle() + '</span> '
      }
      if (this.displayComposer === true) {
        txt += '(' + this.songModel.getComposer() + ')'
      }
      if (this.displayTitle === true || this.displayComposer === true) {
        txt += this.delimiterNewLine
      }
      var bm = this.songModel.getComponent('bars')
      var sectionsLength = this.songModel.getSections().length
      for (var i = 0; i < sectionsLength; i++) {
        txt += this.delimiterNewLine
        txt += this.getSectionView(i)
        if (this.displayBar === true) {
          var currentBar
          var chordDuration
          var cm
          for (var currentBarNumber = 0, c = bm.getBars().length; currentBarNumber < c; currentBarNumber++) {
            currentBar = bm.getBar(currentBarNumber)
            if (currentBarNumber !== 0) {
              txt += this.delimiterBar
            }
            if (
              typeof currentBar.ending !== 'undefined' &&
              (currentBar.ending === 'BEGIN' || currentBar.ending === 'BEGIN_END')
            ) {
              txt += ':'
            }
            if (currentBarNumber !== 0) {
              txt += ' '
            }
            var chordsInCurrentBar = this.songModel.getComponentsAtBarNumber(currentBarNumber, 'chords')
            if (chordsInCurrentBar.length === 0 && this.fillEmptyBar === true) {
              txt += this.fillEmptyBarCharacter + ' '
            } else {
              for (var k = 0, v = chordsInCurrentBar.length; k < v; k++) {
                if (
                  typeof chordsInCurrentBar[k + 1] !== 'undefined' &&
                  chordsInCurrentBar[k].getBeat() === chordsInCurrentBar[k + 1].getBeat()
                ) {
                  txt += chordsInCurrentBar[k].toString('') + '_'
                } else {
                  txt += chordsInCurrentBar[k].toString('') + ' '
                }
                if (this.delimiterBeat !== '') {
                  cm = this.songModel.getComponent('chords')
                  chordDuration = cm.getChordDuration(this.songModel, cm.getChordIndex(chordsInCurrentBar[k]))
                  chordDuration = Math.floor(chordDuration)
                  for (var l = 0; l < chordDuration - 1; l++) {
                    txt += this.delimiterBeat + ' '
                  }
                }
              }
            }
            if (
              typeof currentBar.ending !== 'undefined' &&
              (currentBar.ending === 'END' || currentBar.ending === 'BEGIN_END')
            ) {
              txt += ':'
            }
          }
        }
        txt += this.delimiterNewLine
      }
    }
    this.el.innerHTML = txt
  }

  SongView_chordSequence.prototype.getSectionView = function (sectionNumber) {
    var txt = ''
    if (this.displaySection === true) {
      if (typeof this.songModel.getSection(sectionNumber) !== 'undefined') {
        var section = this.songModel.getSection(sectionNumber)
        txt += /*'section: ' + */ section.getName()
        if (section.getRepeatTimes() > 0) {
          var playedTimes = parseInt(section.getRepeatTimes(), 10) + 1
          txt += ' (' + playedTimes + ')'
        }
        // txt += this.delimiterNewLine;
        txt += ': '
      }
    }
    return txt
  }

  return SongView_chordSequence
})
define('modules/converters/MusicCSLJson/src/BarModel_CSLJson', ['modules/core/src/BarModel'], function (BarModel) {
  var BarModel_CSLJson = {}

  /////////////////////////
  //  Advanced function  //
  /////////////////////////

  BarModel_CSLJson.importFromMusicCSLJSON = function (JSONBar) {
    var bar = new BarModel()
    var labels = ['segno', 'segno2', 'fine', 'coda', 'coda2', 'on cue']
    labels.forEach(function (label) {
      if (JSONBar.hasOwnProperty(label)) {
        bar.setLabel(label)
      }
    })
    //so far now we allow only one label per bar in the DB, but this code is prepared to allow more than one, as an array
    if (JSONBar.hasOwnProperty('clef')) bar.setClef(JSONBar.clef)
    if (JSONBar.hasOwnProperty('ending')) bar.setEnding(JSONBar.ending)
    if (JSONBar.hasOwnProperty('style')) bar.setStyle(JSONBar.style)
    if (JSONBar.hasOwnProperty('sublabel')) bar.setSublabel(JSONBar.sublabel)
    if (JSONBar.hasOwnProperty('timeSignature')) bar.setTimeSignatureChange(JSONBar.timeSignature)
    if (JSONBar.hasOwnProperty('keySignature')) bar.setKeySignatureChange(JSONBar.keySignature)
    return bar
  }

  BarModel_CSLJson.exportToMusicCSLJSON = function (barModel) {
    var bar = {}

    if (barModel.getClef()) bar.clef = barModel.getClef()

    if (barModel.getEnding()) bar.ending = barModel.getEnding()

    if (barModel.getStyle()) bar.style = barModel.getStyle()

    if (barModel.getLabel()) bar[barModel.getLabel()] = 1

    if (barModel.getSublabel()) bar.sublabel = barModel.getSublabel()

    if (barModel.getTimeSignatureChange()) {
      bar.timeSignature = barModel.getTimeSignatureChange().toString()
    }
    if (barModel.getKeySignatureChange()) bar.keySignature = barModel.getKeySignatureChange()

    return bar
  }
  return BarModel_CSLJson
})
define('modules/converters/MusicCSLJson/src/ChordManager_CSLJson', ['modules/core/src/ChordModel'], function (
  ChordModel
) {
  var ChordManager_CSLJson = {}

  ChordManager_CSLJson.importFromMusicCSLJSON = function (MusicCSLJSON) {
    if (typeof MusicCSLJSON !== 'undefined') {
      var chordsSection = []
      var chordModel
      var barNumber = 0
      for (var i = 0, c = MusicCSLJSON.sections.length; i < c; i++) {
        for (var j = 0, v = chordsSection.length; j < v; j++) {
          for (var k = 0, b = chordsSection[j].length; k < b; k++) {
            chordModel = new ChordModel()
            chordModel.importFromMusicCSLJSON(chordsSection[j][k])
            chordModel.setBarNumber(barNumber)
            this.addChord(chordModel)
          }
          barNumber++
        }
      }
    }
    return this
  }

  ChordManager_CSLJson.exportToMusicCSLJSON = function (chordModel) {
    var chords = []
    if (typeof chordModel.chords !== 'undefined' && chordModel.chords.length) {
      var currentChord, currentBn
      for (var i = 0, c = chordModel.chords.length; i < c; i++) {
        currentChord = chordModel.getChord(i)
        currentBn = currentChord.getBarNumber()
        if (typeof chords[currentBn] === 'undefined') {
          chords[currentBn] = []
        }

        var jsonChord = {
          beat: currentChord.getBeat(),
          p: currentChord.getNote(),
          ch: currentChord.getChordType(),
        }
        if (!currentChord.isEmptyBase()) {
          jsonChord.bp = currentChord.getBase().getNote()
          jsonChord.bch = currentChord.getBase().getChordType()
        }
        if (currentChord.getParenthesis()) {
          jsonChord.parenthesis = currentChord.getParenthesis()
        }
        chords[currentBn].push(jsonChord)
      }
    }
    return chords
  }

  return ChordManager_CSLJson
})
define('modules/converters/MusicCSLJson/src/NoteManager_CSLJson', ['modules/core/src/NoteModel'], function (NoteModel) {
  var NoteManager_CSLJson = {}

  NoteManager_CSLJson.importFromMusicCSLJSON = function (notes, song) {
    if (typeof notes !== 'undefined') {
      for (var i in notes) {
        this.addNote(new NoteModel(notes[i]))
      }
    }
    this.setNotesBarNum(song)
    return this
  }
  /*  TODO: test does not exist */
  NoteManager_CSLJson.exportToMusicCSLJSON = function (noteManager, from, to) {
    var notes = []
    noteManager.getNotes(from, to + 1).forEach(function (note) {
      notes.push(note.exportToMusicCSLJSON(songModel))
    })
    return notes
  }
  return NoteManager_CSLJson
})

define('modules/converters/MusicCSLJson/src/NoteModel_CSLJson', [
  'modules/core/src/NoteModel',
  'utils/NoteUtils',
], function (NoteModel, NoteUtils) {
  var NoteModel_CSLJson = {}

  NoteModel_CSLJson.importFromMusicCSLJSON = function (noteStruct, noteModel) {
    var duration = noteStruct.duration
    if (duration.indexOf('r') != -1) {
      noteModel.duration = duration.substring(0, duration.length - 1)
      noteModel.isRest = true
      noteModel.barDuration = false // when there is only a whole note in the bar, its duration will depend on bar's duration. Initially is false, in SongModel_CSLJson it can be modified
    } else {
      noteModel.duration = duration
      noteModel.isRest = false
    }

    if (noteStruct.keys.length > 1) {
      noteStruct.keys = NoteUtils.sortPitches(noteStruct.keys)
    }

    var parsedNote
    for (var i = 0, c = noteStruct.keys.length; i < c; i++) {
      parsedNote = string2Obj(noteStruct.keys[i])

      noteModel.pitchClass[i] = parsedNote.pitchClass
      noteModel.accidental[i] = parsedNote.accidental
      noteModel.octave[i] = parsedNote.octave
    }

    noteModel.setDot(noteStruct.dot)
    noteModel.setTie(noteStruct.tie)
    noteModel.setTuplet(noteStruct.tuplet, noteStruct.time_modification)

    function string2Obj(strPitch) {
      var re = /[a-g|A-G](#{1,2}|b{1,2}|n)?\/\d/
      if (!strPitch.match(re))
        throw 'Error creating pitch ' + strPitch + '. Should be in the form [pitch][acc]/[octave]. e.g. Ab/4'

      var parts = strPitch.split('/')

      var pitchClass = parts[0].substr(0, 1).toUpperCase()
      var accidental = parts[0].substr(1, parts[0].length)
      var octave = parts[1]

      return {
        pitchClass: pitchClass,
        accidental: accidental,
        octave: octave,
      }
    }
  }

  NoteModel_CSLJson.exportToMusicCSLJSON = function (note, complete, withNumMeasure) {
    if (!note) {
      throw 'note sent is not correct'
    }
    if (complete === undefined) complete = true
    if (withNumMeasure === undefined) withNumMeasure = false

    var noteObj = {}
    noteObj.keys = []
    for (var i = 0, c = note.getNumPitches(); i < c; i++) {
      noteObj.keys.push(note.getPitch(i))
    }
    noteObj.duration = note.duration
    //important only set property if not null,
    if (note.dot != null) noteObj.dot = note.dot
    if (note.tie != null && complete) noteObj.tie = note.tie
    if (note.tuplet != null && complete) noteObj.tuplet = note.tuplet
    if (note.timeModification != null && complete) noteObj.time_modification = note.timeModification
    if (note.isRest) noteObj.duration += 'r'

    if (note.measure != null && withNumMeasure) noteObj.num_measure = note.measure
    return noteObj
  }

  return NoteModel_CSLJson
})
define('modules/converters/MusicCSLJson/src/SectionModel_CSLJson', ['modules/core/src/SectionModel'], function (
  SectionModel
) {
  var SectionModel_CSLJson = {}

  /////////////////////////
  //  Advanced function  //
  /////////////////////////

  SectionModel_CSLJson.importFromMusicCSLJSON = function (JSONSection, sectionModel) {
    if (
      typeof JSONSection === 'undefined' ||
      typeof sectionModel === 'undefined' ||
      !(sectionModel instanceof SectionModel)
    ) {
      throw 'SectionModel_CSLJson - importFromMusicCSLJSON - bad arguments type'
    }
    sectionModel.setName(JSONSection.name)
    sectionModel.setNumberOfBars(JSONSection.bars ? parseInt(JSONSection.bars.length) : 0)
    sectionModel.setTimeSignature(JSONSection.timeSignature)
    sectionModel.setRepeatTimes(JSONSection.repeat ? JSONSection.repeat : 0)
    sectionModel.setStyle(JSONSection.style)
  }

  SectionModel_CSLJson.exportToMusicCSLJSON = function (sectionModel) {
    var sectionMusicCSLJSON = {}
    sectionMusicCSLJSON.name = sectionModel.getName()

    if (sectionModel.getTimeSignature()) sectionMusicCSLJSON.timeSig = sectionModel.getTimeSignature().toString()

    if (sectionModel.getRepeatTimes()) sectionMusicCSLJSON.repeat = sectionModel.getRepeatTimes()

    if (sectionModel.getStyle()) sectionMusicCSLJSON.style = sectionModel.getStyle()

    return sectionMusicCSLJSON
  }

  return SectionModel_CSLJson
})
define('modules/converters/MusicCSLJson/src/SongModel_CSLJson', [
  'require',
  'modules/core/src/SongModel',
  'modules/core/src/SectionModel',
  'modules/core/src/BarManager',
  'modules/core/src/BarModel',
  'modules/core/src/ChordManager',
  'modules/core/src/ChordModel',
  'modules/core/src/NoteManager',
  'modules/core/src/NoteModel',
  'modules/converters/MusicCSLJson/src/SectionModel_CSLJson',
  'modules/converters/MusicCSLJson/src/BarModel_CSLJson',
  'modules/converters/MusicCSLJson/src/ChordManager_CSLJson',
  'modules/converters/MusicCSLJson/src/ChordModel_CSLJson',
  'modules/converters/MusicCSLJson/src/NoteManager_CSLJson',
  'modules/converters/MusicCSLJson/src/NoteModel_CSLJson',
  'modules/core/src/SongBarsIterator',
  'utils/NoteUtils',
], function (require) {
  var SongModel = require('modules/core/src/SongModel')
  var SectionModel = require('modules/core/src/SectionModel')
  var BarManager = require('modules/core/src/BarManager')
  var BarModel = require('modules/core/src/BarModel')
  var ChordManager = require('modules/core/src/ChordManager')
  var ChordModel = require('modules/core/src/ChordModel')
  var NoteManager = require('modules/core/src/NoteManager')
  var NoteModel = require('modules/core/src/NoteModel')
  var SectionModel_CSLJson = require('modules/converters/MusicCSLJson/src/SectionModel_CSLJson')
  var BarModel_CSLJson = require('modules/converters/MusicCSLJson/src/BarModel_CSLJson')
  var ChordManager_CSLJson = require('modules/converters/MusicCSLJson/src/ChordManager_CSLJson')
  var ChordModel_CSLJson = require('modules/converters/MusicCSLJson/src/ChordModel_CSLJson')
  var NoteManager_CSLJson = require('modules/converters/MusicCSLJson/src/NoteManager_CSLJson')
  var NoteModel_CSLJson = require('modules/converters/MusicCSLJson/src/NoteModel_CSLJson')
  var SongBarsIterator = require('modules/core/src/SongBarsIterator')
  var NoteUtils = require('utils/NoteUtils')

  var SongModel_CSLJson = {}

  SongModel_CSLJson.importFromMusicCSLJSON = function (MusicCSLJSON, songModel, id) {
    if (!songModel || !songModel instanceof SongModel) {
      songModel = new SongModel()
    } else {
      songModel.clear()
    }
    var chordManager = new ChordManager()
    var noteManager = new NoteManager()
    var barManager = new BarManager()

    //if (!MusicCSLJSON._id && !id)	throw "SongModel: importing from MusicCSL no id specified";

    if (!MusicCSLJSON) {
      throw "SongModel_CSLJson-importFromMusicCSLJSON: You can't import an empty song " + MusicCSLJSON
    }

    //there are 4 cases: id by param, _id is 'MongoId' from php, _id is 'MongoId' from javascript or _id is string
    if (typeof MusicCSLJSON._id !== 'undefined') {
      if (typeof MusicCSLJSON._id['$oid'] !== 'undefined') {
        MusicCSLJSON._id['$id'] = MusicCSLJSON._id['$oid']
      }
    }
    songModel._id = MusicCSLJSON._id ? MusicCSLJSON._id['$id'] : id
    if (!songModel._id) songModel._id = MusicCSLJSON._id

    if (typeof MusicCSLJSON !== 'undefined') {
      songModel.setTitle(MusicCSLJSON.title)
      songModel.setTimeSignature(MusicCSLJSON.time)
      songModel.setTonality(MusicCSLJSON.keySignature)
      songModel.addComposer(MusicCSLJSON.composer)
      songModel.setStyle(MusicCSLJSON.style)
      songModel.setSource(MusicCSLJSON.source)
      songModel.setTempo(MusicCSLJSON.tempo)

      var section, chord, note, bar
      var barNumber = 0,
        onlyOneNote,
        wholeRestFound = false
      if (MusicCSLJSON.changes != null) {
        MusicCSLJSON.changes.forEach(function (JSONSection) {
          section = new SectionModel()
          SectionModel_CSLJson.importFromMusicCSLJSON(JSONSection, section)
          songModel.addSection(section)

          if (JSONSection.bars != null) {
            JSONSection.bars.forEach(function (JSONBar) {
              bar = BarModel_CSLJson.importFromMusicCSLJSON(JSONBar, new BarModel())
              barManager.addBar(bar)
              //chords:
              if (JSONBar.chords != null) {
                JSONBar.chords.forEach(function (JSONChord) {
                  chord = ChordModel_CSLJson.importFromMusicCSLJSON(JSONChord)
                  chord.setBarNumber(barNumber)
                  chordManager.addChord(chord)
                })
              }
              //melody;
              if (JSONBar.melody != null) {
                onlyOneNote = JSONBar.melody.length === 1
                JSONBar.melody.forEach(function (JSONNote) {
                  note = new NoteModel()
                  NoteModel_CSLJson.importFromMusicCSLJSON(JSONNote, note)
                  noteManager.addNote(note)
                })
                if (onlyOneNote && note.isRest && note.duration === 'w') {
                  note.durationDependsOnBar = true // if it's a whole rest, it will take bar's duration
                  wholeRestFound = true
                }
              } else {
                //if no notes in bar, we add a whole rest
                note = new NoteModel()
                note.setNoteFromString('wr')
                noteManager.addNote(note)
                note.durationDependsOnBar = true
                wholeRestFound = true
              }
              barNumber++
            })
          } else {
            console.log(JSONSection.bars)
          }
        })
        songModel.addComponent('bars', barManager)
        //noteManager.setNotesBarNum(songModel);
        songModel.addComponent('chords', chordManager)
        songModel.addComponent('notes', noteManager)
      }
      //songModel.getUnfoldedSongStructure();
      if (wholeRestFound) {
        //if found bars with only one whole rest
        SongModel_CSLJson._updateNotesBarDuration(songModel)
      }
    }
    return songModel
  }
  /**
   * If there are bars with only one whole rest (very few cases), we set their real duration, which depends on the time signature bar
   * @param  {SongModel} song
   */
  SongModel_CSLJson._updateNotesBarDuration = function (song) {
    /**
			function already defined in noteManager, it should be used in an 'utils' mod
		*/
    function roundBeat(beat) {
      return Math.round(beat * 1000000) / 1000000
    }
    var songIt = new SongBarsIterator(song),
      notes = song.getComponent('notes').getNotes(),
      currentBarNumBeats = songIt.getBarTimeSignature().getQuarterBeats(),
      notesBarDur = 0

    var i = 0
    while (songIt.hasNext() && i < notes.length) {
      // if it's first note, and duration depends on bar (only whole notes can have durationDependsOnBar = true)
      if (notesBarDur === 0 && notes[i].durationDependsOnBar) {
        notes[i].barDuration = currentBarNumBeats
      }

      notesBarDur += notes[i].getDuration()
      if (notesBarDur > currentBarNumBeats) {
        console.warn('note exceeds bar duration (index ' + i + ') bar ' + songIt.getBarIndex())
      } else if (roundBeat(notesBarDur) == currentBarNumBeats) {
        notesBarDur = 0
        songIt.next()
        if (songIt.hasNext()) {
          currentBarNumBeats = songIt.getBarTimeSignature().getQuarterBeats()
        }
      }
      i++
    }
    /*for (var i = 0; i < notes.length; i++) {
			// if it's first note, and duration depends on bar (only whole notes can have durationDependsOnBar = true)
			if (notesBarDur === 0 && notes[i].durationDependsOnBar){
				notes[i].barDuration = currentBarNumBeats;

			}
			notesBarDur += notes[i].getDuration();

			if (notesBarDur > currentBarNumBeats){
				console.warn("note exceeds bar duration (index "+ i +")");
			}
			else if (roundBeat(notesBarDur) == currentBarNumBeats ){
				notesBarDur = 0;
				
				if (songIt.next()){
					currentBarNumBeats = songIt.getBarTimeSignature().getQuarterBeats();
				}
			}
		}*/
  }
  SongModel_CSLJson.exportToMusicCSLJSON = function (songModel) {
    if (!songModel instanceof SongModel) {
      throw 'SongModel_CSLJson - exportToMusicCSLJSON - songModel parameters must be an instanceof SongModel'
    }

    var MusicCSLJSON = {}
    if (typeof songModel._id !== 'undefined') {
      MusicCSLJSON._id = songModel._id
    }
    var composer = songModel.getComposer()
    if (typeof composer !== 'undefined') {
      composer = composer.toString()
    }
    MusicCSLJSON.composer = composer
    MusicCSLJSON.title = songModel.getTitle()

    MusicCSLJSON.time = songModel.getTimeSignature().toString()

    MusicCSLJSON.keySignature = songModel.getTonality()
    MusicCSLJSON.tempo = songModel.getTempo()

    MusicCSLJSON.style = songModel.getStyle()
    MusicCSLJSON.source = songModel.getSource()

    // Sections
    var bm = songModel.getComponent('bars')
    var JSONSection = {}
    var startbarNumber, lastBarSection, barChords, barNotes
    MusicCSLJSON.changes = []
    for (var i = 0, c = songModel.getSections().length; i < c; i++) {
      // section information
      JSONSection = SectionModel_CSLJson.exportToMusicCSLJSON(songModel.getSection(i))
      // bar information
      startbarNumber = songModel.getStartBarNumberFromSectionNumber(i)
      lastBarSection = startbarNumber + songModel.getSection(i).getNumberOfBars() - 1

      var bars = []
      var bar, chords, melody
      var JSONBar, JSONChord, JSONNote

      for (var j = startbarNumber; j <= lastBarSection; j++) {
        JSONBar = BarModel_CSLJson.exportToMusicCSLJSON(bm.getBar(j))
        //bar = bm.getBar(j).exportToMusicCSLJSON(songModel);

        chords = []
        barChords = songModel.getComponentsAtBarNumber(j, 'chords')
        //jsLint complains but nevermind
        barChords.forEach(function (chord) {
          JSONChord = ChordModel_CSLJson.exportToMusicCSLJSON(chord)
          chords.push(JSONChord)
        })

        if (chords.length != 0) JSONBar.chords = chords

        barNotes = songModel.getComponentsAtBarNumber(j, 'notes')

        melody = []
        barNotes.forEach(function (note) {
          JSONNote = NoteModel_CSLJson.exportToMusicCSLJSON(note)
          melody.push(JSONNote)
        })

        if (melody.length !== 0) JSONBar.melody = melody

        bars.push(JSONBar)
      }

      JSONSection.bars = bars
      MusicCSLJSON.changes[i] = JSONSection
    }
    return MusicCSLJSON
  }

  return SongModel_CSLJson
})
define('modules/converters/MusicCSLJson/src/main', [
  'modules/converters/MusicCSLJson/src/BarModel_CSLJson',
  'modules/converters/MusicCSLJson/src/ChordManager_CSLJson',
  'modules/converters/MusicCSLJson/src/ChordModel_CSLJson',
  'modules/converters/MusicCSLJson/src/NoteManager_CSLJson',
  'modules/converters/MusicCSLJson/src/NoteModel_CSLJson',
  'modules/converters/MusicCSLJson/src/SectionModel_CSLJson',
  'modules/converters/MusicCSLJson/src/SongModel_CSLJson',
], function (
  BarModel_CSLJson,
  ChordManager_CSLJson,
  ChordModel_CSLJson,
  NoteManager_CSLJson,
  NoteModel_CSLJson,
  SectionModel_CSLJson,
  SongModel_CSLJson
) {
  return {
    BarModel_CSLJson: BarModel_CSLJson,
    ChordManager_CSLJson: ChordManager_CSLJson,
    ChordModel_CSLJson: ChordModel_CSLJson,
    NoteManager_CSLJson: NoteManager_CSLJson,
    NoteModel_CSLJson: NoteModel_CSLJson,
    SectionModel_CSLJson: SectionModel_CSLJson,
    SongModel_CSLJson: SongModel_CSLJson,
  }
})
define('modules/converters/MusicXML/src/BarModel_MusicXML', ['modules/core/src/BarModel'], function (BarModel) {
  var BarModel_MusicXML = {}

  BarModel_MusicXML.importFromMusicXML = function (MusicXMLBar) {
    var bar = new BarModel()
    if (MusicXMLBar.hasOwnProperty('key')) bar.setKeySignatureChange(MusicXMLBar.key)
    var clef = 'treble'
    if (
      MusicXMLBar.hasOwnProperty('stave') &&
      typeof MusicXMLBar.stave[0] !== 'undefined' &&
      typeof MusicXMLBar.stave[0].clef !== 'undefined'
    ) {
      clef = MusicXMLBar.stave[0].clef
    } else if (MusicXMLBar.hasOwnProperty('clef')) {
      clef = MusicXMLBar.clef
    }
    bar.setClef(clef)
    if (MusicXMLBar.hasOwnProperty('time')) {
      bar.setTimeSignatureChange(MusicXMLBar.time.num_beats + '/' + MusicXMLBar.time.beat_value)
    } else {
      bar.setTimeSignatureChange('4/4')
    }
    return bar
  }

  return BarModel_MusicXML
})
define('modules/converters/MusicXML/src/ChordModel_MusicXML', ['modules/core/src/ChordModel'], function (ChordModel) {
  var ChordModel_MusicXML = {}

  ChordModel_MusicXML.importFromMusicXML = function (MusicXMLChord) {
    var chord = new ChordModel()

    if (MusicXMLChord.hasOwnProperty('chordPitch')) {
      chord.setNote(MusicXMLChord.chordPitch)
    }
    if (MusicXMLChord.hasOwnProperty('chordType')) {
      chord.setChordType(MusicXMLChord.chordType)
    }

    return chord
  }

  return ChordModel_MusicXML
})
define('modules/converters/MusicXML/src/NoteModel_MusicXML', ['modules/core/src/NoteModel'], function (NoteModel) {
  var NoteModel_MusicXML = {}

  NoteModel_MusicXML.importFromMusicXML = function (MusicXMLNote, note) {
    if (typeof note === 'undefine' || !(note instanceof NoteModel)) {
      note = new NoteModel()
    }

    if (MusicXMLNote.hasOwnProperty('rest')) {
      note.isRest = MusicXMLNote.rest
    }
    if (MusicXMLNote.hasOwnProperty('dot')) {
      note.setDot(1)
    }

    var duration = MusicXMLNote.duration
    if (duration.indexOf('r') != -1) {
      note.setDuration(duration.substring(0, duration.length - 1))
      note.isRest = true
    } else {
      note.setDuration(duration)
      note.isRest = false
    }

    if (MusicXMLNote.keys.length > 1) {
      MusicXMLNote.keys = NoteUtils.sortPitches(MusicXMLNote.keys)
    }

    var parsedNote
    for (var i = 0, c = MusicXMLNote.keys.length; i < c; i++) {
      parsedNote = string2Obj(MusicXMLNote.keys[i])
      note.pitchClass[i] = parsedNote.pitchClass
      note.accidental[i] = parsedNote.accidental
      note.octave[i] = parsedNote.octave
    }

    note.setDot(MusicXMLNote.dot)
    note.setTie(MusicXMLNote.tie)
    if (typeof MusicXMLNote.tuplet === 'object' && MusicXMLNote.tuplet !== null) {
      note.setTuplet(
        MusicXMLNote.tuplet.typeTuplet,
        MusicXMLNote.tuplet.num_notes + '/' + MusicXMLNote.tuplet.beats_occupied
      )
    }
    return note

    function string2Obj(strPitch) {
      var re = /[a-g|A-G](#{1,2}|b{1,2}|n)?\/\d/
      if (!strPitch.match(re))
        throw 'Error creating pitch ' + strPitch + '. Should be in the form [pitch][acc]/[octave]. e.g. Ab/4'

      var parts = strPitch.split('/')

      var pitchClass = parts[0].substr(0, 1).toUpperCase()
      var accidental = parts[0].substr(1, parts[0].length)
      var octave = parts[1]

      return {
        pitchClass: pitchClass,
        accidental: accidental,
        octave: octave,
      }
    }
  }

  return NoteModel_MusicXML
})
define('modules/converters/MusicXML/utils/musicXMLParser', ['require'], function (require) {
  /**
   * VexFlow MusicXML - DOM-based MusicXML backend for VexFlow Documents.
   * @author Daniel Ringwalt (ringw)
   * https://github.com/ringw/vexflow/blob/musicxml/tests/document_tests.js
   */

  var MusicXMLParser = {}

  /** @constructor */
  MusicXMLParser = function () {
    this.partList = []
    this.partName = []
    this.staveConnectors = []
    // Create timewise array of arrays
    // Measures (zero-indexed) -> array of <measure> elements for each part
    this.measures = []
    // Actual measure number for each measure
    // (Usually starts at 1, or 0 for pickup measure and numbers consecutively)
    this.measureNumbers = []
    // Store number of staves for each part (zero-indexed)
    this.numStaves = []
    // Track every child of any <attributes> element in array
    // (except <staves> which is stored in numStaves)
    // Measures -> parts ->
    //  object where keys are names of child elements ->
    //    data representing the attribute
    this.attributes = []
  }

  MusicXMLParser.appearsValid = function (data) {
    if (typeof data == 'string') {
      return data.search(/<score-partwise/i) != -1
    }
    return data instanceof Document && data.documentElement.nodeName == 'score-partwise'
  }

  MusicXMLParser.prototype.parse = function (data) {
    if (typeof data == 'string') {
      // Parse XML string
      if (window.DOMParser && typeof XMLDocument != 'undefined') {
        var parser = new window.DOMParser()
        this.document = parser.parseFromString(data, 'text/xml')
      } else if (window.ActiveXObject && new window.ActiveXObject('Microsoft.XMLDOM')) {
        this.document = new window.ActiveXObject('Microsoft.XMLDOM')
        this.document.async = 'false'
        this.document.loadXML(data)
      } else throw new Vex.RERR('UnsupportedBrowserError', 'No XML parser found')
    } else if (data instanceof Document) this.document = data
    else {
      this.valid = false
      throw new Vex.RERR('ArgumentError', 'MusicXML requires XML string or DOM Document object')
    }
    this.documentElement = this.document.documentElement
    if (this.documentElement.nodeName != 'score-partwise')
      throw new Vex.RERR('ArgumentError', 'VexFlow only supports partwise scores')

    // Go through each part, pushing the measures on the correct sub-array
    var partNum = 0
    Array.prototype.forEach.call(
      this.documentElement.childNodes,
      function (node) {
        if (node.nodeName == 'part-list') this.parsePartList(node)
        else if (node.nodeName == 'part') {
          var measureNum = 0
          for (var j = 0; j < node.childNodes.length; j++) {
            var measure = node.childNodes[j]
            if (measure.nodeName != 'measure') continue
            if (!(measureNum in this.measures)) this.measures[measureNum] = []
            if (this.measures[measureNum].length != partNum) {
              // Some part is missing a measure
              Vex.LogFatal('Part missing measure')
              this.valid = false
              return
            }
            if (!(measureNum in this.measureNumbers)) {
              var num = parseInt(measure.getAttribute('number'))
              if (!isNaN(num)) this.measureNumbers[measureNum] = num
            }
            this.measures[measureNum][partNum] = measure
            var attributes = measure.getElementsByTagName('attributes')[0]
            if (attributes) this.parseAttributes(measureNum, partNum, attributes)
            measureNum++
          }
          // numStaves defaults to 1 for this part
          if (!(partNum in this.numStaves)) this.numStaves[partNum] = 1
          partNum++
        }
      },
      this
    )

    // Create a brace for each part with multiple staves
    var partNum = 0
    this.numStaves.forEach(function (staves) {
      if (staves > 1)
        this.staveConnectors.push({
          type: 'brace',
          parts: [partNum],
          system_start: true,
        })
      partNum++
    }, this)

    this.valid = true
  }

  MusicXMLParser.prototype.parsePartList = function (partListElem) {
    // We only care about stave connectors in part groups
    var partNum = 0
    var partGroup = null
    var staveConnectors = null // array of stave connectors for part group
    Array.prototype.forEach.call(
      partListElem.childNodes,
      function (elem) {
        switch (elem.nodeName) {
          case 'part-group':
            if (elem.getAttribute('type') == 'start') {
              partGroup = []
              staveConnectors = []
              Array.prototype.forEach.call(elem.childNodes, function (groupElem) {
                switch (groupElem.nodeName) {
                  case 'group-symbol':
                    if (groupElem.textContent == 'bracket' || groupElem.textContent == 'brace')
                      // Supported connectors
                      staveConnectors.push({
                        type: groupElem.textContent,
                        system_start: true,
                      })
                  case 'group-barline':
                    if (groupElem.textContent == 'yes')
                      staveConnectors.push({
                        type: 'single',
                        measure_start: true,
                        system_end: true,
                      })
                }
              })
            } else if (elem.getAttribute('type') == 'stop') {
              staveConnectors.forEach(function (connect) {
                connect.parts = partGroup
                this.staveConnectors.push(connect)
              }, this)
              partGroup = staveConnectors = null
            }
            break
          case 'score-part':
            if (partGroup) partGroup.push(partNum)
            var self = this
            Array.prototype.forEach.call(elem.childNodes, function (groupElem) {
              if (groupElem.nodeName === 'part-name') {
                self.partName[partNum] = groupElem.textContent
              }
            })
            this.partList.push(partNum)
            partNum++
            break
        }
      },
      this
    )
  }

  MusicXMLParser.prototype.isValid = function () {
    return this.valid
  }

  MusicXMLParser.prototype.getNumberOfMeasures = function () {
    return this.measures.length
  }

  MusicXMLParser.prototype.getMeasureNumber = function (m) {
    var num = this.measureNumbers[m]
    return isNaN(num) ? null : num
  }

  MusicXMLParser.prototype.getMeasure = function (m) {
    var measure_attrs = this.getAttributes(m, 0)
    var time = measure_attrs.time
    var measureInfos = {
      time: time,
    }
    var measure = {
      part: [],
    }
    var numParts = this.measures[m].length
    for (var p = 0; p < numParts; p++) {
      measure.part[p] = {}
      var attrs = this.getAttributes(m, p)
      if (typeof attrs.clef == 'string') measureInfos.clef = attrs.clef
      if (typeof attrs.key == 'string') measureInfos.key = attrs.key

      measureInfos.numberOfStaves = this.numStaves[p]
      measureInfos.stave = []
      if (attrs.clef instanceof Array)
        for (var s = 0; s < this.numStaves[p]; s++) {
          measureInfos.stave[s] = {
            clef: attrs.clef[s],
          }
        }
      measure.part[p].measureInfos = measureInfos
      measure.part[p].notes = []
      var noteElems = this.measures[m][p].getElementsByTagName('note')
      for (var i = 0; i < noteElems.length; i++) {
        var noteObj = this.parseNote(noteElems[i], attrs)
        measure.part[p].notes.push(noteObj)
        if (noteObj.grace) continue // grace note requires VexFlow support
      }

      measure.part[p].chords = []
      var chordElems = this.measures[m][p].getElementsByTagName('harmony')
      for (var i = 0, c = chordElems.length; i < c; i++) {
        var chordObj = this.parseChord(chordElems[i], attrs)
        measure.part[p].chords.push(chordObj)
      }
    }
    return measure
  }

  MusicXMLParser.prototype.getStaveConnectors = function () {
    return this.staveConnectors
  }

  MusicXMLParser.prototype.parseAttributes = function (measureNum, partNum, attributes) {
    var attrs = attributes.childNodes
    for (var i = 0; i < attrs.length; i++) {
      var attrObject = null
      var attr = attrs[i]
      switch (attr.nodeName) {
        case 'staves':
          // If this is the first measure, we use <staves>
          if (measureNum == 0) this.numStaves[partNum] = parseInt(attr.textContent)
          break
        case 'key':
          attrObject = this.getKeySignature(parseInt(attr.getElementsByTagName('fifths')[0].textContent))
          break
        case 'time':
          attrObject =
            attr.getElementsByTagName('senza-misura').length > 0
              ? {
                  num_beats: 4,
                  beat_value: 4,
                  soft: true,
                }
              : {
                  num_beats: parseInt(attr.getElementsByTagName('beats')[0].textContent),
                  beat_value: parseInt(attr.getElementsByTagName('beat-type')[0].textContent),
                  soft: true, // XXX: Should we always have soft voices?
                }
          break
        case 'clef':
          var number = parseInt(attr.getAttribute('number'))
          var sign = attr.getElementsByTagName('sign')[0].textContent
          var line = parseInt(attr.getElementsByTagName('line')[0].textContent)
          var clef =
            sign == 'G' && line == '2'
              ? 'treble'
              : sign == 'C' && line == '3'
              ? 'alto'
              : sign == 'C' && line == '4'
              ? 'tenor'
              : sign == 'F' && line == '4'
              ? 'bass'
              : null
          if (number > 0) {
            if (
              measureNum in this.attributes &&
              partNum in this.attributes[measureNum] &&
              this.attributes[measureNum][partNum].clef instanceof Array
            )
              attrObject = this.attributes[measureNum][partNum].clef
            else attrObject = new Array(this.numStaves[partNum])
            attrObject[number - 1] = clef
          } else attrObject = clef
          break
        case 'divisions':
          attrObject = parseInt(attr.textContent)
          break
        default:
          continue // Don't use attribute if we don't know what it is
      }
      if (!(measureNum in this.attributes)) this.attributes[measureNum] = []
      if (!(partNum in this.attributes[measureNum])) this.attributes[measureNum][partNum] = {}
      this.attributes[measureNum][partNum][attr.nodeName] = attrObject
    }
    return attrObject
  }

  MusicXMLParser.prototype.parseNote = function (noteElem, attrs) {
    var noteObj = {
      rest: false,
      chord: false,
    }
    noteObj.tickMultiplier = 1
    noteObj.tuplet = null
    Array.prototype.forEach.call(noteElem.childNodes, function (elem) {
      switch (elem.nodeName) {
        case 'pitch':
          var step = elem.getElementsByTagName('step')[0].textContent
          var octave = parseInt(elem.getElementsByTagName('octave')[0].textContent)
          var alter = elem.getElementsByTagName('alter')[0]
          if (alter)
            switch (parseInt(alter.textContent)) {
              case 1:
                step += '#'
                break
              case 2:
                step += '##'
                break
              case -1:
                step += 'b'
                break
              case -2:
                step += 'bb'
                break
            }
          noteObj.keys = [step + '/' + octave.toString()]
          break
        case 'type':
          var type = elem.textContent
          // Look up type
          noteObj.duration = {
            /*"whole": "1",
						"half": "2",
						"quarter": "4",
						"eighth": "8",
						"16th": "16",
						"32nd": "32",
						"64th": "64",
						"128th": "128",
						"256th": "256"*/
            whole: 'w',
            half: 'h',
            quarter: 'q',
            eighth: '8',
            '16th': '16',
            '32nd': '32',
            '64th': '64',
            '128th': '128',
            '256th': '256',
          }[type]
          if (noteObj.rest) noteObj.duration += 'r'
          break
        case 'dot': // Always follow type; noteObj.duration exists
          /*var duration = noteObj.duration,
						rest = duration.indexOf("r");
					if (noteObj.rest) duration = duration.substring(0, rest) + "dr";
					else duration += "d";
					noteObj.duration = duration;*/
          noteObj.dot = true
          break
        case 'duration':
          var intrinsicTicks = {
            numerator: 1 / (4 * parseInt(elem.textContent, 10)),
            denominator: attrs.divisions,
          }
          if (isNaN(intrinsicTicks.numerator) || isNaN(intrinsicTicks.denominator))
            throw 'InvalidMusicXML - Error parsing MusicXML duration'
          if (intrinsicTicks.denominator == 1) intrinsicTicks = intrinsicTicks.numerator
          noteObj.intrinsicTicks = intrinsicTicks
          // TODO: come up with duration string if we don't have a type
          if (!noteObj.duration) noteObj.duration = '4'
          break
        case 'time-modification':
          var num_notes = elem.getElementsByTagName('actual-notes')[0]
          var beats_occupied = elem.getElementsByTagName('normal-notes')[0]
          if (num_notes && beats_occupied) {
            num_notes = parseInt(num_notes.textContent)
            beats_occupied = parseInt(beats_occupied.textContent)
            if (!(num_notes > 0 && beats_occupied > 0)) break
            noteObj.tickMultiplier = {
              beats_occupied: beats_occupied,
              num_notes: num_notes,
            }
            noteObj.tuplet = {
              typeTuplet: 'middle',
              num_notes: num_notes,
              beats_occupied: beats_occupied,
            }
          }
          break
        case 'rest':
          noteObj.rest = true
          var step = elem.getElementsByTagName('display-step')[0]
          var octave = elem.getElementsByTagName('display-octave')[0]
          if (step && octave) noteObj.keys = [step.textContent + '/' + octave.textContent]
          // FIXME: default length for rest only if length is full measure
          if (!noteObj.duration) noteObj.duration = '1r'
          break
        case 'grace':
          noteObj.grace = true
          break
        case 'chord':
          noteObj.chord = true
          break
        case 'voice':
          var voice = parseInt(elem.textContent)
          if (!isNaN(voice)) noteObj.voice = voice
          break
        case 'staff':
          var stave = parseInt(elem.textContent)
          if (!isNaN(stave) && stave > 0) noteObj.stave = stave - 1
          break
        case 'stem':
          if (elem.textContent == 'up') noteObj.stem_direction = 1
          else if (elem.textContent == 'down') noteObj.stem_direction = -1
          break
        case 'beam':
          var beam = elem.textContent
          if (beam != 'begin' && beam != 'continue' && beam != 'end') break
          // "continue" overrides begin or end when there are multiple beams
          // TODO: support backward hook/forward hook,
          //       partial beam between groups of notes where needed
          if (noteObj.beam != 'continue') noteObj.beam = beam
          break
        case 'lyric':
          var text = elem.getElementsByTagName('text')[0]
          if (text) text = text.textContent
          if (text)
            noteObj.lyric = {
              text: text,
            }
          break
        case 'notations':
          Array.prototype.forEach.call(elem.childNodes, function (notationElem) {
            /*console.log('--------');
						console.log(notationElem);
						console.log(notationElem.nodeName);*/
            switch (notationElem.nodeName) {
              case 'tied': // start-start/stop-stop vs begin-continue-end
                var tie = notationElem.getAttribute('type')
                switch (tie) {
                  case 'start':
                    noteObj.tie = noteObj.tie == 'stop' ? 'stop_start' : 'start'
                    break
                  case 'stop':
                    noteObj.tie = noteObj.tie == 'start' ? 'stop_start' : 'stop'
                    break
                  default:
                    throw 'BadMusicXML - Bad tie: ' + tie.toString()
                }
                //console.log(noteObj.tie);
                break
              case 'tuplet': // start-start/stop-stop vs begin-continue-end
                var tuplet = notationElem.getAttribute('type')
                switch (tuplet) {
                  case 'start':
                    noteObj.tuplet.typeTuplet = noteObj.tuplet.typeTuplet == 'stop' ? 'stop_start' : 'start'
                    break
                  case 'stop':
                    noteObj.tuplet.typeTuplet = noteObj.tuplet.typeTuplet == 'start' ? 'stop_start' : 'stop'
                    break
                  default:
                    throw 'BadMusicXML - Bad tuplet: ' + tuplet.toString()
                }
                //console.log(noteObj.tuplet.typeTuplet);
                break
              // TODO: tuplet
            }
            //console.log('---');
          })
          break
      }
    })
    // Set default rest position now that we know the stave
    if (noteObj.rest && !noteObj.keys) {
      var clef = attrs.clef
      if (clef instanceof Array) clef = clef[noteObj.stave]
      switch (clef) {
        case 'bass':
          noteObj.keys = ['D/3']
          break
        case 'tenor':
          noteObj.keys = ['A/3']
          break
        case 'alto':
          noteObj.keys = ['C/4']
          break
        case 'treble':
        default:
          noteObj.keys = ['B/4']
          break
      }
    }
    return noteObj
  }

  MusicXMLParser.prototype.parseChord = function (chordElems, attrs) {
    var chordObj = {}
    Array.prototype.forEach.call(chordElems.childNodes, function (elem) {
      switch (elem.nodeName) {
        case 'root':
          chordObj.chordPitch = elem.getElementsByTagName('root-step')[0].textContent
          if (typeof elem.getElementsByTagName('root-alter')[0] !== 'undefined') {
            if (elem.getElementsByTagName('root-alter')[0].textContent === '-1') {
              chordObj.chordPitch += 'b'
            }
            if (elem.getElementsByTagName('root-alter')[0].textContent === '1') {
              chordObj.chordPitch += '#'
            }
          }
          break
        case 'kind':
          if (typeof elem.attributes['text'] !== 'undefined') {
            chordObj.chordType = elem.attributes['text'].textContent
          } else {
            chordObj.chordType = elem.textContent
          }
          break
      }
    })
    return chordObj
  }

  /**
   * Returns complete attributes object for measure m, part p (zero-indexed)
   */
  MusicXMLParser.prototype.getAttributes = function (m, p) {
    var attrs = {}
    // Merge with every previous attributes object in order
    // If value is an array, merge non-null indices only
    for (var i = 0; i <= m; i++) {
      if (!(i in this.attributes)) continue
      if (!(p in this.attributes[i])) continue
      var measureAttrs = this.attributes[i][p]
      for (var key in measureAttrs) {
        var val = measureAttrs[key]
        if (val instanceof Array) {
          if (!(attrs[key] && attrs[key] instanceof Array)) attrs[key] = []
          for (var ind = 0; ind < val.length; ind++)
            if (typeof attrs[key][ind] == 'undefined' || (typeof val[ind] != 'undefined' && val[ind] != null))
              attrs[key][ind] = val[ind]
        } else attrs[key] = val
      }
    }

    // Default attributes
    if (!attrs.time)
      attrs.time = {
        num_beats: 4,
        beat_value: 4,
        soft: true,
      }

    return attrs
  }

  /**
   * Converts keys as fifths (e.g. -2 for Bb) to the equivalent major key ("Bb").
   * @param {Number} number of fifths from -7 to 7
   * @return {String} string representation of key
   */
  MusicXMLParser.prototype.getKeySignature = function (fifths) {
    var keys = {
      '-7': 'Cb',
      '-6': 'Gb',
      '-5': 'Db',
      '-4': 'Ab',
      '-3': 'Eb',
      '-2': 'Bb',
      '-1': 'F',
      0: 'C',
      1: 'G',
      2: 'D',
      3: 'A',
      4: 'E',
      5: 'B',
      6: 'F#',
      7: 'C#',
    }
    var key = keys[fifths]
    return key
  }

  MusicXMLParser.prototype.fetch = function (uri) {
    var req = new XMLHttpRequest()
    req.open('GET', uri, false)
    req.send(null)
    if (req.readyState != 4) return undefined
    return req.responseText
  }

  return MusicXMLParser
})
define('modules/converters/MusicXML/src/SongModel_MusicXML', [
  'require',
  'modules/core/src/SongModel',
  'modules/core/src/SectionModel',
  'modules/core/src/BarManager',
  'modules/core/src/BarModel',
  'modules/core/src/ChordManager',
  'modules/core/src/ChordModel',
  'modules/core/src/NoteManager',
  'modules/core/src/NoteModel',
  'modules/converters/MusicXML/utils/musicXMLParser',
  'modules/converters/MusicXML/src/BarModel_MusicXML',
  'modules/converters/MusicXML/src/ChordModel_MusicXML',
  'modules/converters/MusicXML/src/NoteModel_MusicXML',
], function (require) {
  var SongModel = require('modules/core/src/SongModel')
  var SectionModel = require('modules/core/src/SectionModel')
  var BarManager = require('modules/core/src/BarManager')
  var BarModel = require('modules/core/src/BarModel')
  var ChordManager = require('modules/core/src/ChordManager')
  var ChordModel = require('modules/core/src/ChordModel')
  var NoteManager = require('modules/core/src/NoteManager')
  var NoteModel = require('modules/core/src/NoteModel')

  var MusicXMLParser = require('modules/converters/MusicXML/utils/musicXMLParser')
  //var SectionModel_MusicXML = require('modules/converters/MusicXML/src/SectionModel_MusicXML');
  var BarModel_MusicXML = require('modules/converters/MusicXML/src/BarModel_MusicXML')
  var ChordModel_MusicXML = require('modules/converters/MusicXML/src/ChordModel_MusicXML')
  var NoteModel_MusicXML = require('modules/converters/MusicXML/src/NoteModel_MusicXML')

  var SongModel_MusicXML = {}

  SongModel_MusicXML.importFromMusicXML = function (docString, songModel) {
    if (typeof songModel === 'undefined' || !(songModel instanceof SongModel)) {
      songModel = new SongModel()
    } else {
      songModel.clear()
    }
    var chordManager = new ChordManager()
    var noteManager = new NoteManager()
    var barManager = new BarManager()

    var mxlParse = new MusicXMLParser()
    //var docString = '<?xml version="1.0" encoding="UTF-8" standalone="no"?><!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd"><score-partwise version="3.0"><part-list><score-part id="P1"><part-name>Music</part-name></score-part></part-list><part id="P1"><measure number="1"><attributes><divisions>1</divisions><key><fifths>0</fifths></key><time><beats>4</beats><beat-type>4</beat-type></time><clef><sign>G</sign><line>2</line></clef></attributes><note><pitch><step>C</step><octave>4</octave></pitch><duration>4</duration><type>whole</type></note></measure></part></score-partwise>';

    //docString = mxlParse.fetch(filepath);
    mxlParse.parse(docString)
    //console.log(mxlParse.measures);
    //console.log(mxlParse.attributes);

    if (typeof mxlParse !== 'undefined') {
      Array.prototype.forEach.call(mxlParse.documentElement.getElementsByTagName('credit'), function (node) {
        if (node.hasAttribute('page') && node.attributes['page'].value === '1') {
          var title = node.getElementsByTagName('credit-words')[0].textContent
          songModel.setTitle(title)
        }
      })
      if (typeof mxlParse.attributes !== 'undefined') {
        if (typeof mxlParse.attributes[0] !== 'undefined' && typeof mxlParse.attributes[0][0] !== 'undefined') {
          if (typeof mxlParse.attributes[0][0].key !== 'undefined') {
            songModel.setTonality(mxlParse.attributes[0][0].key)
          }
          if (typeof mxlParse.attributes[0][0].time !== 'undefined') {
            songModel.setTimeSignature(
              mxlParse.attributes[0][0].time.num_beats + '/' + mxlParse.attributes[0][0].time.beat_value
            )
          } else {
            songModel.setTimeSignature('4/4')
          }
        }
      }
      var section, measure, bar, chord, note, noteElems
      var chordBeat = [[1], [1, 3], [1, 3, 4], [1, 2, 3, 4]]
      for (var i = 0, c = mxlParse.partList.length; i < c; i++) {
        section = new SectionModel()
        /*console.log('---Section----');
				console.log(mxlParse);
				console.log(mxlParse.partList[i], mxlParse.staveConnectors[i]);*/
        //SectionModel_MusicXML.importFromMusicXML(mxlParse.partList[i], mxlParse.staveConnectors[i], section);
        if (typeof mxlParse.partName[i] !== 'undefined') {
          section.setName(mxlParse.partName[i])
        }
        songModel.addSection(section)
        section.setNumberOfBars(mxlParse.measures.length)
        for (var barNumber = 0, v = mxlParse.measures.length; barNumber < v; barNumber++) {
          measure = mxlParse.measures[barNumber][0]
          measure = mxlParse.getMeasure(barNumber)
          measure = measure.part[0]

          bar = BarModel_MusicXML.importFromMusicXML(measure.measureInfos)
          barManager.addBar(bar)
          if (typeof measure.chords !== 'undefined') {
            for (var k = 0, b = measure.chords.length; k < b; k++) {
              chord = ChordModel_MusicXML.importFromMusicXML(measure.chords[k])
              chord.setBarNumber(barNumber)
              chord.setBeat(chordBeat[b][k])
              chordManager.addChord(chord)
            }
          }

          if (typeof measure.notes !== 'undefined') {
            for (var k = 0, b = measure.notes.length; k < b; k++) {
              if (measure.notes[k].chord === false) {
                // case it's polyphonic (we keep same rhythm)
                note = NoteModel_MusicXML.importFromMusicXML(measure.notes[k])
                noteManager.addNote(note)
              } else {
                // case it's not monophonic
                // we reuse last note
                NoteModel_MusicXML.importFromMusicXML(measure.notes[k], note)
              }
            }
          }
        }
      }
      songModel.addComponent('bars', barManager)
      songModel.addComponent('chords', chordManager)
      songModel.addComponent('notes', noteManager)
    }
    return songModel
  }
  return SongModel_MusicXML
})
define('modules/converters/MusicXML/src/main', [
  'modules/converters/MusicXML/src/BarModel_MusicXML',
  'modules/converters/MusicXML/src/ChordModel_MusicXML',
  'modules/converters/MusicXML/src/NoteModel_MusicXML',
  'modules/converters/MusicXML/src/SongModel_MusicXML',
], function (BarModel_MusicXML, ChordModel_MusicXML, NoteModel_MusicXML, SongModel_MusicXML) {
  return {
    BarModel_MusicXML: BarModel_MusicXML,
    ChordModel_MusicXML: ChordModel_MusicXML,
    NoteModel_MusicXML: NoteModel_MusicXML,
    SongModel_MusicXML: SongModel_MusicXML,
  }
})
define('modules/core/src/SectionBarsIterator', [], function () {
  /**
   * Iterator that allow to go through sections
   * @exports core/SectionBarsIterator
   */
  function SectionBarsIterator(section) {
    this.section = section
    this.index = 0
  }
  SectionBarsIterator.prototype = {
    hasNext: function () {
      return this.index < this.section.getNumberOfBars()
    },
    getBarIndex: function () {
      return this.index
    },
    getSection: function () {
      return this.section
    },
    next: function () {
      this.index++
    },
    isLastBar: function () {
      return this.index == this.section.getNumberOfBars() - 1
    },
  }

  return SectionBarsIterator
})
define('modules/core/src/main', [
  'modules/core/src/SongModel',
  'modules/core/src/SectionModel',
  'modules/core/src/SectionBarsIterator',
  'modules/core/src/BarModel',
  'modules/core/src/BarManager',
  'modules/core/src/NoteManager',
  'modules/core/src/NoteModel',
  'modules/core/src/ChordManager',
  'modules/core/src/ChordModel',
  'modules/core/src/TimeSignatureModel',
  'modules/core/src/SongBarsIterator',
], function (
  SongModel,
  SectionModel,
  SectionBarsIterator,
  BarModel,
  BarManager,
  NoteManager,
  NoteModel,
  ChordManager,
  ChordModel,
  TimeSignatureModel,
  SongBarsIterator
) {
  return {
    SongModel: SongModel,
    SectionModel: SectionModel,
    SectionBarsIterator: SectionBarsIterator,
    BarModel: BarModel,
    BarManager: BarManager,
    NoteManager: NoteManager,
    NoteModel: NoteModel,
    ChordManager: ChordManager,
    ChordModel: ChordModel,
    TimeSignatureModel: TimeSignatureModel,
    SongBarsIterator: SongBarsIterator,
  }
})
define('modules/Cursor/src/CursorController', ['jquery', 'pubsub'], function ($, pubsub) {
  /**
   * Cursor manages all cursor edition function
   * @exports Cursor/CursorController
   */
  function CursorController(model, view) {
    this.model = model || new CursorModel()
    this.view = view
    this.initSubscribe()
  }

  /**
   * Subscribe to view events
   */
  CursorController.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('Cursor-' + this.view.id, function (el, fn, param) {
      if (self.model.getEditable()) {
        self[fn].call(self, param)
        $.publish('CanvasLayer-refresh')
      }
    })
  }

  /**
   * set cursor by index
   * @param {integer} index
   * @param {string} editMode "notes" or "chords"
   */
  CursorController.prototype.setCursor = function (index) {
    if (typeof index === 'undefined' || isNaN(index)) {
      throw 'CursorController - setCursor - index is not correct ' + index
    }
    this.model.setPos(index)
  }

  CursorController.prototype.expandSelected = function (inc) {
    if (typeof inc === 'undefined' || isNaN(inc)) {
      throw 'CursorController - expandSelected - inc is not correct ' + inc
    }
    this.model.expand(inc)
  }

  CursorController.prototype.moveCursor = function (inc) {
    this.setCursor(this.model.getEnd() + inc)
  }

  CursorController.prototype.setEditable = function (isEditable) {
    this.model.setEditable(isEditable)
  }

  return CursorController
})
define('modules/Cursor/src/CursorListener', ['jquery', 'pubsub'], function ($, pubsub) {
  /**
   * CursorListener creates link events from html to controller
   * @exports Cursor/CursorListener
   */
  function CursorListener(id, keyToNext) {
    if (!id) {
      throw 'CursorListener needs id'
    }
    this.id = id
    this.keyToNext = typeof keyToNext !== 'undefined' ? keyToNext : 'arrow' // way to go to previous next, 'arrow' or 'tab', by default it's arrow
    this.initSubscribe()
  }

  CursorListener.prototype.initSubscribe = function () {
    var fn
    var cursorId = 'Cursor-' + this.id
    var self = this
    if (self.keyToNext === 'tab') {
      $.subscribe('tab-key', function (el, inc) {
        //ChordsEdition is subscribed to this one, because we need SongModel
        $.publish('Cursor-moveCursorByElement-' + self.id, inc)
      })
    } else {
      //arrow
      $.subscribe('ctrl-leftright-arrows', function (el, inc) {
        //NoteEdition is subscribed to this one, because we need SongModel
        $.publish('Cursor-moveCursorByElement-' + self.id, inc)
      })
    }
    $.subscribe('shift-leftright-arrows', function (el, inc) {
      fn = 'expandSelected'
      $.publish(cursorId, [fn, inc])
    })
    $.subscribe('leftright-arrows', function (el, inc) {
      fn = 'moveCursor'
      $.publish(cursorId, [fn, inc])
    })
    $.subscribe('shift-begin', function (el, inc) {
      fn = 'expandSelected'
      $.publish(cursorId, [fn, -10000])
    })
    $.subscribe('begin', function (el, inc) {
      fn = 'setCursor'
      $.publish(cursorId, [fn, 0])
    })
    $.subscribe('shift-end', function (el, inc) {
      fn = 'expandSelected'
      $.publish(cursorId, [fn, 10000])
    })
    $.subscribe('end', function (el, inc) {
      fn = 'setCursor'
      $.publish(cursorId, [fn, 10000])
    })
  }

  return CursorListener
})
define('modules/Cursor/src/Cursor', [
  'modules/Cursor/src/CursorController',
  'modules/Cursor/src/CursorModel',
  'modules/Cursor/src/CursorListener',
], function (CursorController, CursorModel, CursorListener) {
  /**
   * Cursor constructor
   * @exports Cursor
   */
  function Cursor(listElement, id, keyType) {
    this.model = new CursorModel(listElement, id)
    var cV = new CursorListener(id, keyType)
    this.controller = new CursorController(this.model, cV)
  }
  return Cursor
})
define('modules/NoteEdition/src/NoteEditionController', [
  'mustache',
  'modules/core/src/SongModel',
  'modules/core/src/NoteManager',
  'modules/Cursor/src/CursorModel',
  'utils/NoteUtils',
  'utils/UserLog',
  'jquery',
  'pubsub',
], function (Mustache, SongModel, NoteManager, CursorModel, NoteUtils, UserLog, $, pubsub) {
  /**
   * NoteEditionController manages all notes edition function
   * @exports NoteEdition/NoteEditionController
   */
  function NoteEditionController(songModel, cursor, noteSpaceMng) {
    if (!songModel || !cursor) {
      throw 'NoteEditionController params are wrong'
    }
    this.songModel = songModel
    this.cursor = cursor
    this.noteSpaceMng = noteSpaceMng // in tests we don't pass noteSpaceMng, it will be undefined
    this.initSubscribe()
    this._lastCursorIndexHistory = -1 // we add an entry in history only when cursor is changed (it adds only one entry in histo)
  }

  /**
   * Subscribe to view events
   */
  NoteEditionController.prototype.initSubscribe = function () {
    var self = this

    function getHistoryName(fn) {
      var name
      switch (fn) {
        case 'setPitch':
          name = 'Change pitch'
          break
        case 'addAccidental':
          name = 'Change note accidental'
          break
        case 'setCurrDuration':
        case 'setDot':
        case 'setDoubleDot':
          name = 'Change note duration'
          break
        case 'setTie':
          name = 'Add tie'
          break
        case 'setTuplet':
          name = 'Add tuplets'
          break
        case 'setSilence':
          name = 'Change note'
          break
        case 'addNote':
          name = 'Add note'
          break
        case 'pasteNotes':
          name = 'Paste notes'
          break
      }
      return name
    }

    function addToHistory(fn) {
      var updateLastEntry = self._lastCursorIndexHistory === self.cursor.getPos()
      $.publish('ToHistory-add', [getHistoryName(fn), updateLastEntry])
      self._lastCursorIndexHistory = self.cursor.getPos()
    }

    // cursor view subscribe
    $.subscribe('Cursor-moveCursorByElement-notes', function (el, inc) {
      if (self.cursor.getEditable()) {
        self.moveCursorByBar(inc)
        $.publish('CanvasLayer-refresh')
      }
    })
    // All functions related with note edition go here
    $.subscribe('NoteEditionView', function (el, fn, param, shiftKey) {
      if (self.noteSpaceMng.isEnabled()) {
        self[fn].call(self, param, shiftKey)
        if (fn == 'addNote') {
          // we increment cursor if we added a note
          self.cursor.increment()
        }
        if (fn !== 'copyNotes') {
          //copyNotes is the only function that we don't save in history
          addToHistory(fn)
        }
        $.publish('ToLayers-removeLayer')
        $.publish('ToAudioPlayer-disable')
        $.publish('ToViewer-draw', self.songModel)
        // 向vue传输当前json
        $.publish('ToUpdateModel')
      }
    })
  }
  //Private functions
  /**
   * if a duration function is applied to a tuplet note, we expand cursor to include the other tuplet notes (to avoid strange durations
   */
  NoteEditionController.prototype._ifTupletExpandCursor = function () {
    var noteManager = this.songModel.getComponent('notes')
    var notes = noteManager.getNotes()
    var c = this.cursor.getStart()
    if (notes[c].isTuplet()) {
      c--
      while (c >= 0 && notes[c].isTuplet() && !notes[c].isTuplet('stop')) {
        this.cursor.setPos([c, this.cursor.getEnd()])
        c--
      }
    }
    c = this.cursor.getEnd()
    if (notes[c].isTuplet()) {
      c++
      while (c < notes.length && notes[c].isTuplet() && !notes[c].isTuplet('start')) {
        this.cursor.setPos([this.cursor.getStart(), c])
        c++
      }
    }
  }

  /**
   * Return a boolean that indicates is the whole tuplet is selected by the cursor from a note Index
   */
  NoteEditionController.prototype._isWholeTupletSelected = function (noteIndex) {
    if (isNaN(noteIndex)) {
      throw (
        'NoteEditionController - _isWholeTupletSelected - You should send a noteIndex to get a valid answer ' +
        noteIndex
      )
    }
    var notes = this.songModel.getComponent('notes').getNotes()
    var cursorStart = this.cursor.getStart()
    var cursorEnd = this.cursor.getEnd()
    if (noteIndex < cursorStart || cursorEnd < noteIndex) {
      return false
    }
    var cursorTmp = noteIndex
    if (!notes[cursorTmp].isTuplet('start')) {
      // If selected note is not the start, then we search for tuplet start backward in the cursor selection
      cursorTmp--
      while (cursorTmp > cursorStart && !notes[cursorStart].isTuplet('start')) {
        cursorTmp--
      }
      if (cursorTmp < cursorStart) {
        return false
      }
    }
    cursorTmp = noteIndex
    if (!notes[cursorTmp].isTuplet('stop')) {
      // If selected note is not the stop, then we search for tuplet stop forward in the cursor selection
      cursorTmp++
      while (cursorTmp <= cursorEnd && !notes[cursorTmp].isTuplet('stop')) {
        cursorTmp++
      }
      if (cursorEnd < cursorTmp) {
        return false
      }
    }
    return true
  }

  /**
   * for duration functions we will check always if change does not exceeds a bar duration
   * @param  {NoteManager} tmpNm
   * @return {Boolean}
   */
  NoteEditionController.prototype._fitsInBar = function (tmpNm) {
    var noteManager = this.songModel.getComponent('notes')
    var initIndex = this.cursor.getStart()
    var initBeat = noteManager.getNoteBeat(initIndex)
    var numBar = noteManager.getNoteBarNumber(initIndex, this.songModel)
    var barBeatDuration = this.songModel.getTimeSignatureAt(numBar).getQuarterBeats()
    var barRelativeBeat = initBeat - this.songModel.getStartBeatFromBarNumber(numBar)

    var notesNew = tmpNm.getNotes()
    var duration
    for (var i = 0; i < notesNew.length; i++) {
      duration = notesNew[i].getDuration()
      if (
        NoteUtils.roundBeat(barRelativeBeat) < barBeatDuration &&
        NoteUtils.roundBeat(barRelativeBeat + duration) > barBeatDuration
      ) {
        return false
      }
      barRelativeBeat += duration
    }
    return true
  }
  /**
   * used usuarlly by pitch functions
   * @return {Array} Array of NoteModel
   */
  NoteEditionController.prototype._getSelectedNotes = function () {
    var noteManager = this.songModel.getComponent('notes')
    var selectedNotes = noteManager.getNotes(this.cursor.getStart(), this.cursor.getEnd() + 1)
    return selectedNotes
  }

  /**
   * Function clones selectedNotes and inserts it in a new NoteManager
   * @return {NoteManager} return a cloned notemanager that contain as many notes as the cursor selection
   */
  NoteEditionController.prototype._cloneSelectedNotes = function () {
    /*we run it in a temporal NoteManager, and then we check if there are duration differences to fill with silences or not*/
    var nm = this.songModel.getComponent('notes')
    var selectedNotes = nm.cloneElems(this.cursor.getStart(), this.cursor.getEnd() + 1)
    var tmpNm = new NoteManager()
    tmpNm.setNotes(selectedNotes)
    return tmpNm
  }
  /**
   * checks if after doing the required operation the duration of the changes is longer than what was selected or not
   * if it is shorter it adds silences,
   * if it is longer but the duration finishes inside the duration of a note, it deletes the note and replaces the remaining time with silence too
   * @param  {NoteManager} noteMng   manager of the original notes
   * @param  {NoteManager} tmpNm     manager of the selected notes after being modified (e.g. if we are adding a dot to a quarter note, tmpNm will contain that note already dotted)
   * @param  {Integer} durBefore duration before the changes (.e.g 1 beats,  for a quarter note)
   * @param  {Integer} durAfter  duration after the chagnes (e.g. 1.5 beats, for a dotted quarter note)
   * @return {tmpNm}           returns tmpNm with added rests if necessary, ready for being pasted to original note manager
   */
  NoteEditionController.prototype._checkDuration = function (noteMng, tmpNm, durBefore, durAfter) {
    function checkIfBreaksTuplet(initBeat, endBeat, nm) {
      /**
       * means that is a 0.33333 or something like that
       * @return {Boolean}
       */
      function isTupletBeat(beat) {
        beat = beat * 16
        return Math.round(beat) != beat
      }
      var iPrevNote = nm.getNextIndexNoteByBeat(initBeat)
      var iNextNote = nm.getNextIndexNoteByBeat(endBeat)
      return (
        isTupletBeat(nm.getNoteBeat(iPrevNote)) ||
        (iNextNote < nm.getTotal() && isTupletBeat(nm.getNoteBeat(iNextNote)))
      )
    }

    var initBeat = noteMng.getNoteBeat(this.cursor.getStart())
    var endBeat = initBeat + durAfter
    var divisions

    if (durAfter < durBefore) {
      divisions = this.songModel.getBarDivisionsBetweenBeats(initBeat + durAfter, initBeat + durBefore)
      tmpNm.fillGapWithRests(divisions)
    } else if (durAfter > durBefore) {
      if (checkIfBreaksTuplet(initBeat, endBeat, noteMng)) {
        //TODO: return object
        var msg = "Can't break tuplet"
        UserLog.logAutoFade('error', msg)
        console.warn(msg)
        return
      }
      var endIndex = noteMng.getNextIndexNoteByBeat(endBeat)
      // after having copied notes sometimes there can be a gap to old duration, if so, we add silences
      // (e.g. last not copied is an 8th note that starts at the same point a half note started,
      //	so overwriting it, there are 1.5 beats missing to be filled by silences)

      var beatEndNote
      // when dealing with changes in last note we make sure index does not exceed total notes
      if (endIndex >= noteMng.getTotal()) {
        var indexLastNote = noteMng.getTotal() - 1
        var beatStartLastNote = noteMng.getNoteBeat(indexLastNote)
        var durLastNote = noteMng.getNotes()[indexLastNote].getDuration()
        beatEndNote = beatStartLastNote + durLastNote
      } else {
        beatEndNote = noteMng.getNoteBeat(endIndex)
      }

      if (endBeat < beatEndNote) {
        tmpNm.fillGapWithRests(beatEndNote - endBeat)
      }

      //important, to keep consistency in noteSpaceMng
      this.cursor.setPos([this.cursor.getStart(), endIndex - 1])
    }

    return tmpNm
  }
  /**
   * after duration funcion, we merge rests that concern changed area
   */
  NoteEditionController.prototype.mergeRests = function () {
    var noteMng = this.songModel.getComponent('notes')
    var restAreas = noteMng.findRestAreas(this.cursor.getPos())
    var area, beats, divisions, tmpNm

    if (restAreas) {
      for (var i = 0; i < restAreas.length; i++) {
        tmpNm = new NoteManager()
        area = restAreas[i]
        beats = noteMng.getBeatIntervalByIndexes(area[0], area[1])
        divisions = this.songModel.getBarDivisionsBetweenBeats(beats[0], beats[1])
        tmpNm.fillGapWithRests(divisions)
        area[1] - 1
        noteMng.notesSplice(area, tmpNm.getNotes())
      }
    }
  }

  /**
   * wrapper for all duration functions
   * @param  {Function} fn function to be called
   */
  NoteEditionController.prototype._runDurationFn = function (fn) {
    var noteMng = this.songModel.getComponent('notes')
    var tmpNm = this._cloneSelectedNotes()
    var onlyRestsBefore = tmpNm.onlyRests()
    var tmpCursorPos = this.cursor.getPos()
    //saving beat interval, to put again cursor later, regardless of changed notes
    var tmpBeatInterval = noteMng.getBeatIntervalByIndexes(tmpCursorPos[0], tmpCursorPos[1])
    var durBefore = tmpNm.getTotalDuration()

    //Here we run the actual function
    var res = fn(tmpNm)
    if (res && res.error) {
      UserLog.logAutoFade('error', res.error)
      return
    }

    var durAfter = tmpNm.getTotalDuration()
    //check if durations fit in the bar duration
    if (!this._fitsInBar(tmpNm)) {
      var msg = "Duration doesn't fit the bar"
      UserLog.logAutoFade('error', msg)
      console.warn(msg)
      return
    }

    tmpNm = this._checkDuration(noteMng, tmpNm, durBefore, durAfter, this.songModel)
    noteMng.notesSplice(this.cursor.getPos(), tmpNm.getNotes())
    noteMng.reviseNotes()

    //we merge only of we are not changing duration of rests
    if (!(onlyRestsBefore && tmpNm.onlyRests())) {
      this.mergeRests()
    }

    // tmpCursorPos = noteMng.getIndexesStartingBetweenBeatInterval(tmpBeatInterval[0], tmpBeatInterval[1], true);
    // if we wanted cursor comprise whole previously selected space we whould have use previous line,
    // otherwise, next line (cursor comprises first position)
    tmpCursorPos = noteMng.getPrevIndexNoteByBeat(tmpBeatInterval[0])
    this.cursor.setPos(tmpCursorPos)
  }

  //Public functions:
  //
  //Pitch functions
  /**
   * Set selected notes to a key
   * @param {int|letter} If decal is a int, than it will be a decal between current note and wanted note in semi tons, if decal is a letter then current note is the letter
   */
  NoteEditionController.prototype.setPitch = function (decalOrNote, chromatic) {
    var self = this,
      note,
      type = NoteUtils.getValidPitch(decalOrNote) !== -1 ? 'pitch' : 'decal'

    if (chromatic && type == 'decal') {
      setPitchChromatically()
    } else {
      setPitchNormally()
    }

    function setPitchChromatically() {
      var newKey
      var noteMng = self.songModel.getComponent('notes')
      var start = self.cursor.getStart(),
        end = self.cursor.getEnd() + 1
      var tmpNoteMng = noteMng.score2play(self.songModel, start, end)

      for (var i = 0; i < tmpNoteMng.getTotal(); i++) {
        note = tmpNoteMng.getNote(i)
        if (!note.isRest) {
          newKey = NoteUtils.getNextChromaticKey(note.getPitch(), decalOrNote)
          note.setNoteFromString(newKey)
        }
      }
      noteMng.notesSplice([start, end - 1], tmpNoteMng.getNotes())
      var tmpNoteMng = noteMng.play2score(self.songModel, start, end)
      noteMng.notesSplice([start, end - 1], tmpNoteMng.getNotes())
    }

    function setPitchNormally() {
      var newKey
      var selNotes = self._getSelectedNotes()
      var convertRestToNote = selNotes.length == 1
      for (var i = 0; i < selNotes.length; i++) {
        note = selNotes[i]
        if (note.isRest && convertRestToNote) {
          note.setRest(false)
        }
        if (type == 'pitch') {
          //find closest key
          newKey = NoteUtils.getClosestKey(note.getPitch(), decalOrNote)
          note.setNoteFromString(newKey)
        } else if (!note.isRest) {
          newKey = NoteUtils.getNextKey(note.getPitch(), decalOrNote) // decalOrNote is 1 or -1
          note.setNoteFromString(newKey)
        }
      }
    }
  }

  NoteEditionController.prototype.transposeBy = function (interval, direction) {
    var selNotes = this._getSelectedNotes()
  }

  NoteEditionController.prototype.addAccidental = function (accidental) {
    var selNotes = this._getSelectedNotes()
    var note
    if (typeof doubleAccidental !== 'undefined' && doubleAccidental === true && accidental !== 'n') {
      accidental += accidental
    }
    for (var i = 0; i < selNotes.length; i++) {
      note = selNotes[i]
      if (note.isRest) continue
      if (note.getAccidental() == accidental) {
        note.removeAccidental()
      } else {
        note.setAccidental(accidental)
      }
    }
  }

  //Duration functions
  /**
   * setCurrDuration("4")
   * @param {String} duration	represents the duration
   */
  NoteEditionController.prototype.setCurrDuration = function (duration) {
    this._ifTupletExpandCursor()
    this._runDurationFn(function (tmpNm) {
      var arrDurs = {
        1: '64',
        2: '32',
        3: '16',
        4: '8',
        5: 'q',
        6: 'h',
        7: 'w',
        8: 'w', //should be double whole but not supported yet
      }
      var notes = tmpNm.getNotes()
      var newDur = arrDurs[duration]
      if (typeof newDur === 'undefined') {
        throw 'NoteEditionController - setCurrDuration not accepted duration ' + duration
      }

      for (var i = 0; i < notes.length; i++) {
        notes[i].setDuration(newDur)
      }
    })
  }

  NoteEditionController.prototype.setDot = function () {
    this._runDurationFn(function (tmpNm) {
      var notes = tmpNm.getNotes()
      var numberOfDots = 0
      for (var i = 0, c = notes.length; i < c; i++) {
        numberOfDots = notes[i].getDot()
        if (numberOfDots === 1) {
          numberOfDots = 0
        } else {
          numberOfDots = 1
        }
        notes[i].setDot(numberOfDots)
      }
      return notes
    })
  }
  NoteEditionController.prototype.setDoubleDot = function () {
    this._runDurationFn(function (tmpNm) {
      var notes = tmpNm.getNotes()
      var numberOfDots = 0
      for (var i = 0, c = notes.length; i < c; i++) {
        numberOfDots = notes[i].getDot()
        if (numberOfDots === 2) {
          numberOfDots = 0
        } else {
          numberOfDots = 2
        }
        notes[i].setDot(numberOfDots)
      }
      return notes
    })
  }

  NoteEditionController.prototype.setTie = function () {
    var selNotes = this._getSelectedNotes()
    var note
    if (selNotes.length == 2) {
      for (var i = 0; i < selNotes.length; i++) {
        note = selNotes[i]
        if (i === 0) {
          if (note.isTie('start')) note.removeTie('start')
          else note.setTie('start')
        } else {
          if (note.isTie('stop')) note.removeTie('stop')
          else note.setTie('stop')
        }
      }
    }
  }

  NoteEditionController.prototype.setTuplet = function () {
    var self = this
    this._runDurationFn(function (tmpNm) {
      function validDur(notes) {
        //get total duration
        var dur = 0,
          i
        for (i = 0; i < notes.length; i++) {
          dur += notes[i].getDuration()
        }
        //check if valid
        var initDur = 4
        for (i = 0; i < 6; i++) {
          if (initDur == dur) return true
          initDur /= 2
        }
        return false
      }

      function createTupletFromNotes(arrNotes, timeModif) {
        var firstNote = arrNotes[0],
          tmpNote,
          newDuration = arrNotes.length == 1 ? firstNote.getDuration() / 2 : firstNote.getDuration()
        tupletsNote = []

        for (var i = 0; i < 3; i++) {
          tmpNote = firstNote.clone()
          tmpNote.setDurationByBeats(newDuration)

          if (i === 0) tmpNote.setTuplet('start', timeModif)
          else if (i === 1) tmpNote.setTuplet('middle', timeModif)
          else tmpNote.setTuplet('stop', timeModif)

          tupletsNote.push(tmpNote)
        }
        return tupletsNote
      }
      var selNotes = tmpNm.getNotes()
      var note
      var timeModif = '3/2'
      if (selNotes.length > 3) {
        return {
          error: 'You must select 3 notes or less',
        }
      }
      //check all notes have same dur
      for (var i = 0; i < selNotes.length - 1; i++) {
        if (selNotes[i].getDuration() != selNotes[i + 1].getDuration()) {
          return {
            error: 'Notes do not have the same duration',
          }
        }
      }
      if (selNotes.length < 3) {
        if (!validDur(selNotes)) {
          return {
            error: 'Select notes with a simple duration (not dotted or tuplet notes)',
          }
        }
      }
      if (selNotes.length == 1 || selNotes.length == 2) {
        var tupletsNote = createTupletFromNotes(selNotes, timeModif)
        tmpNm.setNotes(tupletsNote)
      } else if (selNotes.length == 3) {
        for (var i = 0; i < selNotes.length; i++) {
          note = selNotes[i]
          if (note.isTuplet()) {
            note.removeTuplet()
          } else {
            if (i === 0) note.setTuplet('start', timeModif)
            else if (i == selNotes.length - 1) note.setTuplet('stop', timeModif)
            else note.setTuplet('middle', timeModif)
          }
        }
      }
    })
  }

  NoteEditionController.prototype.setSilence = function () {
    //this._ifTupletExpandCursor();
    var self = this
    var deleteNoteTupletCount = 0
    var deleteNoteTupletToDo = 0
    var noteToDelete = []
    var tupletToDelete = []
    this._runDurationFn(function (tmpNm) {
      var selNotes = tmpNm.getNotes()
      var note
      for (var i = 0; i < selNotes.length; i++) {
        note = selNotes[i]
        if (note.isTie()) {
          note.removeTie()
        }
        if (self._isWholeTupletSelected(self.cursor.getStart() + i) && note.isTuplet()) {
          // get realIndex and not the cursor dependent index
          // in case it's a new tuplet
          if (note.isTuplet('start')) {
            // case we have a 3/2 tuplet, we do 3-2 = 1 so we need to remove 1 note
            deleteNoteTupletToDo = note.getTimeModification().split('/')[0] - note.getTimeModification().split('/')[1]
            deleteNoteTupletCount = 0
          }
          tupletToDelete.push(i)
          if (deleteNoteTupletCount < deleteNoteTupletToDo) {
            // delete the note we don't need
            noteToDelete.push(i)
            deleteNoteTupletCount++
          }
        }
        if (!note.isRest) note.setRest(true)
      }
      for (var j = 0; j < tupletToDelete.length; j++) {
        selNotes[tupletToDelete[j]].removeTuplet()
      }
      for (var k = 0; k < noteToDelete.length; k++) {
        tmpNm.deleteNote(noteToDelete[k])
      }
    })
    //self.cursor.setIndexPos(1, self.cursor.getEnd() - noteToDelete.length);
  }

  NoteEditionController.prototype.addNote = function () {
    var self = this
    this._runDurationFn(function (tmpNm) {
      var cloned = tmpNm.getNotes()[0].clone(false)
      tmpNm.addNote(cloned, 0)
    })
  }

  NoteEditionController.prototype.copyNotes = function () {
    this._ifTupletExpandCursor()
    var noteManager = this.songModel.getComponent('notes')
    this.buffer = noteManager.cloneElems(this.cursor.getStart(), this.cursor.getEnd() + 1)
  }

  NoteEditionController.prototype.pasteNotes = function () {
    var notesToPaste = this.buffer
    this._runDurationFn(function (tmpNm) {
      tmpNm.setNotes(notesToPaste)
    })
    if (this._lastCursorIndexHistory !== this.cursor.getPos()) {
      $.publish('ToHistory-add', 'Paste notes')
      this._lastCursorIndexHistory = this.cursor.getPos()
    } else {
      $.publish('ToHistory-updateLastEntry')
    }
  }

  /**
   * This is the only function not called by 'NoteEditionView' event, (see NoteEditionController.initSubscribe)
   * @param  {Integer} inc is a number that will be added to current barNumber, it can be negative, usually it's 1 or -1
   */
  NoteEditionController.prototype.moveCursorByBar = function (inc) {
    if (this.cursor.getEditable() === false) {
      return
    }
    var noteManager = this.songModel.getComponent('notes')
    var barNum = noteManager.getNoteBarNumber(this.cursor.getPos()[0], this.songModel)

    if (barNum === 0 && inc === -1) {
      this.cursor.setPos(0)
      $.publish('ToViewer-draw', this.songModel)
      return
    }

    var startBeat = this.songModel.getStartBeatFromBarNumber(barNum + inc)
    var indexFirstNoteInNewBar = noteManager.getNextIndexNoteByBeat(startBeat)

    this.cursor.setPos(indexFirstNoteInNewBar)
    $.publish('ToViewer-draw', this.songModel)
  }

  return NoteEditionController
})

define('text!modules/NoteEdition/src/NoteEditionTemplate.html', [], function () {
  return '<div id="edit_notes_second_level">\n\t<div id="edit_pitch_container">\n\t\t<div id="edit_each_pitch_container">\n\t\t\t<div class="current_button" title="Add 1 ton (+)" id="aug-note">+</div>\n\t\t\t<div class="current_button" title="Substract 1 ton (-)" id="sub-note">-</div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tPitch\n\t\t</div>\n\t</div>\n\t<div id="edit_alteration_container">\n\t\t<div id="edit_each_alteration_container">\n\t\t\t<div class="current_button" title="Double Flat (Shift+V)" id="double_flat"><img src="{{imgPath}}/double_flat.png" alt="double_flat" /></div>\n\t\t\t<div class="current_button" title="Flat (V)" id="flat">&#9837;</div>\n\t\t\t<div class="current_button" title="Natural (N)" id="natural">&#9838;</div>\n\t\t\t<div class="current_button" title="Sharp (S)" id="sharp">&#9839;</div>\n\t\t\t<div class="current_button" title="Double Sharp (Shitf+S)" id="double_sharp"><img src="{{imgPath}}/double_sharp.png" alt="double_sharp" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tAlteration\n\t\t</div>\n\t</div>\n\t<div id="edit_rhythm_container">\n\t\t<div id="edit_each_rhythm_container">\n\t\t\t<div class="current_button" id="sixty-four-note" title="Sixty-four note (1)"><img src="{{imgPath}}/sixty-four-note.png" alt="1/64" /></div>\n\t\t\t<div class="current_button" id="thirty-second-note" title="Thirty-second note (2)"><img src="{{imgPath}}/thirty-second-note.png" alt="1/32" /></div>\n\t\t\t<div class="current_button" id="sixteenth-note" title="Sixteenth note (3)"><img src="{{imgPath}}/sixteenth-note.png" alt="1/16" /></div>\n\t\t\t<div class="current_button" id="eight-note" title="Eight note (4)"><img src="{{imgPath}}/eight-note.png" alt="1/8" /></div>\n\t\t\t<div class="current_button" id="quarter-note" title="Quarter note (5)"><img src="{{imgPath}}/quarter-note.png" alt="1/4" /></div>\n\t\t\t<div class="current_button" id="half-note" title="Half note (6)"><img src="{{imgPath}}/half-note.png" alt="1/2" /></div>\n\t\t\t<div class="current_button" id="whole-note" title="Whole note (7)"><img src="{{imgPath}}/whole-note.png" alt="1" /></div>\n\t\t\t<div class="current_button" id="dot" title="dot (.)">.</div>\n\t\t\t<div class="current_button" id="double-dot" title="Double dot (:)">..</div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tRhythm\n\t\t</div>\n\t</div>\n\t<div id="edit_symbol_container">\n\t\t<div id="edit_each_symbol_container">\n\t\t\t<div class="current_button" id="tie-note" title="Tie note (T)"><img src="{{imgPath}}/tie-note.png" alt="tie" /></div>\n\t\t\t<div class="current_button" id="tuplet" title="Tuplet (Shift+T)"><img src="{{imgPath}}/tuplet.png" alt="tuplet" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tSymbol\n\t\t</div>\n\t</div>\n\t<div id="edit_note_container">\n\t\t<div id="edit_each_note_container">\n\t\t\t<div class="current_button" id="regular-note" title="Regular mode (D)"><img src="{{imgPath}}/quarter-note.png" alt="regular" /></div>\n\t\t\t<div class="current_button" id="silent-note" title="Silent mode (R)"><img src="{{imgPath}}/silent.png" alt="silent" /></div>\n\t\t\t<div class="current_button" id="delete-note" title="Remove note (Del)"><img src="{{imgPath}}/remove.png" alt="delete" /></div>\n\t\t\t<div class="current_button" id="add-note" title="Add note (Space)"><img src="{{imgPath}}/add.png" alt="add" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tNote\n\t\t</div>\n\t</div>\n\t<div id="selection_container">\n\t\t<div id="edit_each_selection_container">\n\t\t\t<div class="current_button" id="copy-note" title="Copy (Ctrl+C)"><img src="{{imgPath}}/copy.png" alt="copy" /></div>\n\t\t\t<div class="current_button" id="paste-note" title="Paste (Ctrl+V)"><img src="{{imgPath}}/paste.png" alt="paste" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tSelection\n\t\t</div>\n\t</div>\n</div>'
})

define('modules/NoteEdition/src/NoteEditionView', [
  'jquery',
  'mustache',
  'modules/core/src/SongModel',
  'utils/UserLog',
  'utils/NoteUtils',
  'pubsub',
  'text!modules/NoteEdition/src/NoteEditionTemplate.html',
], function ($, Mustache, SongModel, UserLog, NoteUtils, pubsub, NoteEditionTemplate) {
  /**
   * NoteEditionView creates notes edition template and link event from html to controller
   * @exports NoteEdition/NoteEditionView
   */
  function NoteEditionView(imgPath) {
    this.el = undefined
    this.imgPath = imgPath
    this.initKeyboard()
    this.render()
  }

  NoteEditionView.prototype.render = function (parentHTML, callback) {
    this.el = Mustache.render(NoteEditionTemplate, {
      imgPath: this.imgPath,
    })
  }

  /**
   * manages events that come from the keyboard
   */
  NoteEditionView.prototype.initKeyboard = function () {
    $.subscribe('updown-arrows', function (el, inc, evt) {
      fn = 'setPitch'
      $.publish('NoteEditionView', [fn, inc, evt.shiftKey])
    })
    $.subscribe('pitch-letter-key', function (el, key) {
      fn = 'setPitch'
      $.publish('NoteEditionView', [fn, key])
    })
    $.subscribe('accidental-key', function (el, acc) {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, acc])
    })
    $.subscribe('shift-accidental-key', function (el, acc) {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, acc + acc])
    })
    $.subscribe('number-key', function (el, key) {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, key])
    })
    $.subscribe('dot-key', function (el) {
      fn = 'setDot'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('colon-key', function (el) {
      fn = 'setDoubleDot'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('shift-t-key', function (el) {
      fn = 'setTuplet'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('t-key', function (el) {
      fn = 'setTie'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('R-key', function (el) {
      fn = 'setSilence'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('supr-key', function (el) {
      fn = 'setSilence'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('enter-key', function (el) {
      fn = 'addNote'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('ctrl-c-key', function (el) {
      fn = 'copyNotes'
      $.publish('NoteEditionView', fn)
    })
    $.subscribe('ctrl-v-key', function (el) {
      fn = 'pasteNotes'
      $.publish('NoteEditionView', fn)
    })
  }
  /**
   * Manages events clicked from the menu
   * this function is called by MainMenuView
   *
   */
  NoteEditionView.prototype.initController = function () {
    // pitch
    var fn
    $('#aug-note').click(function () {
      fn = 'setPitch'
      $.publish('NoteEditionView', [fn, 1])
    })
    $('#sub-note').click(function () {
      fn = 'setPitch'
      $.publish('NoteEditionView', [fn, -1])
    })

    // Alteration
    $('#double_flat').click(function () {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, 'bb'])
    })
    $('#flat').click(function () {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, 'b'])
    })
    $('#natural').click(function () {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, 'n'])
    })
    $('#sharp').click(function () {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, '#'])
    })
    $('#double_sharp').click(function () {
      fn = 'addAccidental'
      $.publish('NoteEditionView', [fn, '##'])
    })
    // Rhythm
    $('#whole-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 7])
    })
    $('#half-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 6])
    })
    $('#quarter-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 5])
    })
    $('#eight-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 4])
    })
    $('#sixteenth-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 3])
    })
    $('#thirty-second-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 2])
    })
    $('#sixty-four-note').click(function () {
      fn = 'setCurrDuration'
      $.publish('NoteEditionView', [fn, 1])
    })
    $('#dot').click(function () {
      fn = 'setDot'
      $.publish('NoteEditionView', fn)
    })
    $('#double-dot').click(function () {
      fn = 'setDoubleDot'
      $.publish('NoteEditionView', fn)
    })

    // Symbol
    $('#tie-note').click(function () {
      fn = 'setTie'
      $.publish('NoteEditionView', fn)
    })
    $('#tuplet').click(function () {
      fn = 'setTuplet'
      $.publish('NoteEditionView', fn)
    })

    // Note
    $('#silent-note').click(function () {
      fn = 'setSilence'
      $.publish('NoteEditionView', fn)
    })
    $('#regular-note').click(function () {
      fn = 'setPitch'
      $.publish('NoteEditionView', [fn, 0])
    })
    $('#delete-note').click(function () {
      // in our editor we want to replace note by silence and not delete note
      fn = 'setSilence'
      $.publish('NoteEditionView', fn)
    })
    $('#add-note').click(function () {
      fn = 'addNote'
      $.publish('NoteEditionView', fn)
    })

    // Selection
    $('#copy-note').click(function () {
      fn = 'copyNotes'
      $.publish('NoteEditionView', fn)
    })
    $('#paste-note').click(function () {
      fn = 'pasteNotes'
      $.publish('NoteEditionView', fn)
    })
  }
  return NoteEditionView
})
define('modules/NoteEdition/src/NoteSpaceManager', [
  'modules/Cursor/src/CursorModel',
  'utils/UserLog',
  'modules/Edition/src/ElementManager',
  'jquery',
  'pubsub',
], function (CursorModel, UserLog, ElementManager, $, pubsub) {
  /**
   * NoteSpaceManager creates and manages an array of notes represented by their positions
   * @exports NoteEdition/NoteSpaceManager
   *
   * @param {CursorModel} cursor
   * @param {LSViewer} viewer
   * @param {String} name        name as CanvasLayer listener
   * @param {String} color       RGB color. e. g.: "#FF0000"
   * @param {Boolean} interactive if true, can be selected (e.g. cursor to edit notes will be interactive, player cursor will not)
   * @param {Boolean} enabled     if true, it will be initially enabled (e.g. notes editing cursor), on the other hand, player cursor will be enabled on 'play'
   */
  function NoteSpaceManager(cursor, viewer, name, color, interactive, enabled) {
    if (!cursor) {
      throw 'NoteSpaceManager - missing cursor'
    }
    if (!viewer) {
      throw 'NoteSpaceManager - missing viewer'
    }
    this.interactive = interactive === undefined ? true : interactive
    this.CL_TYPE = this.interactive ? 'CURSOR' : 'NOT_INTERACTIVE' //TODO: create maybe subclass (or abstract NoteSpaceManager)
    this.CL_NAME = name || 'NotesCursor'
    this.cursor = cursor
    this.viewer = viewer
    this.elemMng = new ElementManager()
    this.noteSpace = []
    this.initSubscribe()
    this.enabled = enabled === undefined ? true : enabled
    this.COLOR = color || '#0099FF'
  }

  /**
   * Subscribe to view events
   */
  NoteSpaceManager.prototype.initSubscribe = function () {
    var self = this

    $.subscribe('LSViewer-drawEnd', function (el, viewer) {
      if (!self.viewer.canvasLayer) {
        throw 'NoteSpaceManager needs CanvasLayer'
      }

      self.noteSpace = self.createNoteSpace(self.viewer)
      self.cursor.setListElements(self.noteSpace.length)
      self.viewer.canvasLayer.addElement(self)
      self.viewer.canvasLayer.refresh()
    })
    if (self.CL_TYPE === 'NOT_INTERACTIVE') {
      $.subscribe('ToNoteSpaceManager-enable', function () {
        self.enable()
      })
      $.subscribe('ToPlayer-play', function () {
        self.playing = true
      })
      $.subscribe('ToPlayer-stop', function () {
        self.playing = false
      })
      $.subscribe('ToPlayer-pause', function () {
        self.playing = false
      })
    }
    $.subscribe('ctrl-a', function () {
      if (!self.interactive) return
      self.enable()
      self.cursor.selectAll()
      self.viewer.canvasLayer.refresh()
    })
  }

  NoteSpaceManager.prototype.createNoteSpace = function (viewer) {
    var noteSpace = []
    if (viewer.vxfBars === undefined) {
      return
    }
    noteSpace = viewer.noteViews
    return noteSpace
  }

  NoteSpaceManager.prototype.getType = function () {
    return this.CL_TYPE
  }

  /**
   * @interface
   * @param  {Object} coords
   * @return {Object} e.g: {topY:44, bottomY: 23}
   */
  NoteSpaceManager.prototype.getYs = function (coords) {
    return this.elemMng.getYs(this.noteSpace, coords)
  }

  /**
   * @interface
   * @param  {Object} coords
   * @param  {Integer} ini
   * @param  {Integer} end
   * @param  {Boolean} clicked
   * @param  {Boolean} mouseUp
   * @param  {Boolean} ctrlPressed
   */
  NoteSpaceManager.prototype.onSelected = function (coords, ini, end, clicked, mouseUp, ctrlPressed) {
    if (!this.interactive) return
    var posCursor
    var coordsTop, coordsBottom

    posCursor = this.elemMng.getElemsInPath(this.noteSpace, coords, ini, end, this.getYs(coords))
    if (ctrlPressed) {
      posCursor = this.elemMng.getMergedCursors(posCursor, this.cursor.getPos())
    }
    if (posCursor) {
      this.cursor.setPos(posCursor)
      //when clicking on a note, if there is an audio player, cursor should be updated
      $.publish('ToWave-setCursor', this.cursor.getPos()) // getPos() returns array, of two elements, each element will be one parameter
    }
  }

  /**
   * @interface
   * @param  {Object} coords {x: xval, y: yval}}
   * @return {Boolean}
   */
  NoteSpaceManager.prototype.inPath = function (coords) {
    return !!this.elemMng.getElemsInPath(this.noteSpace, coords)
  }

  /**
   * @interface
   * @param  {CanvasContext} ctx
   */
  NoteSpaceManager.prototype.drawCursor = function (ctx) {
    if (this.noteSpace.length === 0) return
    var position = this.cursor.getPos(),
      saveFillColor = ctx.fillStyle,
      areas = []

    ctx.fillStyle = this.COLOR
    ctx.globalAlpha = 0.2

    if (position[0] !== null) {
      areas = this.elemMng.getElementsAreaFromCursor(this.noteSpace, position)
      for (i = 0; i < areas.length; i++) {
        ctx.fillRect(areas[i].x, areas[i].y, areas[i].w, areas[i].h)
      }
      ctx.fillStyle = saveFillColor
      ctx.globalAlpha = 1
    }
  }

  /**
   * @interface
   */
  NoteSpaceManager.prototype.isEnabled = function () {
    return this.enabled
  }

  /**
   * @interface
   */
  NoteSpaceManager.prototype.enable = function () {
    this.enabled = true
  }

  /**
   * @interface
   */
  NoteSpaceManager.prototype.disable = function () {
    if (!this.playing) {
      //if 'NOT_INTERACTIVE' depends if playing
      this.enabled = false
    }
  }
  /**
   * @interface
   */
  NoteSpaceManager.prototype.setCursorEditable = function (bool) {
    this.cursor.setEditable(bool)
  }

  return NoteSpaceManager
})
define('modules/NoteEdition/src/NoteEdition', [
  'modules/NoteEdition/src/NoteEditionController',
  'modules/NoteEdition/src/NoteEditionView',
  'modules/NoteEdition/src/NoteSpaceManager',
], function (NoteEditionController, NoteEditionView, NoteSpaceManager) {
  /**
   * NoteEdition constructor
   * @exports NoteEdition
   */
  function NoteEdition(songModel, cursorModel, viewer, imgPath, snglNotesManager) {
    this.noteSpaceMng = snglNotesManager.getInstance(songModel, viewer)
    new NoteEditionController(songModel, cursorModel, this.noteSpaceMng)
    this.view = new NoteEditionView(imgPath)
  }
  return NoteEdition
})
define('modules/MidiCSL/src/model/NoteModel_midiCSL', [], function () {
  /**
   * NoteModel_MidiCSL represent a note that is ready to be readed by midi player
   * @exports MidiCSL/NoteModel_MidiCSL
   */
  function NoteModel_MidiCSL(option) {
    this.currentTime =
      typeof option !== 'undefined' && typeof option.currentTime !== 'undefined' ? option.currentTime : 0.0 // currentTime in beat
    this.duration = typeof option !== 'undefined' && typeof option.duration !== 'undefined' ? option.duration : 0.0 // duration in beat
    this.type = typeof option !== 'undefined' && typeof option.type !== 'undefined' ? option.type : undefined // type is melody or chord
    this.midiNote = typeof option !== 'undefined' && typeof option.midiNote !== 'undefined' ? option.midiNote : []
    this.noteIndex =
      typeof option !== 'undefined' && typeof option.noteIndex !== 'undefined' ? option.noteIndex : undefined
  }

  NoteModel_MidiCSL.prototype.getCurrentTime = function () {
    return this.currentTime
  }

  NoteModel_MidiCSL.prototype.setCurrentTime = function (currentTime) {
    if (typeof currentTime === 'undefined' || isNaN(currentTime) || currentTime < 0) {
      throw 'NoteModel_MidiCSL - setCurrentTime - currentTime must be a positive float ' + currentTime
    }
    this.currentTime = currentTime
  }

  NoteModel_MidiCSL.prototype.getDuration = function () {
    return this.duration
  }

  NoteModel_MidiCSL.prototype.setDuration = function (duration) {
    if (typeof duration === 'undefined' || isNaN(duration) || duration < 0) {
      throw 'NoteModel_MidiCSL - setCurrentTime - duration must be a positive float ' + duration
    }
    this.duration = duration
  }

  NoteModel_MidiCSL.prototype.getType = function () {
    return this.type
  }

  NoteModel_MidiCSL.prototype.setType = function (type) {
    if (typeof type === 'undefined') {
      throw 'NoteModel_MidiCSL - setType - type is undefined ' + type
    }
    this.type = type
  }

  NoteModel_MidiCSL.prototype.getMidiNote = function () {
    return this.midiNote
  }

  NoteModel_MidiCSL.prototype.setMidiNote = function (midiNote) {
    if (typeof midiNote === 'undefined') {
      throw 'NoteModel_MidiCSL - setType - midiNote is undefined ' + midiNote
    }
    this.midiNote = midiNote
  }

  NoteModel_MidiCSL.prototype.getNoteIndex = function () {
    return this.noteIndex
  }

  NoteModel_MidiCSL.prototype.getTransposeMidiNote = function (semi_tons) {
    var midiNote = []
    var computedMidiNote
    if (this.midiNote !== 'undefined') {
      for (var i = 0, c = this.midiNote.length; i < c; i++) {
        computedMidiNote = this.midiNote[i] + semi_tons
        if (computedMidiNote >= 21 && computedMidiNote <= 108) {
          midiNote[i] = computedMidiNote
        }
      }
    }
    return midiNote
  }

  NoteModel_MidiCSL.prototype.serialize = function () {
    //return JSON.stringify(this.currentTime + this.duration + this.type + this.midiNote);
    var noteModel_midiCSL = {}
    noteModel_midiCSL.currentTime = this.currentTime
    noteModel_midiCSL.duration = this.duration
    noteModel_midiCSL.type = this.type
    noteModel_midiCSL.midiNote = this.midiNote
    return noteModel_midiCSL
  }

  NoteModel_MidiCSL.prototype.clone = function () {
    return new NoteModel_MidiCSL(this.serialize())
  }

  return NoteModel_MidiCSL
})
define('modules/MidiCSL/utils/MidiHelper', [], function () {
  var MidiHelper = {} // Namespaces

  MidiHelper.convertNotesToMidi = function (allNotes) {
    var allMidiNotes = []
    if (typeof allNotes !== 'undefined') {
      var currentNote
      for (var i = 0, c = allNotes.length; i < c; i++) {
        currentNote = allNotes[i]
        currentNote = MidiHelper.convertSharp2Flat(currentNote)
        currentNote = MidiHelper.detectImpossibleFlat(currentNote)
        currentNote = MidiHelper.convertDoubleAccidental(currentNote)
        allMidiNotes[i] = MidiHelper.keyToNote[currentNote]
        /*		if(!MIDI.keyToNote[ currentNote ]){
				console.log(this.allNotes[ i ], currentNote);
			}*/
      }
    }
    return allMidiNotes
  }

  /*
   * This function convert double accident sharp or flat
   * @argument noteKey is a String Containing [note + (sharp/flat) + (sharp/flat) + scaleNumber] , e.g C##4
   * return a string noteKey containing for e.g. D4
   */
  MidiHelper.convertDoubleAccidental = function (noteKey) {
    if (typeof noteKey === 'undefined') {
      return
    }
    if (noteKey[1] === '#' && noteKey[2] === '#') {
      if (noteKey[0] === 'G') {
        noteKey = 'A' + noteKey.substring(3)
      } else if (noteKey[0] === 'B') {
        noteKey = 'C' + (parseInt(noteKey[3]) + 1) // Change to upper scale
      } else {
        noteKey = String.fromCharCode(noteKey.charCodeAt(0) + 1) + noteKey.substring(3)
      }
    } else if (noteKey[1] === 'b' && noteKey[2] === 'b') {
      if (noteKey[0] === 'A') {
        noteKey = 'G' + noteKey.substring(3)
      } else if (noteKey[0] === 'C') {
        noteKey = 'B' + (parseInt(noteKey[3]) - 1) // Change to upper scale
      } else {
        noteKey = String.fromCharCode(noteKey.charCodeAt(0) - 1) + noteKey.substring(3)
      }
    }
    return noteKey
  }

  /*
   * This function transform sharp to flat for soundfont use
   * @argument noteKey is a String Containing [note + (sharp) + scaleNumber] , e.g C#4
   * return a string noteKey containing for e.g. Db4
   */
  MidiHelper.convertSharp2Flat = function (noteKey) {
    if (typeof noteKey === 'undefined') {
      return
    }
    if (noteKey[1] === '#') {
      if (noteKey[0] === 'G') {
        noteKey = 'Ab' + noteKey.substring(2)
      } else if (noteKey[0] === 'B') {
        noteKey = 'C' + (parseInt(noteKey[2]) + 1) // Change to upper scale
      } else if (noteKey[0] === 'E') {
        noteKey = 'F' + noteKey.substring(2)
      } else {
        noteKey = String.fromCharCode(noteKey.charCodeAt(0) + 1) + 'b' + noteKey.substring(2)
      }
    }
    return noteKey
  }

  /*
   * This function detects non obvious flat (Cb and Fb) and transform them to note
   * @argument noteKey is a String Containing [note + (sharp) + scaleNumber] , e.g Cb4
   * returns a string noteKey containing for e.g. B4
   */
  MidiHelper.detectImpossibleFlat = function (noteKey) {
    if (typeof noteKey === 'undefined') {
      return
    }
    if (noteKey[1] === 'b') {
      if (noteKey[0] === 'C') {
        noteKey = 'B' + (parseInt(noteKey[2]) - 1) // Change to lower scale
      } else if (noteKey[0] === 'F') {
        noteKey = 'E' + noteKey.substring(2)
      }
    }
    return noteKey
  }

  /*
   * This function transpose midi notes array, the number of transposition is midiDecal
   * @argument midiNotes array of int that contain series of midiNotes
   * @argument midiDecal desired transposition decal (put -x to go lower, +x for higher note)
   * return the transposed midinotes array
   */
  MidiHelper.transposeMidiNotes = function (midiNotes, midiDecal) {
    if (typeof midiNotes !== 'undefined' && !isNaN(midiDecal)) {
      for (var i = 0, c = midiNotes.length; i < c; i++) {
        midiNotes[i] += midiDecal
      }
      return midiNotes
    }
    return undefined
  }

  MidiHelper.getKeyToNote = function (noteKey) {
    noteKey = MidiHelper.convertDoubleAccidental(noteKey)
    noteKey = MidiHelper.convertSharp2Flat(noteKey)
    noteKey = MidiHelper.detectImpossibleFlat(noteKey)
    return this.keyToNote[noteKey]
  }

  //code taken from MidiJS lib
  // note conversions
  MidiHelper.keyToNote = {} // C8  == 108
  MidiHelper.noteToKey = {} // 108 ==  C8
  ;(function () {
    var A0 = 0x15 // first note
    var C8 = 0x6c // last note
    var number2key = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B']
    for (var n = A0; n <= C8; n++) {
      var octave = ((n - 12) / 12) >> 0
      var name = number2key[n % 12] + octave
      MidiHelper.keyToNote[name] = n
      MidiHelper.noteToKey[n] = name
    }
  })()

  return MidiHelper
})
define('modules/MidiCSL/src/converters/ChordConverterMidi_MidiCSL', [
  'modules/core/src/SongModel',
  'modules/core/src/ChordManager',
  'modules/core/src/ChordModel',
  'modules/MidiCSL/src/model/NoteModel_midiCSL',
  'utils/NoteUtils',
  'utils/ChordUtils',
  'modules/MidiCSL/utils/MidiHelper',
], function (SongModel, ChordManager, ChordModel, NoteModel_midiCSL, NoteUtils, ChordUtils, MidiHelper) {
  /**
   * ChordConverterMidi_MidiCSL convert chords to a list of note that can be read by midi player
   * Object is created by ChordManagerConverterMidi_MidiCSL while song is converted
   * @exports MidiCSL/ChordConverterMidi_MidiCSL
   */
  var ChordConverterMidi_MidiCSL = {}

  ChordConverterMidi_MidiCSL.exportToMidiCSL = function (chordModel, callback) {
    if (!chordModel instanceof ChordModel) {
      throw 'ChordConverterMidi_MidiCSL - exportToMidiCSL - chordModel parameters must be an instanceof SongModel'
    }
    var midiNotes = ChordConverterMidi_MidiCSL.getAllMidiNotes(chordModel)
    return midiNotes
  }

  ChordConverterMidi_MidiCSL.getAllMidiNotes = function (chordModel, callback) {
    // case notes and midinotes are unknown
    var chordTypesNotes = ChordConverterMidi_MidiCSL.getChordTypesNotes(chordModel)
    if (typeof chordTypesNotes !== 'undefined') {
      // playing bass chord
      if (chordModel.isEmptyBase() === false) {
        var note = chordModel.getBase().getNote()
        var decalBase = NoteUtils.pitch2Number(note)
        var noteDecalBase = NoteUtils.number2Pitch(decalBase - decal)
        chordTypesNotes.unshift(noteDecalBase + '3')
      }
      // case chordTypeNotes in C are known
      var midiNotes = MidiHelper.convertNotesToMidi(chordTypesNotes)
      var decal = NoteUtils.pitch2Number(chordModel.getNote())
      var allMidiNotes = MidiHelper.transposeMidiNotes(midiNotes, decal)
      return allMidiNotes
    }
  }

  ChordConverterMidi_MidiCSL.getChordTypesNotes = function (chordModel) {
    var note = chordModel.getNote()
    if (note === 'NC') {
      chordModel.allMidiNotes = []
      if (typeof callback !== 'undefined') {
        callback([])
      }
      return
    }
    var chordType = chordModel.unformatChordType(chordModel.getChordType())
    var chordTypeToNote = ChordUtils.getAllChordTypes()
    /**
     * We first try to know if chordModel chord is already known
     */
    if (typeof chordTypeToNote !== 'undefined' && typeof chordTypeToNote[chordType] !== 'undefined') {
      var chordNotes = chordTypeToNote[chordType]
      return chordNotes
    }
    console.warn('ChordConverterMidi_MidiCSL: Unknown chord ' + chordModel.toString())
    return []
  }

  ChordConverterMidi_MidiCSL.convertNotesToMidi = function (chordModel) {
    chordModel.allMidiNotes = MidiHelper.convertNotesToMidi(chordModel.allNotes)
    return chordModel.allMidiNotes
  }
  return ChordConverterMidi_MidiCSL
})
define('modules/MidiCSL/src/converters/ChordManagerConverterMidi_MidiCSL', [
  'modules/core/src/SongModel',
  'modules/core/src/ChordManager',
  'modules/core/src/SongBarsIterator',
  'modules/MidiCSL/src/converters/ChordConverterMidi_MidiCSL',
  'modules/MidiCSL/src/model/NoteModel_midiCSL',
], function (SongModel, ChordManager, SongBarsIterator, ChordConverterMidi_MidiCSL, NoteModel_midiCSL) {
  /**
   * ChordManagerConverterMidi_MidiCSL convert chords to a list of note that can be read by midi player
   * It creates ChordConverterMidi_MidiCSL to retrieve midi informations about every chords
   *
   * Object is created by SongConverterMidi_MidiCSL
   * @exports MidiCSL/ChordManagerConverterMidi_MidiCSL
   */
  var ChordManagerConverterMidi_MidiCSL = {}

  /**
   * gets MidiCSL notes for a SongModel. Concretely it works this way:
   * for each bar takes the chords and translates it to Midi, so that notes are played at the precise time
   * if a bar has no chord:
   *  	- if there is no previous chord, it does nothing
   *  	- if there is a previous chord, it repeats that previous chord
   *
   */
  ChordManagerConverterMidi_MidiCSL.exportToMidiCSL = function (songModel) {
    function getChordAsMidi(time, duration, midiNotes) {
      return new NoteModel_midiCSL({
        currentTime: time,
        duration: duration,
        midiNote: midiNotes,
        type: 'chord',
      })
    }

    if (!songModel instanceof SongModel) {
      throw 'ChordManagerConverterMidi_MidiCSL - exportToMidiCSL - songModel parameters must be an instanceof SongModel'
    }

    var chords = []
    if (songModel.getComponent('chords') === 'undefined') {
      return undefined
    }
    var chordManager = songModel.getComponent('chords'),
      songIt = new SongBarsIterator(songModel),
      currentTime = 0,
      duration = 0.0,
      midiNotes = [],
      barDuration,
      chordsInBar = []

    while (songIt.hasNext()) {
      chordsInBar = chordManager.getChordsByBarNumber(songIt.getBarIndex())
      barDuration = songIt.getBarTimeSignature().getQuarterBeats()
      if (chordsInBar.length === 0) {
        // case there is no chord in bar, we repeat previous one, if there is no previous one we just continue to next bar
        if (!midiNotes || midiNotes.length != 0) {
          //first condition will be true when there are no chords in current bar and previous bar had NC, second condition will be true on bars with one NC
          duration = songIt.getBarTimeSignature().getQuarterBeats()
          chords.push(getChordAsMidi(currentTime, duration, midiNotes))
        }
      } else {
        var nextBeatTime,
          chordCurrentTime,
          barUnitQuarterBeat = songIt.getBarTimeSignature().getBeatUnitQuarter()

        for (var i = 0; i < chordsInBar.length; i++) {
          chordCurrentTime = currentTime + (chordsInBar[i].getBeat() - 1) * barUnitQuarterBeat
          nextBeatTime =
            i < chordsInBar.length - 1 ? (chordsInBar[i + 1].getBeat() - 1) * barUnitQuarterBeat : barDuration
          duration = currentTime + nextBeatTime - chordCurrentTime
          midiNotes = ChordConverterMidi_MidiCSL.exportToMidiCSL(chordsInBar[i])
          chords.push(getChordAsMidi(chordCurrentTime, duration, midiNotes))
        }
      }
      currentTime += barDuration
      songIt.next()
    }
    return chords
  }

  return ChordManagerConverterMidi_MidiCSL
})
define('utils/AjaxUtils', ['jquery'], function ($) {
  var AjaxUtils = {}

  /**
   * Use this function whenever you need to do an ajax request, ajax request allow you to ask a server language from javascript executed by client
   * @param  {Object}   request                 Request object contain url, type, data, dataType, withCredentialsBool
   * @param  {text}   url                   Distant url you want to reach, it can be relative or absolute
   * @param  {text}   type                  Server Request (GET, POST ...)
   * @param  {Object}   data                Contain a JS object that you want to send to the server
   * @param  {bool}   withCredentialsBool   Allow outrepassing CORS restriction, see jQuery documentation
   * @param  {Function} callback            Function call when the request is complete, always launch whenever there is an error or not
   */
  AjaxUtils.request = function (request, callback) {
    if (typeof request === 'undefined') {
      throw 'AjaxUtils - ajaxRequest - request argument is undefined ' + request
    }
    if (typeof request.url === 'undefined') {
      throw 'AjaxUtils - ajaxRequest - url argument is undefined ' + url
    }
    if (typeof request.type === 'undefined') {
      request.type = 'GET'
    }
    if (typeof request.data === 'undefined') {
      request.data = {}
    }
    if (typeof request.dataType === 'undefined') {
      request.dataType = 'jsonp'
    }
    if (typeof request.withCredentialsBool === 'undefined') {
      request.withCredentialsBool = false
    }
    $.ajax({
      url: request.url,
      dataType: request.dataType,
      type: request.type,
      data: request.data,
      xhrFields: {
        withCredentials: request.withCredentialsBool,
      },
      success: function (data) {
        if (typeof callback !== 'undefined') {
          callback(data)
        }
      },
      error: function (query, errorType, error) {
        console.warn('AjaxUtils - Ajax Request fail ' + errorType + ' : ' + error.message)
        if (typeof callback !== 'undefined') {
          callback(error)
        }
      },
    })
  }

  /**
   * Direct link to the servlet ajax request with predefined ajax options
   * @param  {string}   servletRoot Servlet context root, eg. 'rechord', 'jsonsong', 'flow'
   * @param  {string}   servletName Servlet name eg. 'composer', 'harmonize', 'radiofeed'
   * @param  {Object}   data        Contain a JS object that you want to send to the server
   * @param  {Function} callback    Function call when the request is complete, always launch whenever there is an error or not
   */
  AjaxUtils.servletRequest = function (servletRoot, servletName, data, callback) {
    if (typeof servletRoot === 'undefined') {
      throw 'AjaxUtils - servletRequest - servletRoot argument is undefined ' + servletRoot
    }
    if (typeof servletName === 'undefined') {
      throw 'AjaxUtils - servletRequest - servletName argument is undefined ' + servletName
    }
    var request = {
      url: 'http://apijava.flow-machines.com:8080/' + servletRoot + '/' + servletName,
      type: 'POST',
      data: data,
      dataType: 'json',
      withCredentialsBool: true,
    }
    AjaxUtils.request(request, callback)
  }

  return AjaxUtils
})
define('modules/MidiCSL/src/converters/SongConverterMidi_MidiCSL', [
  'modules/core/src/SongModel',
  'modules/MidiCSL/src/model/NoteModel_midiCSL',
  'modules/MidiCSL/src/converters/ChordManagerConverterMidi_MidiCSL',
  'modules/MidiCSL/utils/MidiHelper',
  'modules/core/src/NotesIterator',
  'modules/core/src/SongBarsIterator',
  'modules/converters/MusicCSLJson/src/SongModel_CSLJson',
  'utils/AjaxUtils',
], function (
  SongModel,
  NoteModel_midiCSL,
  ChordManagerConverterMidi_MidiCSL,
  MidiHelper,
  NotesIterator,
  SongBarsIterator,
  SongModel_CSLJson,
  AjaxUtils
) {
  var SongConverterMidi_MidiCSL = {}
  /**
   * SongConverterMidi_MidiCSL convert a song to a list of note that can be read by midi player
   * It creates ChordConverterMidi_MidiCSL to retrieve midi informations about every chords and directly do the jobs for notes
   * @exports MidiCSL/SongConverterMidi_MidiCSL
   */
  SongConverterMidi_MidiCSL.exportToMidiCSL = function (songModel, unfold, callback) {
    if (!songModel instanceof SongModel) {
      throw 'SongConverterMidi_MidiCSL - exportToMusicCSLJSON - songModel parameters must be an instanceof SongModel'
    }

    function runExport(songModel, callback) {
      song = SongConverterMidi_MidiCSL.exportElementsToMidiCSL(songModel)
      if (typeof callback !== 'undefined') {
        callback(song)
      }
      return song
    }
    var song = []
    if (unfold === true) {
      this.unfold(songModel, function (newSongModel) {
        return runExport(newSongModel, callback)
      })
    } else {
      return runExport(songModel, callback)
    }
  }

  SongConverterMidi_MidiCSL.unfold = function (songModel, callback) {
    var self = this
    var newSongModel
    if (songModel.canBeUnfold() === true) {
      // replace by test if segno or code
      newSongModel = this.unfoldDirectly(songModel)
      if (typeof callback !== 'undefined') {
        callback(newSongModel)
      }
      return newSongModel
    } else {
      SongConverterMidi_MidiCSL.unfoldUsingServlet(songModel, function (newSongModel) {
        if (typeof newSongModel.error !== 'undefined') {
          newSongModel = self.unfoldDirectly(songModel)
          return newSongModel
        } else if (typeof callback !== 'undefined') {
          callback(newSongModel)
        }
        return newSongModel
      })
    }
  }

  SongConverterMidi_MidiCSL.unfoldDirectly = function (songModel) {
    var newSongModel = songModel.clone()
    newSongModel.unfold()
    return newSongModel
  }

  SongConverterMidi_MidiCSL.unfoldUsingServlet = function (songModel, callback) {
    if (typeof callback === 'undefined') {
      return
    }
    var JSONSong = SongModel_CSLJson.exportToMusicCSLJSON(songModel)
    var request = {
      leadsheet: JSON.stringify(JSONSong),
    }
    AjaxUtils.servletRequest('jsonsong', 'unfold', request, function (data) {
      if (typeof data.error !== 'undefined') {
        callback(data)
        return
      }
      var unfoldedSongModel = new SongModel()
      SongModel_CSLJson.importFromMusicCSLJSON(data.unfolded, unfoldedSongModel)
      callback(unfoldedSongModel)
      return
    })
  }

  SongConverterMidi_MidiCSL.exportElementsToMidiCSL = function (songModel) {
    var song = []
    song = ChordManagerConverterMidi_MidiCSL.exportToMidiCSL(songModel)
    var nm = songModel.getComponent('notes')
    if (typeof nm !== 'undefined') {
      var melodySong = SongConverterMidi_MidiCSL.exportNotesToMidiCSL(songModel)
      song = song.concat(melodySong)
    }
    return song
  }

  SongConverterMidi_MidiCSL.exportNotesToMidiCSL = function (songModel) {
    function addNote(midiNote, currentTime, duration, index, midiSong) {
      midiSong.push(
        new NoteModel_midiCSL({
          midiNote: midiNote,
          type: 'melody',
          currentTime: currentTime,
          duration: duration,
          noteIndex: index,
        })
      )
    }

    var song = []
    if (songModel === undefined || typeof MidiHelper === 'undefined') {
      return song
    }

    var note,
      duration,
      noteKey,
      midiNote,
      currentTime = 0,
      tieNotesObject = {},
      tieNotesNumber = 0,
      inTie = false,
      refreshTonalityNote = false,
      globalIndex = 0,
      midiSoundModel

    var songIt = new SongBarsIterator(songModel)
    var noteMng = songModel.getComponent('notes')
    var playingNotes = noteMng.score2play(songModel)

    var notesIt = new NotesIterator(songIt, playingNotes)

    while (notesIt.hasNext()) {
      note = playingNotes.getNote(notesIt.index)
      duration = note.getDuration()
      if (note.isRest) {
        addNote([false], currentTime, duration, globalIndex, song)
      } else {
        midiNote = []
        for (var k = 0; k < note.getNumPitches(); k++) {
          midiNote[k] = MidiHelper.getKeyToNote(note.getPitch(k, true))
        }
        if (note.isTie() /*&& c !== 1*/) {
          // don't use tie when there is one note (it happen when we click on one note)
          if (note.getTie() === 'start') {
            inTie = true
            tieNotesNumber = 2
            tieNotesObject = new NoteModel_midiCSL({
              midiNote: midiNote,
              type: 'melody',
              currentTime: currentTime,
              duration: duration,
              noteIndex: globalIndex,
            })
            addNote(false, currentTime, duration, globalIndex, song)
          }
          if (note.getTie() === 'stop_start') {
            tieNotesNumber++
            tieNotesObject.setDuration(tieNotesObject.getDuration() + duration)
            addNote(false, currentTime, duration, globalIndex, song)
          }
          if (note.getTie() === 'stop') {
            inTie = false
            if (typeof tieNotesObject.getDuration === 'undefined') {
              // case the tieNotes have not been yet created (it's a particular case where tie note is tie with nothing)
              // It happens when we take a chunk of a melody
              tieNotesObject = new NoteModel_midiCSL({
                midiNote: midiNote,
                type: 'melody',
                currentTime: currentTime,
                duration: duration,
                noteIndex: globalIndex,
              })
            } else {
              // usual case
              tieNotesObject.setDuration(tieNotesObject.getDuration() + duration)
            }
            tieNotesObject.tieNotesNumber = tieNotesNumber
            midiSoundModel = tieNotesObject
            song.push(tieNotesObject)
            tieNotesNumber = 0
          }
        } else {
          addNote(midiNote, currentTime, duration, globalIndex, song)
        }
      }
      currentTime += duration
      globalIndex++
      notesIt.next()
    }
    return song
  }

  return SongConverterMidi_MidiCSL
})
define('modules/core/src/Intervals', [], function () {
  /**
   * [Interval description]
   * @param {Number} type      e.g. 1 for unison, 2 for second (regardless of if it is augmented, diminished...etc.)
   * @param {Number} semitones semitones from natural C
   * @param {String} name
   */
  function Interval(type, semitones, name) {
    this.type = type
    this.semitones = semitones
    this.name = name
  }

  var Intervals = {}
  Intervals.unison = new Interval(1, 0, 'unison')
  Intervals.augmentedUnison = new Interval(1, 1, 'augmented unison')
  Intervals.superAugmentedUnison = new Interval(1, 2, 'super augmented unison')
  Intervals.diminshedUnison = new Interval(1, -1, 'diminished unison')
  Intervals.superDiminishedUnison = new Interval(1, -2, 'super diminished unison')
  Intervals.minorSecond = new Interval(2, 1, 'minor second')
  Intervals.majorSecond = new Interval(2, 2, 'major second')
  Intervals.augmentedSecond = new Interval(2, 3, 'augmented second')
  Intervals.minorThird = new Interval(3, 3, 'minor third')
  Intervals.majorThird = new Interval(3, 4, 'major third')
  Intervals.perfectFourth = new Interval(4, 5, 'perfect fourth')
  Intervals.diminishedFourth = new Interval(4, 4, 'diminished fourth')
  Intervals.augmentedFourth = new Interval(4, 6, 'augmented fourth')
  Intervals.perfectFifth = new Interval(5, 7, 'perfect fifth')
  Intervals.diminishedFifth = new Interval(5, 6, 'diminished fifth')
  Intervals.augmentedFifth = new Interval(5, 8, 'augmented fifth')
  Intervals.minorSixth = new Interval(6, 8, 'minor sixth')
  Intervals.majorSixth = new Interval(6, 9, 'major sixth')
  Intervals.augmentedSixth = new Interval(6, 10, 'augmented sixth')
  Intervals.minorSeventh = new Interval(7, 10, 'minor seventh')
  Intervals.majorSeventh = new Interval(7, 11, 'major seventh')
  Intervals.diminishedSeventh = new Interval(7, 9, 'diminished seventh')
  Intervals.octave = new Interval(8, 12, 'octave')
  Intervals.augmentedOctave = new Interval(8, 13, 'augmented octave')
  Intervals.diminishedOctave = new Interval(8, 11, 'diminished octave')
  Intervals.minorNinth = new Interval(9, 13, 'minor ninth')
  Intervals.majorNinth = new Interval(9, 14, 'major ninth')
  Intervals.augmentedNinth = new Interval(9, 15, 'augmented ninth')

  return Intervals
})
define('modules/core/src/Note', ['modules/core/src/PitchClass'], function (PitchClass) {
  /**
   * extends (by composition) PitchClass adding octave
   * @param {String} name
   * @param {Strign} accidental
   * @param {Number} octave
   */
  function Note(name, accidental, octave) {
    this.pitchClass = new PitchClass(name + accidental)
    this.octave = Number(octave)
  }
  /**
   * sets pitchClass and octave of transposed note
   * @param  {Interval} interval  object representing interval to move, e.g. perfectFifth
   * @param  {Number} direction either 1 or -1
   */
  Note.prototype.transposeBy = function (interval, direction) {
    var r = this.pitchClass.transposeBy(interval, direction, true)

    this.pitchClass = r.newPitch
    this.octave += r.octaveDiff
  }
  Note.prototype.toString = function () {
    return this.pitchClass.toString() + '/' + this.octave
  }
  return Note
})
define('modules/StructureEdition/src/StructureEditionController', [
  'jquery',
  'mustache',
  'modules/Cursor/src/CursorModel',
  'modules/core/src/SongModel',
  'modules/core/src/SectionModel',
  'modules/core/src/NoteManager',
  'modules/core/src/NoteModel',
  'modules/core/src/SongBarsIterator',
  'modules/core/src/TimeSignatureModel',
  'modules/MidiCSL/src/converters/SongConverterMidi_MidiCSL',
  'utils/NoteUtils',
  'utils/UserLog',
  'modules/MidiCSL/utils/MidiHelper',
  'modules/core/src/Intervals',
  'modules/core/src/Note',
  'modules/core/src/PitchClass',
  'pubsub',
], function (
  $,
  Mustache,
  CursorModel,
  SongModel,
  SectionModel,
  NoteManager,
  NoteModel,
  SongBarsIterator,
  TimeSignatureModel,
  SongConverterMidi_MidiCSL,
  NoteUtils,
  UserLog,
  Midi,
  Intervals,
  Note,
  PitchClass,
  pubsub
) {
  /**
   * StructureEditionController manages all structure edition function
   * @exports StructureEdition/StructureEditionController
   */
  function StructureEditionController(songModel, cursor, structEditionModel) {
    this.songModel = songModel || new SongModel()
    this.cursor = cursor || new CursorModel()
    this.initSubscribe()
    this.structEditionModel = structEditionModel
  }

  /**
   * Subscribe to view events
   */
  StructureEditionController.prototype.initSubscribe = function () {
    var self = this
    var fn
    // All functions related with note edition go here
    $.subscribe('StructureEditionView', function (el, fn, param) {
      self[fn].call(self, param)
      var forceNewCanvasLayer = fn === 'addBar' || fn === 'addSection'
      $.publish('ToViewer-draw', [self.songModel, forceNewCanvasLayer])
    })
    $.subscribe('CursorModel-setPos', function (el) {
      self.setCurrentElementFromCursor()
    })
  }

  StructureEditionController.prototype.setCurrentElementFromCursor = function () {
    if (typeof this.structEditionModel === 'undefined') {
      return
    }
    var currentBarNumber = this.songModel.getComponent('notes').getNoteBarNumber(this.cursor.getStart(), this.songModel)
    var currentBar = this.songModel.getComponent('bars').getBar(currentBarNumber)
    // TODO get tonality at
    this.structEditionModel.setSelectedBarAndSignatures(
      currentBar,
      this.songModel.getKeySignatureAt(currentBarNumber),
      this.songModel.getTimeSignatureAt(currentBarNumber)
    )
    var currentSectionNumber = this.songModel.getSectionNumberFromBarNumber(currentBarNumber)
    var currentSection = this.songModel.getSection(currentSectionNumber)
    this.structEditionModel.setSelectedSection(currentSection)
  }

  StructureEditionController.prototype.addSection = function () {
    var selBars = this._getSelectedBars()
    var currentBar = selBars[0]
    var sectionNumber = this.songModel.getSectionNumberFromBarNumber(currentBar)
    var startBar = this.songModel.getStartBarNumberFromSectionNumber(sectionNumber)

    if (startBar == selBars[0]) {
      UserLog.logAutoFade('error', 'Cannot add new section in first bar of a Section')
      return false
    }

    var section = this.songModel.getSection(sectionNumber)
    var oldTotalBars = section.getNumberOfBars()

    section.setNumberOfBars(currentBar - startBar)
    var section = new SectionModel({
      numberOfBars: startBar + oldTotalBars - currentBar,
    })
    this.songModel.addSection(section, sectionNumber + 1)

    UserLog.logAutoFade('info', 'Section has been added successfully')
    $.publish('ToLayers-removeLayer')
    $.publish('ToHistory-add', 'Add Section')
    //this.cursor.setPos(indexLastNote + 1);
  }

  StructureEditionController.prototype.removeSection = function () {
    var selBars = this._getSelectedBars()
    var currentBar = selBars[0]
    var sectionNumber = this.songModel.getSectionNumberFromBarNumber(currentBar)
    if (sectionNumber == 0) {
      UserLog.logAutoFade('error', "You can't delete last section")
      return false
    }

    var prevSection = this.songModel.getSection(sectionNumber - 1)
    var currSection = this.songModel.getSection(sectionNumber)

    prevSection.setNumberOfBars(prevSection.getNumberOfBars() + currSection.getNumberOfBars())
    this.songModel.removeSection(sectionNumber)

    UserLog.logAutoFade('info', 'Section have been removed successfully')
    $.publish('ToLayers-removeLayer')
    $.publish('ToHistory-add', 'Remove Section')
  }

  StructureEditionController.prototype.setSectionName = function (name) {
    if (typeof name === 'undefined') {
      return
    }
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    var sectionNumber = this.songModel.getSectionNumberFromBarNumber(selBars[0])
    this.songModel.getSection(sectionNumber).setName(name)
    $.publish('ToViewer-draw', this.songModel)
    $.publish('ToHistory-add', 'Rename Section ' + name)
  }

  // Carefull, if a section is played 2 times, repeatTimes = 1
  StructureEditionController.prototype.setRepeatTimes = function (repeatTimes) {
    if (typeof repeatTimes === 'undefined') {
      return
    }
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    var sectionNumber = this.songModel.getSectionNumberFromBarNumber(selBars[0])
    this.songModel.getSection(sectionNumber).setRepeatTimes(repeatTimes)

    $.publish('ToHistory-add', 'Change Section repeat' + repeatTimes)
  }

  StructureEditionController.prototype.addBar = function () {
    var selBars = this._getSelectedBars()
    var numBar = 0
    if (selBars.length !== 0) {
      numBar = selBars[0] // add bar after current one
    }

    var nm = this.songModel.getComponent('notes')
    //get the duration of the bar, and create a new bar with silences
    var beatDuration = this.songModel.getTimeSignatureAt(numBar).getQuarterBeats()
    var newBarNm = new NoteManager() //Create new Bar NoteManager

    //insert those silences
    newBarNm.fillGapWithRests(beatDuration)

    var numInsertBar = numBar + 1
    //get numBeat from first note of current bar
    var numBeat = this.songModel.getStartBeatFromBarNumber(numInsertBar)
    // get the index of that note
    var index = nm.getNextIndexNoteByBeat(numBeat)

    // remove a possibly tied notes
    if (typeof nm.getNote(index) !== 'undefined' && nm.getNote(index).isTie('stop')) {
      var tieType = nm.getNote(index).getTie()
      if (tieType === 'stop') {
        nm.getNote(index).removeTie()
        var tieTypePrevious = nm.getNote(index - 1).getTie()
        if (tieTypePrevious === 'start') {
          nm.getNote(index - 1).removeTie()
        } else if (tieTypePrevious === 'start_stop') {
          nm.getNote(index - 1).setTie('stop')
        }
      } else {
        // case it's start or stop_start
        nm.getNote(index).setTie('start')
      }
    }
    nm.notesSplice([index, index - 1], newBarNm.getNotes())
    nm.reviseNotes()

    //add bar to barManager
    var barManager = this.songModel.getComponent('bars')
    barManager.insertBar(numInsertBar, this.songModel)

    // decal chords
    this.songModel.getComponent('chords').incrementChordsBarNumberFromBarNumber(1, numInsertBar)
    $.publish('ToLayers-removeLayer')
    $.publish('ToHistory-add', 'Add Bar')
  }

  /**
   * Function deletes selected bars
   */
  StructureEditionController.prototype.removeBar = function () {
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    for (var i = selBars.length - 1; i >= 0; i--) {
      this._removeBar(selBars[i])
    }
    $.publish('ToLayers-removeLayer')
    $.publish('ToHistory-add', 'Remove Bar')
  }

  /**
   * Function deletes bar and all it's components with index, it also delete section if it was the last bar of the section
   */
  StructureEditionController.prototype._removeBar = function (barNumber) {
    var bm = this.songModel.getComponent('bars')
    var nm = this.songModel.getComponent('notes')
    var cm = this.songModel.getComponent('chords')

    var sectionNumber = this.songModel.getSectionNumberFromBarNumber(barNumber)
    var section = this.songModel.getSection(sectionNumber)
    var sectionNumberOfBars = section.getNumberOfBars()
    if (sectionNumberOfBars === 1 && this.songModel.getSections().length === 1) {
      UserLog.logAutoFade('warn', "Can't delete the last bar of the last section.")
      return
    }

    // remove notes in bar
    var beatDuration = this.songModel.getTimeSignatureAt(barNumber).getQuarterBeats() - 0.001 // I am not sure why we remove 0.001 here
    var numBeat = this.songModel.getStartBeatFromBarNumber(barNumber)
    var index = nm.getNextIndexNoteByBeat(numBeat)
    var index2 = nm.getPrevIndexNoteByBeat(numBeat + beatDuration)
    nm.notesSplice([index, index2], [])
    nm.reviseNotes()

    // remove chords in bar
    cm.removeChordsByBarNumber(barNumber)
    // if we are removing bar with time signature change, and following bar has no time signature change,
    // we move it to following bar
    //
    // adjust all chords bar number
    cm.incrementChordsBarNumberFromBarNumber(-1, barNumber)
    var timeSigChange = bm.getBar(barNumber).getTimeSignatureChange()
    if (timeSigChange && barNumber < bm.getTotal() - 1 && !bm.getBar(barNumber + 1).getTimeSignatureChange()) {
      //if it's not the last bar
      bm.getBar(barNumber + 1).setTimeSignatureChange(timeSigChange)
    }

    //we remove the bar
    bm.removeBar(barNumber)

    // adjust section number of bars (important to do it after removing bar, because 'number of bars in section' is used when deleting bar)
    section.setNumberOfBars(sectionNumberOfBars - 1)

    // We remove the section in songModel if it was the last bar of the section
    if (sectionNumberOfBars === 1) {
      this.songModel.removeSection(sectionNumber)
    }
    this.cursor.setPos(index - 1)
  }

  StructureEditionController.prototype.setTimeSignature = function (timeSignature) {
    /**
     * modifies selBars end index, if there is a time signature change, selection is reduced until the bar before the time change,
     * this behaviour is copied from Sibelius
     * @return {Boolean} tells if we actually reduced selection or not, later we set Time Signature change to the previous only if we did not reduce.
     */
    function reduceSelectionIfChanges() {
      //if there are timeSig changes in selection we just take until change
      var barsIt = new SongBarsIterator(song)
      var timeSigChangesInSelection = false,
        iBar,
        prevTimeSignature
      barsIt.setBarIndex(selBars[0] + 1) //we check if there is a timeSig change in the middle (not in first bar)
      while (barsIt.getBarIndex() <= selBars[1]) {
        iBar = barsIt.getBarIndex()

        if (barsIt.doesTimeSignatureChange()) {
          timeSigChangesInSelection = true
          selBars[1] = barsIt.getBarIndex() - 1
          break
        }
        barsIt.next()
      }
      return timeSigChangesInSelection
    }
    /**
     * @param  {Array} selBars       indexes of bars selected
     * @param  {Array} selectedNotes notes selected
     * @param  {Integer} numSelectedBars notes selected
     * @param  {TimeSignaureModel} newTimeSig    new time signature
     * @return {Array}               notes adapted to new time signature
     */
    function calcAdaptedNotes(selBars, selectedNotes, numSelectedBars, newTimeSig) {
      var tmpNm = new NoteManager()
      tmpNm.setNotes(selectedNotes)
      var notes = tmpNm.getNotesAdaptedToTimeSig(newTimeSig, numSelectedBars)
      tmpNm.setNotes(notes)
      var numBars = tmpNm.getTotalDuration() / newTimeSig.getQuarterBeats()
      return {
        notes: notes,
        numBars: numBars,
      }
    }

    //actually starts here
    var selBars = []
    selBars[0] = this.songModel.getComponent('notes').getNoteBarNumber(this.cursor.getStart(), this.songModel)
    selBars[1] = this.songModel.getComponent('notes').getNoteBarNumber(this.cursor.getEnd(), this.songModel)
    if (selBars.length === 0) {
      return
    }

    var song = this.songModel,
      barMng = song.getComponent('bars'),
      noteMng = song.getComponent('notes'),
      newTimeSig = new TimeSignatureModel(timeSignature)

    //we check if there are time signature changes within the selection in that case selection is reduced until first change, selBars[1] is modified
    var timeSigChangesInSelection = reduceSelectionIfChanges()

    //we get start and en beats of selection
    var startBeat = song.getStartBeatFromBarNumber(selBars[0])
    var endBeat = barMng.getTotal() - 1 === selBars[1] ? null : song.getStartBeatFromBarNumber(selBars[1] + 1)

    //we get selected notes and adapt them to new time signature
    var indexes = noteMng.getIndexesStartingBetweenBeatInterval(startBeat, endBeat)
    var selectedNotes = noteMng.cloneElems(indexes[0], indexes[1])
    var numSelectedBars = selBars[1] + 1 - selBars[0]
    var calc
    try {
      calc = calcAdaptedNotes(selBars, selectedNotes, numSelectedBars, newTimeSig)
      var adaptedNotes = calc.notes
      var numBarsAdaptedNotes = calc.numBars

      //HERE we change time signature
      var prevTimeSignature = song.getTimeSignatureAt(selBars[0])
      if (selBars[0] === 0) {
        // in case it's first measure we change the whole song time signature
        song.setTimeSignature(timeSignature)
      } else {
        barMng.getBar(selBars[0]).setTimeSignatureChange(timeSignature)
      }

      //check if we have to create bars to fit melody (normally if new time sign. has less beats than old one)
      var diffBars = numBarsAdaptedNotes - numSelectedBars
      if (diffBars) {
        barMng.insertBar(selBars[1], song, diffBars)
      }

      //we set previous time signature in the bar just after the selection, only if there are no time sign. changes and if we are not at end of song
      var indexFollowingBar = selBars[1] + diffBars + 1
      if (
        barMng.getTotal() > indexFollowingBar && // if following bar exists
        !timeSigChangesInSelection &&
        !barMng.getBar(indexFollowingBar).getTimeSignatureChange()
      ) {
        //if there is no time signature change in following bar
        barMng.getBar(indexFollowingBar).setTimeSignatureChange(prevTimeSignature.toString())
      }

      //we set end index to -1 because notesSplice indexes are inclusive (so if we want to paste notes over indexes [0,5] we don't have to send 0,6 like in cloneElems). These differences among the code are confusing. TODO: refactor
      indexes[1]--
      //we overwrite adapted notes in general note manager
      noteMng.notesSplice(indexes, adaptedNotes)
    } catch (e) {
      console.log(e)
      UserLog.logAutoFade('error', "Tuplets can't be broken")
      return
    }

    $.publish('ToHistory-add', 'Time signature set to ' + timeSignature)
  }
  StructureEditionController.prototype.tonality = function (tonality) {
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    for (var i = 0, c = selBars.length; i < c; i++) {
      this.songModel.getComponent('bars').getBar(selBars[i]).setKeySignatureChange(tonality)
    }
    $.publish('ToHistory-add', 'Tonality set to ' + tonality)
  }

  StructureEditionController.prototype.ending = function (ending) {
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    for (var i = 0, c = selBars.length; i < c; i++) {
      if (ending === 'none') {
        ending = undefined
      }
      this.songModel.getComponent('bars').getBar(selBars[i]).setEnding(ending)
    }
    $.publish('ToHistory-add', 'Ending set to ' + ending)
  }

  StructureEditionController.prototype.style = function (style) {
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    for (var i = 0, c = selBars.length; i < c; i++) {
      if (style === 'none') {
        style = undefined
      }
      this.songModel.getComponent('bars').getBar(selBars[i]).setStyle(style)
    }
    $.publish('ToHistory-add', 'Style set to ' + style)
  }

  StructureEditionController.prototype.label = function (label) {
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    for (var i = 0, c = selBars.length; i < c; i++) {
      if (label === 'none') {
        label = ''
      }
      this.songModel.getComponent('bars').getBar(selBars[i]).setLabel(label)
    }
    $.publish('ToHistory-add', 'Label set to ' + label)
  }

  StructureEditionController.prototype.subLabel = function (sublabel) {
    var selBars = this._getSelectedBars()
    if (selBars.length === 0) {
      return
    }
    for (var i = 0, c = selBars.length; i < c; i++) {
      if (sublabel === 'none') {
        sublabel = undefined
      }
      this.songModel.getComponent('bars').getBar(selBars[i]).setSublabel(sublabel)
    }
    $.publish('ToHistory-add', 'Sublabel set to ' + sublabel)
  }

  StructureEditionController.prototype._getSelectedBars = function () {
    var noteMng = this.songModel.getComponent('notes')
    var selectedBars = []
    selectedBars[0] = noteMng.getNoteBarNumber(this.cursor.getStart(), this.songModel)
    selectedBars[1] = noteMng.getNoteBarNumber(this.cursor.getEnd(), this.songModel)
    if (selectedBars[1] === selectedBars[0]) {
      selectedBars.pop()
    }
    return selectedBars
  }

  StructureEditionController.prototype.unfold = function (force) {
    var unfold = true
    if (typeof force === 'undefined' || force === false) {
      unfold = !this.structEditionModel.unfolded
    }
    if (unfold) {
      this.oldSong = this.songModel
      var newSongModel = this.songModel.unfold()
      this.songModel = newSongModel
      $.publish('ToViewer-draw', this.songModel)
    } else {
      $.publish('ToViewer-draw', this.oldSong)
    }
    this.structEditionModel.toggleUnfolded()
    $.publish('ToLayers-removeLayer')
  }

  StructureEditionController.prototype.transposeSong = function (semiTons) {
    if (isNaN(semiTons) || semiTons === 0) {
      return
    }
    function getTransposedNote(note, interval, direction) {
      var newNote = new Note(note.getPitchClass(), note.getAccidental(), note.getOctave())
      newNote.transposeBy(interval, direction)
      return newNote.toString()
    }

    var transpositions = [
      'unison', //0
      'minorSecond', //1
      'majorSecond', //2
      'minorThird', //3
      'majorThird', //4
      'perfectFourth', //5
      'augmentedFourth', //6
      'perfectFifth', //7
      'minorSixth', //8
      'majorSixth', //9
      'minorSeventh', //10
      'majorSeventh', //11
      'octave', //12
      'minorNinth', //13
      'majorNinth', //14
    ]

    var interval = Intervals[transpositions[Math.abs(semiTons)]]
    var direction = semiTons < 0 ? -1 : 1

    // notes
    // First we get all notes and all midi notes
    //var nm = this.songModel.getComponent('notes');
    var noteMng = this.songModel.getComponent('notes')
    var start = 0,
      end = noteMng.getTotal(),
      pitchClass,
      note
    // var start = this.cursor.getStart();
    //  	end = this.cursor.getEnd() + 1;
    var tmpNoteMng = noteMng.score2play(this.songModel, start, end)

    for (var i = 0; i < tmpNoteMng.getTotal(); i++) {
      note = tmpNoteMng.getNote(i)
      if (!note.isRest) {
        note.setNoteFromString(getTransposedNote(note, interval, direction))
      }
    }

    noteMng.notesSplice([start, end - 1], tmpNoteMng.getNotes())
    var tmpNoteMng = noteMng.play2score(this.songModel, start, end)
    noteMng.notesSplice([start, end - 1], tmpNoteMng.getNotes())
    // chords
    var chordMng = this.songModel.getComponent('chords')
    var chord
    for (var i = 0, c = chordMng.getTotal(); i < c; i++) {
      chord = chordMng.getChord(i)
      if (chord.getNote() == 'NC') continue

      pitchClass = new PitchClass(chord.getNote())
      chord.setNote(pitchClass.transposeBy(interval, direction).toString())
    }

    $.publish('ToHistory-add', 'Transpose Song ' + semiTons + ' half ton(s)')
  }

  return StructureEditionController
})
define('modules/StructureEdition/src/StructureEditionModel', ['jquery', 'pubsub'], function ($, pubsub) {
  function StructureEditionModel() {
    this.unfolded = false
    this.selectedSection = undefined
    this.selectedBar = undefined
    this.keySignature = undefined
    this.timeSignature = undefined
  }

  StructureEditionModel.prototype.setUnfolded = function (value) {
    this.unfolded = !!value
    $.publish('StructureEditionModel-setUnfolded', this.unfolded)
  }

  StructureEditionModel.prototype.setSelectedBarAndSignatures = function (bar, keySignature, timeSignature) {
    if (typeof bar === 'undefined') {
      throw 'StructureEditionModel - setSelectedBar - bar is not defined'
    }
    if (this.selectedBar != bar) {
      this.selectedBar = bar
      $.publish('StructureEditionModel-setSelectedBar', bar)
    }
    if (this.keySignature !== keySignature) {
      this.keySignature = keySignature
      $.publish('StructureEditionModel-setKeySignature', keySignature)
    }
    if (this.timeSignature !== timeSignature) {
      this.timeSignature = timeSignature
      $.publish('StructureEditionModel-setTimeSignature', timeSignature)
    }
  }

  StructureEditionModel.prototype.setSelectedSection = function (section) {
    if (typeof section === 'undefined') {
      throw 'StructureEditionModel - setSelectedSection - section is not defined'
    }
    this.selectedSection = section
    $.publish('StructureEditionModel-setSelectedSection', section)
  }

  StructureEditionModel.prototype.toggleUnfolded = function () {
    var unfolded = !this.unfolded
    this.setUnfolded(unfolded)
  }

  return StructureEditionModel
})

define('text!modules/StructureEdition/src/StructureEditionTemplate.html', [], function () {
  return '<div id="edit_bars_second_level">\n\t<div id="transpose_container">\n\t\t<select id="leadsheet_transpose">\n\t\t\t<option value="-6">-6</option>\n\t\t\t<option value="-5">-5</option>\n\t\t\t<option value="-4">-4</option>\n\t\t\t<option value="-3">-3</option>\n\t\t\t<option value="-2">-2</option>\n\t\t\t<option value="-1">-1</option>\n\t\t\t<option value="0" selected="selected">none</option>\n\t\t\t<option value="1">1</option>\n\t\t\t<option value="2">2</option>\n\t\t\t<option value="3">3</option>\n\t\t\t<option value="4">4</option>\n\t\t\t<option value="5">5</option>\n\t\t\t<option value="6">6</option>\n\t\t</select>\n\t\t<div class="button_text">\n\t\t\tTransposition\n\t\t</div>\n\t</div>\n\t<div id="edit_bar_container">\n\t\t<div id="edit_each_bar_container">\n\t\t\t<div class="current_button" title="Add section" id="add-section"><img src="{{imgPath}}/add.png" alt="Add section" /></div>\n\t\t\t<div class="current_button" title="Remove section" id="rem-section"><img src="{{imgPath}}/remove.png" alt="Delete section" /></div>\n\t\t\t<span><input type="input" id="inputSectionName" name="inputSectionName" placeholder="Section title" />\n\t\t\t<input type="button" value="Ok" id="validateSectionTitle" /></span>\n\t\t\t<select id="selectSectionRepeatTimes">\n\t\t\t\t<option value="1">1</option>\n\t\t\t\t<option value="2">2</option>\n\t\t\t\t<option value="3">3</option>\n\t\t\t\t<option value="4">4</option>\n\t\t\t\t<option value="5">5</option>\n\t\t\t\t<option value="6">6</option>\n\t\t\t\t<option value="7">7</option>\n\t\t\t\t<option value="8">8</option>\n\t\t\t\t<option value="9">9</option>\n\t\t\t\t<option value="10">10</option>\n\t\t\t\t<option value="11">11</option>\n\t\t\t\t<option value="12">12</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tSections\n\t\t</div>\n\t</div>\n\t<div id="edit_bar_container">\n\t\t<div id="edit_each_bar_container">\n\t\t\t<div class="current_button" title="Add bar after" id="add-bar"><img src="{{imgPath}}/add.png" alt="Add bar" /></div>\n\t\t\t<div class="current_button" title="Remove bar" id="rem-bar"><img src="{{imgPath}}/remove.png" alt="Delete bar" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tBars\n\t\t</div>\n\t</div>\n\t<!--div id="selection_bar_container">\n\t\t<div id="edit_each_selection_bar_container">\n\t\t\t<div class="current_button" id="copy-bar" title="Copy (Ctrl+C)"><img src="{{static}}/img/general_icons/copy.png" alt="copy" /></div>\n\t\t\t<div class="current_button" id="paste-bar" title="Paste (Ctrl+V)"><img src="{{static}}/img/general_icons/paste.png" alt="paste" /></div>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tSelection\n\t\t</div>\n\t</div-->\n\t<div id="edit_time_signature_container">\n\t\t<div id="edit_each_time_signature_container">\n\t\t\t<select>\n\t\t\t\t<option value="select">Select</option>\n\t\t\t\t<option value="2/2">2/2</option>\n\t\t\t\t<option value="2/4">2/4</option>\n\t\t\t\t<option value="3/4">3/4</option>\n\t\t\t\t<option value="4/4">4/4</option>\n\t\t\t\t<option value="5/4">5/4</option>\n\t\t\t\t<option value="6/4">6/4</option>\n\t\t\t\t<option value="7/4">7/4</option>\n\t\t\t\t<option value="9/4">9/4</option>\n\t\t\t\t<option value="3/8">3/8</option>\n\t\t\t\t<option value="6/8">6/8</option>\n\t\t\t\t<option value="7/8">7/8</option>\n\t\t\t\t<option value="9/8">9/8</option>\n\t\t\t\t<option value="12/8">12/8</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tTime Signature\n\t\t</div>\n\t</div>\n\t<div id="edit_tonality_container">\n\t\t<div id="edit_each_tonality_container">\n\t\t\t<select>\n\t\t\t\t<option value="C">C</option>\n\t\t\t\t<option value="C#">C#</option>\n\t\t\t\t<option value="Db">Db</option>\n\t\t\t\t<option value="D">D</option>\n\t\t\t\t<option value="Eb">Eb</option>\n\t\t\t\t<option value="E">E</option>\n\t\t\t\t<option value="F">F</option>\n\t\t\t\t<option value="F#">F#</option>\n\t\t\t\t<option value="Gb">Gb</option>\n\t\t\t\t<option value="G">G</option>\n\t\t\t\t<option value="Ab">Ab</option>\n\t\t\t\t<option value="A">A</option>\n\t\t\t\t<option value="Bb">Bb</option>\n\t\t\t\t<option value="B">B</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tTonality\n\t\t</div>\n\t</div>\n\t<div id="edit_ending_container">\n\t\t<div id="edit_each_ending_container">\n\t\t\t<select>\n\t\t\t\t<option value="none">none</option>\n\t\t\t\t<option value="1">1</option>\n\t\t\t\t<option value="2">2</option>\n\t\t\t\t<option value="3">3</option>\n\t\t\t\t<option value="4">4</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tEnding\n\t\t</div>\n\t</div>\n\t<!--<div id="edit_style_container">\n\t\t<div id="edit_each_style_container">\n\t\t\t<select>\n\t\t\t\t<option value="none">none</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tStyle\n\t\t</div>\n\t</div>-->\n\n\t<div id="edit_label_container">\n\t\t<div id="edit_each_label_container">\n\t\t\t<select>\n\t\t\t\t<option value="none">none</option>\n\t\t\t\t<option value="segno">segno</option>\n\t\t\t\t<option value="segno2">segno2</option>\n\t\t\t\t<option value="fine">fine</option>\n\t\t\t\t<option value="coda">coda</option>\n\t\t\t\t<option value="coda2">coda2</option>\n\t\t\t\t<option value="on cue">on cue</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tLabel\n\t\t</div>\n\t</div>\n\t<div id="edit_sublabel_container">\n\t\t<div id="edit_each_sublabel_container">\n\t\t\t<select>\n\t\t\t\t<option value="none">none</option>\n\t\t\t\t<option value="DS">DS</option>\n\t\t\t\t<option value="DS2">DS2</option>\n\t\t\t\t<option value="DS al Fine">DS al Fine</option>\n\t\t\t\t<option value="DC al Fine">DC al Fine</option>\n\t\t\t\t<option value="DS al Coda">DS al Coda</option>\n\t\t\t\t<option value="DS al Coda2">DS al Coda2</option>\n\t\t\t\t<option value="DC al Coda">DC al Coda</option>\n\t\t\t\t<option value="DC al Coda2">DC al Coda2</option>\n\t\t\t\t<option value="DS al 2nd ending">DS al 2nd ending</option>\n\t\t\t\t<option value="DS2 al Fine">DS2 al Fine</option>\n\t\t\t\t<option value="DS2 al Coda">DS2 al Coda</option>\n\t\t\t\t<option value="DS2 al Coda2">DS2 al Coda2</option>\n\t\t\t\t<option value="Da capo no rep">Da capo no rep</option>\n\t\t\t</select>\n\t\t</div>\n\t\t<div class="button_text">\n\t\t\tSublabel\n\t\t</div>\n\t</div>\n\t<!--<div id="unfold_container">\n\t\t<input type="button" value="Unfold" id="unfold" />\n\t</div>-->\n</div>'
})

define('modules/StructureEdition/src/StructureEditionView', [
  'mustache',
  'modules/core/src/SongModel',
  'utils/UserLog',
  'jquery',
  'pubsub',
  'text!modules/StructureEdition/src/StructureEditionTemplate.html',
], function (Mustache, SongModel, UserLog, $, pubsub, StructureEditionTemplate) {
  /**
   * StructureEditionView creates structure edition template and link event from html to controller
   * @exports StructureEdition/StructureEditionView
   */
  function StructureEditionView(imgPath) {
    this.el = undefined
    this.imgPath = imgPath
    this.initSubscribe()
    this.initKeyboard()
    this.render()
  }

  StructureEditionView.prototype.render = function (parentHTML, callback) {
    //if (typeof this.el === "undefined" || (typeof this.el !== "undefined" && force === true)) {
    this.el = Mustache.render(StructureEditionTemplate, {
      imgPath: this.imgPath,
    })
  }

  /**
   * Publish event after receiving dom events
   */
  StructureEditionView.prototype.initController = function () {
    var fn
    var publishTarget = 'StructureEditionView'
    $('#add-section').click(function () {
      fn = 'addSection'
      $.publish(publishTarget, fn)
    })
    $('#rem-section').click(function () {
      fn = 'removeSection'
      $.publish('StructureEditionView', fn)
    })
    $('#validateSectionTitle').click(function () {
      var name = $('#inputSectionName').val()
      fn = 'setSectionName'
      $.publish('StructureEditionView', [fn, name])
    })
    $('#selectSectionRepeatTimes').change(function () {
      var repeatTimes = parseInt($(this).val(), 10) - 1 // number of repetition is the number of played times minus 1
      fn = 'setRepeatTimes'
      $.publish('StructureEditionView', [fn, repeatTimes])
    })

    $('#add-bar').click(function () {
      fn = 'addBar'
      $.publish('StructureEditionView', fn)
    })
    $('#rem-bar').click(function () {
      fn = 'removeBar'
      $.publish('StructureEditionView', fn)
    })

    // Time Signature change
    $('#edit_each_time_signature_container select').change(function () {
      fn = 'setTimeSignature'
      var timeSignature = $(this).val()
      if (timeSignature === 'select') {
        return
      }
      $.publish('StructureEditionView', [fn, timeSignature])
    })

    // Tonality change
    $('#edit_each_tonality_container select').change(function () {
      fn = 'tonality'
      var tonality = $(this).val()
      $.publish('StructureEditionView', [fn, tonality])
    })

    // Ending change
    $('#edit_each_ending_container select').change(function () {
      var ending = $(this).val()
      fn = 'ending'
      $.publish('StructureEditionView', [fn, ending])
    })

    // // Style change
    // $('#edit_each_style_container select').change(function() {
    // 	var style = $(this).val();
    // 	fn = 'style';
    // 	$.publish('StructureEditionView-', [fn, style]);
    // });

    // Label change
    $('#edit_each_label_container select').change(function () {
      var label = $(this).val()
      fn = 'label'
      $.publish('StructureEditionView', [fn, label])
    })

    // Sublabel change
    $('#edit_each_sublabel_container select').change(function () {
      var sublabel = $(this).val()
      fn = 'subLabel'
      $.publish('StructureEditionView', [fn, sublabel])
    })
    $('#unfold').click(function () {
      $.publish('StructureEditionView', 'unfold')
    })

    $('#leadsheet_transpose').change(function () {
      var semiTons = Number($(this).val())
      fn = 'transposeSong'
      $.publish('StructureEditionView', [fn, semiTons])
    })
  }

  StructureEditionView.prototype.initKeyboard = function (evt) {}

  /**
   * Subscribe to model events
   */
  StructureEditionView.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('StructureEditionModel-setUnfolded', function (el, unfolded) {
      var textButton = unfolded ? 'Fold' : 'Unfold'
      $('#unfold').val(textButton)
    })
    $.subscribe('StructureEditionModel-setSelectedSection', function (el, currentSection) {
      self._setSelectedSection(currentSection)
    })
    $.subscribe('StructureEditionModel-setSelectedBar', function (el, currentBar) {
      self._setSelectedBar(currentBar)
    })
    $.subscribe('StructureEditionModel-setKeySignature', function (el, keySignature) {
      self._setTonality(keySignature)
    })
    $.subscribe('StructureEditionModel-setTimeSignature', function (el, timeSignature) {
      self._setBarTimeSignature(timeSignature)
    })
  }

  StructureEditionView.prototype._setSelectedSection = function (currentSection) {
    this._setSectionName(currentSection.getName())
    this._setSectionRepeatTimes(currentSection.getRepeatTimes())
  }
  StructureEditionView.prototype._setSelectedBar = function (currentBar) {
    this._setEnding(currentBar.getEnding())
    this._setLabel(currentBar.getLabel())
    this._setSublabel(currentBar.getSublabel())
  }

  StructureEditionView.prototype._setSectionName = function (sectionName) {
    if ($('#inputSectionName').val() !== sectionName) {
      $('#inputSectionName').val(sectionName)
    }
  }
  StructureEditionView.prototype._setSectionRepeatTimes = function (repeatTimes) {
    if (typeof repeatTimes === 'undefined') {
      repeatTimes = 1
    } else {
      repeatTimes++
    }
    if ($('#selectSectionRepeatTimes').val() !== repeatTimes) {
      $('#selectSectionRepeatTimes').val(repeatTimes)
    }
  }

  StructureEditionView.prototype._setBarTimeSignature = function (timeSignature) {
    if (typeof timeSignature === 'undefined') {
      timeSignature = 'select'
    }
    if ($('#edit_each_time_signature_container select').val() !== timeSignature.toString()) {
      $('#edit_each_time_signature_container select').val(timeSignature.toString())
    }
  }
  StructureEditionView.prototype._setTonality = function (tonality) {
    if (typeof tonality !== 'undefined') {
      if ($('#edit_each_tonality_container select').val() !== tonality) {
        $('#edit_each_tonality_container select').val(tonality)
      }
    }
  }
  StructureEditionView.prototype._setEnding = function (ending) {
    if (typeof ending === 'undefined') {
      ending = 'none'
    }
    if ($('#edit_each_ending_container select').val() !== ending) {
      $('#edit_each_ending_container select').val(ending)
    }
  }
  StructureEditionView.prototype._setLabel = function (label) {
    if (typeof label === 'undefined') {
      label = 'none'
    }
    if ($('#edit_each_label_container select').val() !== label) {
      $('#edit_each_label_container select').val(label)
    }
  }
  StructureEditionView.prototype._setSublabel = function (sublabel) {
    if (typeof sublabel === 'undefined') {
      sublabel = 'none'
    }
    if ($('#edit_each_sublabel_container select').val() !== sublabel) {
      $('#edit_each_sublabel_container select').val(sublabel)
    }
  }
  return StructureEditionView
})
define('modules/StructureEdition/src/StructureEdition', [
  'modules/StructureEdition/src/StructureEditionController',
  'modules/StructureEdition/src/StructureEditionModel',
  'modules/StructureEdition/src/StructureEditionView',
], function (StructureEditionController, StructureEditionModel, StructureEditionView) {
  /**
   * StructureEdition constructor
   * @exports StructureEdition
   */
  function StructureEdition(songModel, cursorModel, imgPath) {
    this.view = new StructureEditionView(imgPath)
    var seM = new StructureEditionModel()
    var seC = new StructureEditionController(songModel, cursorModel, seM)
  }
  return StructureEdition
})
define('modules/TextEdition/src/TextElementView', ['modules/Edition/src/ElementView'], function (ElementView) {
  /**
   * Allow text in canvas to be selected
   * @exports TextEdition/TextElementView
   * @param {Object} position {x:439.25, y:33,w:10,h:10} //position
   * @param {Scaler} viewerScaler  Scaler
   */
  function TextElementView(position, viewerScaler) {
    this.position = position
    this.scaler = viewerScaler
  }
  /**
   * @interface
   * @param  {Object}  coords [description]
   * @return {Boolean}        [description]
   */
  TextElementView.prototype.isInPath = function (coords) {
    return ElementView.isInPath(coords, this.position, this.scaler)
  }

  /**
   * @interface
   */
  TextElementView.prototype.getArea = function () {
    return this.position
  }

  return TextElementView
})
define('modules/TextEdition/src/TextElementManager', [
  'jquery',
  'pubsub',
  'modules/TextEdition/src/TextElementView',
  'modules/Edition/src/HtmlInputElement',
], function ($, pubsub, TextElementView, HtmlInputElement) {
  /**
   * Allow text in canvas to be clickabel and editable
   * @exports TextEdition/TextElementManager
   * @param {Object} fieldElement its a property of the viewer (LSViewer), which is created in the function draw, and contains de dimensions of the object. E.g.: titleView, or composerView which are created respectively in LSViewer._displayTitle() and LSViewer._displayComposer()
   * @param {String} name         should be UpperCamelCase (first letter capital), and there should a setter and a getter in songModel. e.g. name = 'Title', functions songModel.getTitle() and songModel.setTitle() exists, same for name = 'Composer', songModel.setComposer(), songModel.getComposer(). TODO: composers will be treated as ana array, so we have function 'addComposer'. It is not solved yet how to update a composer (or several). When we'll do it, maybe we should pass set and get functions as arguments instead of 'name'
   * @param {LSViewer} viewer
   * @param {SongModel} songModel
   * @param {Array} suggestions	Array of suggestions in case input need autocomplete
   *
   */
  function TextElementManager(fieldElement, name, viewer, songModel, suggestions) {
    if (typeof fieldElement !== 'string' || typeof name !== 'string' || !viewer) {
      throw 'TextElementManager error params'
    }

    this.CL_NAME = name
    this.CL_TYPE = 'CLICKABLE'
    this.viewer = viewer
    this.initSubscribe(fieldElement)
    this.textView = null

    this.songModel = songModel
    this.songSetNameFn = 'set' + name
    this.songGetNameFn = 'get' + name
    this.suggestions = suggestions

    if (
      typeof this.songModel[this.songSetNameFn] !== 'function' ||
      typeof this.songModel[this.songGetNameFn] !== 'function'
    ) {
      throw 'TextElementManager - missing get or set function in songModel'
    }
  }

  TextElementManager.prototype.initSubscribe = function (fieldElement) {
    var self = this
    $.subscribe('LSViewer-drawEnd', function (el, viewer) {
      // If Lsviewer doesn't have a canvas layer we do nothing, otherwise we need to update textelement
      if (viewer.canvasLayer) {
        //throw "TextElementManager needs CanvasLayer";
        self.textView = new TextElementView(viewer[fieldElement], viewer.scaler)
        viewer.canvasLayer.addElement(self)
        viewer.canvasLayer.refresh()
      }
    })
  }
  TextElementManager.prototype.getType = function () {
    return this.CL_TYPE
  }

  TextElementManager.prototype.isEnabled = function () {
    return true
  }

  TextElementManager.prototype.onSelected = function () {
    var self = this
    var inputVal = this.songModel[this.songGetNameFn].call(this.songModel)

    this.htmlInput = new HtmlInputElement(this.viewer, this.CL_NAME, this.textView.getArea())
    var input = this.htmlInput.input

    input.focus()
    input.val(inputVal)
    $(input).keyup(function (evt) {
      var keyCode = evt === null ? event.keyCode : evt.keyCode
      var value = $(this).val()
      self.songModel[self.songSetNameFn].call(self.songModel, value)
      if (keyCode == 13) {
        self.disable()
      }
    })

    if (this.suggestions) {
      input.devbridgeAutocomplete({
        lookup: this.suggestions,
        width: 500,
        lookupFilter: function (suggestion, originalQuery, queryLowerCase) {
          return suggestion.value.toLowerCase().indexOf(queryLowerCase) === 0
        },
        onSelect: function (suggestion) {
          self.songModel[self.songSetNameFn].call(self.songModel, suggestion.value)
        },
      })
    }
  }
  TextElementManager.prototype.enable = function () {
    //do nothing
  }
  TextElementManager.prototype.disable = function () {
    if (this.htmlInput) {
      this.htmlInput.input.devbridgeAutocomplete('dispose')
      this.htmlInput.remove()
      $.publish('ToViewer-draw', this.songModel)
    }
  }
  TextElementManager.prototype.inPath = function (coords) {
    return !!this.textView.isInPath(coords)
  }
  // no getYs function because it is not selectable
  return TextElementManager
})
define('modules/Edition/src/Edition', [
  'modules/Cursor/src/Cursor',
  'modules/NoteEdition/src/NoteEdition',
  'modules/ChordEdition/src/ChordEdition',
  'modules/StructureEdition/src/StructureEdition',
  'modules/TextEdition/src/TextElementManager',
], function (Cursor, NoteEdition, ChordEdition, StructureEdition, TextElementManager) {
  /**
   * Edition constructor
   * @exports Edition
   */
  function Edition(viewer, songModel, menuModel, params) {
    if (!params || !songModel) {
      throw 'Edition - needs params'
    }

    //editing title
    var titleSuggs = params.title ? params.title.suggestions : null
    new TextElementManager('titleView', 'Title', viewer, songModel, titleSuggs)
    var composerSuggs = params.composerSuggestions
    new TextElementManager('composerView', 'Composer', viewer, songModel, composerSuggs)

    var cursorNotesModel, noteEdition, chordEdition, structEdition, imgPath

    if (params.notes) {
      // Edit notes on view
      //cursorNote = new Cursor(songModel.getComponent('notes'), 'notes', 'arrow');
      cursorNotesModel = params.snglNotesCursor.getInstance(songModel)

      imgPath = menuModel ? menuModel.options.notes.imgPath : undefined
      noteEdition = new NoteEdition(songModel, cursorNotesModel, viewer, imgPath, params.snglNotesManager)

      if (menuModel && menuModel.options.notes.menu) {
        menuModel.addMenu({
          title: menuModel.options.notes.menu.title,
          view: noteEdition.view,
          order: menuModel.options.notes.menu.order,
        })
      }
    }
    if (params.chords) {
      // // Edit chords on view
      var cursorChord = new Cursor(songModel.getSongTotalBeats(), 'chords', 'tab')
      cursorChord.controller.model.setEditable(false)
      imgPath = menuModel ? menuModel.options.chords.imgPath : undefined
      chordEdition = new ChordEdition(songModel, cursorChord.controller.model, viewer, imgPath)

      if (menuModel && menuModel.options.chords.menu) {
        menuModel.addMenu({
          title: menuModel.options.chords.menu.title,
          view: chordEdition.view,
          order: menuModel.options.chords.menu.order,
        })
      }
    }

    if (params.structure) {
      if (!params.notes) {
        throw 'Edition: to add structure, cursor of notes edition needed'
      }
      //bars edition
      imgPath = menuModel ? menuModel.options.structure.imgPath : undefined
      var structEdition = new StructureEdition(songModel, params.snglNotesCursor.getInstance(), imgPath)

      if (menuModel && menuModel.options.structure.menu) {
        menuModel.addMenu({
          title: menuModel.options.structure.menu.title,
          view: structEdition.view,
          order: menuModel.options.structure.menu.order,
        })
      }
    }
    return {
      noteEdition: noteEdition,
      chordEdition: chordEdition,
      structEdition: structEdition,
      cursorChord: cursorChord,
      notesCursor: cursorNotesModel,
    }
  }
  return Edition
})

define('text!modules/FileEdition/src/FileEditionTemplate.html', [], function () {
  return '<div id="editor_menu_second_level">\n  {{#save}}\n  <div id="save_container">\n    <div id="save_menu_each_container">\n      {{#saveButton}}<button class="btn" id="leadsheet_save">提交作业</button\n      >{{/saveButton}} {{#saveAsButton}}<button\n        class="btn"\n        id="leadsheet_save_as"\n      >\n        暂存至系统</button\n      >{{/saveAsButton}}\n    </div>\n  </div>\n  {{/save}} {{#import}}\n  <div id="import_container">\n    <div id="editor_menu_each_import_container">\n      <div\n        class="current_button"\n        title="Import leadsheet as MusicCSL JSON or MusicXML"\n      >\n        <input\n          type="file"\n          id="importFile"\n          accept="text/json, text/xml, .json, .xml"\n        />\n      </div>\n    </div>\n    <div class="button_text">导入文件</div>\n  </div>\n  {{/import}} {{#export}}\n  <div id="export_container">\n    <div id="editor_menu_each_export_container">\n      <div\n        class="current_button"\n        id="export_png"\n        title="Export leadsheet as png"\n      >\n        PNG\n      </div>\n      <div\n        class="current_button"\n        id="export_pdf"\n        title="Export leadsheet as pdf"\n      >\n        PDF\n      </div>\n      <div\n        class="current_button"\n        id="export_musicCslJson"\n        title="Export leadsheet as MusicCSL JSON"\n      >\n        MusicCSL JSON\n      </div>\n    </div>\n    <div class="button_text">导出文件</div>\n  </div>\n  {{/export}}\n</div>\n'
})

define('modules/FileEdition/src/FileEditionView', [
  'jquery',
  'mustache',
  'modules/core/src/SongModel',
  'utils/UserLog',
  'pubsub',
  'text!modules/FileEdition/src/FileEditionTemplate.html',
], function ($, Mustache, SongModel, UserLog, pubsub, FileEditionTemplate) {
  /**
   * [FileEditionView description]
   * @exports FileEdition/FileEditionView
   * @param {Object} params {
   *	import: Boolean,
   *	export: Boolean,
   *	save: Boolean
   * }
   */
  function FileEditionView(params) {
    this.el = undefined
    this.initSubscribe()
    this.initKeyboard()
    this.render(params)
  }

  FileEditionView.prototype.render = function (params) {
    params = params || {}
    params.import = params.import !== undefined ? params.import : true
    params.export = params.export !== undefined ? params.export : true
    params.save = params.save !== undefined ? params.save : true
    this.el = Mustache.render(FileEditionTemplate, params)
  }
  /**
   * Publish event after receiving dom events
   */
  FileEditionView.prototype.initController = function () {
    var self = this
    // Leadsheet parameters
    $('#leadsheet_save').click(function () {
      $.publish('FileEditionView-save')
    })
    $('#leadsheet_save_as').click(function () {
      $.publish('FileEditionView-saveAs')
    })

    /*
		$('#leadsheet_edit_chord_sequence').click(function() {

		});

		$('#leadsheet_key_title').click(function() {

		});*/
    $('#importFile').change(function (e) {
      var file = e.target.files[0]
      var allowedTypes = ['json', 'xml', 'mxml']
      var extension = file.name.split('.')
      extension = extension[extension.length - 1]
      var type = allowedTypes.indexOf(extension)
      if (!file || type === -1) {
        return
      }
      var reader = new FileReader()
      reader.onload = function (e) {
        if (type === 0) {
          $.publish('FileEditionView-importMusicCSLJSON', JSON.parse(e.target.result))
        } else {
          $.publish('FileEditionView-importMusicXML', e.target.result)
        }
      }
      reader.readAsText(file)
      return false
    })

    // leadsheet export
    $('#export_png').click(function () {
      $.publish('FileEditionView-exportPNG')
    })

    $('#export_pdf').click(function () {
      $.publish('FileEditionView-exportPDF')
    })

    $('#export_musicCslJson').click(function () {
      $.publish('FileEditionView-exportMusicCSLJSON')
    })
  }

  FileEditionView.prototype.initKeyboard = function (evt) {}

  /**
   * Subscribe to model events
   */
  FileEditionView.prototype.initSubscribe = function () {}

  return FileEditionView
})

define('modules/LSViewer/src/LSNoteView', [
  'vexflow',
  'modules/converters/MusicCSLJson/src/NoteModel_CSLJson',
], function (Vex, NoteModel_CSLJson) {
  /**
   * LSNoteView is a module called by LSViewer to draw notes
   * @exports LSViewer/LSNoteView
   */
  function LSNoteView(note) {
    this.vexflowNote = createVexflowNote(note)
    this.note = note

    /**
     * @param  {NoteModel} note
     * @return {Vex.Flow.StaveNote}
     */
    function createVexflowNote(note) {
      var cslNote = NoteModel_CSLJson.exportToMusicCSLJSON(note)
      if (note.isRest) {
        cslNote.keys[0] = 'B/4'
      }
      var vexflowNote = new Vex.Flow.StaveNote(cslNote)

      if (parseInt(vexflowNote.keyProps[0].octave, null) >= 5) {
        vexflowNote.setStemDirection(-1)
      }
      var accidental = []
      var i
      for (i = 0; i < note.getNumPitches(); i++) {
        accidental.push(note.getAccidental(i))
      }
      //accidental can either be a string (for monophony) or an array (for polyphony)
      for (var acc in accidental) {
        if (accidental[acc] != null && accidental[acc].length !== 0)
          vexflowNote.addAccidental(acc, new Vex.Flow.Accidental(accidental[acc]))
      }
      var dot = note.getDot()

      if (dot) {
        for (i = 0; i < dot; i++) vexflowNote.addDot(0)
      }
      //if (note.isRest)
      return vexflowNote
    }
  }
  LSNoteView.prototype.getVexflowNote = function () {
    return this.vexflowNote
  }

  LSNoteView.prototype.getArea = function () {
    var boundingBox = this.vexflowNote.getBoundingBox()

    return {
      x: boundingBox.x,
      y: this.vexflowNote.stave.y,
      w: boundingBox.w,
      h: boundingBox.h,
    }
  }
  LSNoteView.prototype.isBeamable = function () {
    return /^\d+$/.test(this.vexflowNote.duration) && !this.note.isRest
  }
  return LSNoteView
})
define('modules/NoteEdition/src/NoteSpaceView', ['modules/Edition/src/ElementView'], function (ElementView) {
  /**
   * NoteSpaceView allow note to be selected
   * This object is created by NoteSpaceManager
   * @param {Object} position {x:439.25, y:33,w:10,h:10} //position
   * @param {Scaler} viewerScaler   Scaler object
   * @exports NoteEdition/NoteSpaceView
   */
  function NoteSpaceView(position, viewerScaler) {
    this.position = position
    this.scaler = viewerScaler
  }
  /**
   * @interface
   * @param  {Object}  coords [description]
   * @return {Boolean}        [description]
   */
  NoteSpaceView.prototype.isInPath = function (coords) {
    return ElementView.isInPath(coords, this.position, this.scaler)
  }
  /**
   * @interface
   * @param  {Object}  coords [description]
   * @return {Boolean}        [description]
   */
  NoteSpaceView.prototype.isBetweenYs = function (coords) {
    return ElementView.isBetweenYs(coords, this.position, this.scaler)
  }
  /**
   * @interface
   */
  NoteSpaceView.prototype.getArea = function () {
    return this.position
  }

  return NoteSpaceView
})
define('modules/LSViewer/src/LSChordView', ['vexflow'], function (Vex) {
  /**
   * LSChordView is a module called by LSViewer to draw chords
   * @exports LSViewer/LSChordView
   */
  function LSChordView(chord, color) {
    this.color = color || '#000'
    this.chord = chord
  }
  /**
   * @param  {CanvasContext} ctx
   * @param  {Object} barDimensions e.g. {x:1, y:1, w:2, h:2}
   * @param  {TimeSignatureModel} timeSig
   * @param  {Number} chordsY
   * @param  {String} fontChords
   * @param  {Number} marginLeft
   * @param  {Function} boundingBoxFn returns bounding box of drawed chord, i.e. an object like {x:1, y:1, w:2, h:2}
   * @return {Object}               returns bounding box if function is sent (i.e. when LSViewer.SAVE_CHORDS === true)
   */
  LSChordView.prototype.draw = function (ctx, barDimensions, timeSig, chordsY, fontChords, marginLeft, boundingBoxFn) {
    if (!fontChords) {
      throw 'LSChordView - missing params'
    }
    function getChordX(beat, barDimensions, beatWidth) {
      var zeroBasedBeat = beat - 1
      return barDimensions.left + marginLeft + zeroBasedBeat * beatWidth
    }
    var beatWidth = (barDimensions.width - marginLeft) / timeSig.getBeats()

    var oldBaseline = ctx.textBaseline,
      oldFillStyle = ctx.fillStyle,
      oldFont = ctx.font

    ctx.textBaseline = 'top' // font for chords
    ctx.font = fontChords
    ctx.fillStyle = this.color

    var chordX = getChordX(this.chord.getBeat(), barDimensions, beatWidth)
    ctx.fillText(this.chord.toString(), chordX, barDimensions.top - chordsY)
    var boundingBox = boundingBoxFn
      ? boundingBoxFn(ctx, this.chord.toString(), chordX, barDimensions.top - chordsY)
      : undefined

    ctx.textBaseline = oldBaseline
    ctx.font = oldFont
    ctx.fillStyle = oldFillStyle

    return boundingBox
  }

  return LSChordView
})
define('modules/LSViewer/src/LSBarView', ['vexflow'], function (Vex) {
  /**
   * LSBarView is a module called by CanvasLayer to draw bars
   * @exports LSViewer/LSBarView
   */
  function LSBarView(barDimensions, options) {
    this.vexflowStave = new Vex.Flow.Stave(barDimensions.left, barDimensions.top, barDimensions.width, options)
    this.drawClef = !!options.draw_clef
    this.drawKeySignature = !!options.draw_key_signature
    this.drawStaveNumbers = options.draw_stave_numbers === undefined ? true : !!options.draw_stave_numbers
  }

  LSBarView.prototype.draw = function (ctx, songIt, sectionIt, endingsY, labelsY) {
    if (songIt.getBarIndex() === 0 && this.drawClef) {
      this.vexflowStave.addClef('treble').setContext(ctx).draw()
    }
    //name section
    if (sectionIt.getBarIndex() === 0) {
      var nameSection = sectionIt.getSection().getName()
      var repeatSection = parseInt(sectionIt.getSection().getRepeatTimes(), 10) + 1
      var textRepeatSection = ''
      if (repeatSection > 1) {
        textRepeatSection += ' (x' + repeatSection + ')'
      }
      if (nameSection !== '') {
        this.vexflowStave.setSection(nameSection + textRepeatSection, 9)
      }
    }

    //Bar number
    if (this.drawStaveNumbers === true) {
      ctx.font = '10px Verdana' // font for staves number
      ctx.fillStyle = '#900'
      var position = this.getVexflowStave()
      ctx.fillText(songIt.getBarIndex() + 1, position.x + 3, position.y + 37)
      ctx.fillStyle = '#000'
      ctx.font = '18px Verdana'
    }

    var keySignatureString = songIt.getBarKeySignature()
    if (keySignatureString != songIt.getPrevKeySignature() && this.drawKeySignature) {
      var keySignature = new Vex.Flow.KeySignature(keySignatureString)
      var prevKeySignature = songIt.getPrevKeySignature()
      // see https://github.com/0xfe/vexflow/issues/335
      if (prevKeySignature !== null && prevKeySignature !== 'C') {
        keySignature.cancelKey(prevKeySignature)
      }
      keySignature.addToStave(this.vexflowStave)
    }

    var timeSignature = songIt.getBarTimeSignature()

    if (timeSignature.toString() != songIt.getPrevTimeSignature()) {
      this.vexflowStave.addTimeSignature(timeSignature.toString())
    }

    var bar = songIt.getBar(),
      followingBar = songIt.getFollowingBar(),
      ending = bar.getEnding()
    // endings
    if (ending) {
      songIt.setEndingState(sectionIt.isLastBar() || followingBar.getEnding() ? 'BEGIN_END' : 'BEGIN')
      this.vexflowStave.setVoltaType(Vex.Flow.Volta.type[songIt.getEndingState()], ending + '.', endingsY)
    } else {
      if (songIt.getEndingState() != null) {
        if (sectionIt.isLastBar() || followingBar.getEnding()) {
          songIt.setEndingState('END')
          if (!sectionIt.isLastBar()) {
            this.vexflowStave.setEndBarType(Vex.Flow.Barline.type.REPEAT_END)
          }
          this.vexflowStave.setVoltaType(Vex.Flow.Volta.type[songIt.getEndingState()], ending + '.', endingsY)
          songIt.setEndingState(null)
        } else if (songIt.getEndingState() == 'BEGIN' || songIt.getEndingState() == 'MID') {
          songIt.setEndingState('MID')
          this.vexflowStave.setVoltaType(Vex.Flow.Volta.type[songIt.getEndingState()], ending + '.', endingsY)
        }
      }
    }
    if (sectionIt.isLastBar()) {
      songIt.setEndingState(null)
    }

    var label = bar.getLabel()
    if (label === 'coda' || label === 'coda2') {
      this.vexflowStave.setRepetitionTypeRight(Vex.Flow.Repetition.type.CODA_RIGHT, labelsY)
    }
    if (label === 'segno' || label === 'segno2') {
      this.vexflowStave.setRepetitionTypeRight(Vex.Flow.Repetition.type.SEGNO_RIGHT, labelsY)
    }
    var sublabel = bar.getSublabel(true)
    if (sublabel != null) {
      this.vexflowStave.setRepetitionTypeRight(Vex.Flow.Repetition.type[sublabel], labelsY)
    }
    if (sectionIt.isLastBar()) {
      this.vexflowStave.setEndBarType(Vex.Flow.Barline.type.END)
    }
    this.vexflowStave.setContext(ctx).draw()
  }
  LSBarView.prototype.getKeySignature = function () {
    return this.keySignature
  }
  LSBarView.prototype.getVexflowStave = function () {
    return this.vexflowStave
  }

  return LSBarView
})
define('modules/LSViewer/src/BeamManager', ['vexflow'], function (Vex) {
  /**
   *
   * @exports LSViewer/BeamManager
   */
  function BeamManager() {
    this.beams = [] //array of arrays of vexflow notes, each array of vxfNotes represents a beam group
    this.counter = 0
    this.lastNoteBeat = -1
  }

  /**
   * saves information for later drawing beams: it is set in this.beams
   * @param  {NoteManagerModel} noteMng
   * @param  {Number} iNote    index of note
   * @param  {LSNoteView} noteView
   */
  BeamManager.prototype.checkBeam = function (noteMng, iNote, noteView) {
    /**
     * isSameBeat: for now we just consider beaming at quarter beat level (in the future we may decide beaming level dependign on time signature )
     * @param  {Number}  beat1
     * @param  {Number}  beat2
     * @return {Boolean}
     */
    function isSameBeat(beat1, beat2) {
      return Math.floor(beat1) == Math.floor(beat2)
    }

    var noteBeat
    if (noteView.isBeamable()) {
      noteBeat = noteMng.getNoteBeat(iNote)
      //new position for beam array when they are not in same beat
      if (!isSameBeat(noteBeat, this.lastNoteBeat)) {
        //if length is not > 1, it means that we had a lonely beamable note, so we won't beam it
        //thus, we don't increment counter -> we overwrite position
        if (this.beams[this.counter] && this.beams[this.counter].length > 1) {
          this.counter++
        }
        this.beams[this.counter] = []
      }
      var vexflowNote = noteView.getVexflowNote()

      this.beams[this.counter].push(vexflowNote)
      this.lastNoteBeat = noteBeat
    }
  }

  /**
   * 	@return {Array} Array of Vex.Flow.Beam (generate from information in array this.beams) needed to draw
   */
  BeamManager.prototype.getVexflowBeams = function () {
    var vexflowBeams = []
    for (var j = 0; j < this.beams.length; j++) {
      if (this.beams[j] && this.beams[j].length > 1)
        vexflowBeams[j] = new Vex.Flow.Beam(this.beams[j], true) //auto_stem true
      else vexflowBeams[j] = null
    }
    return vexflowBeams
  }

  /**
   * 	draws beams
   * @param  {Context} ctx
   * @param  {Array} vxfBeams  Array of Vex.Flow.Beam
   */
  BeamManager.prototype.draw = function (ctx, vxfBeams) {
    for (var j = 0, c = vxfBeams.length; j < c; j++) {
      if (vxfBeams[j] !== null) vxfBeams[j].setContext(ctx).draw()
    }
  }

  return BeamManager
})
define('modules/LSViewer/src/TieManager', ['vexflow'], function (Vex) {
  /**
   * LSBarView is a module called by LSViewer to draw tie notes
   * @exports LSViewer/TieManager
   */
  function TieManager() {
    this.ties = []
    this.numTies = 0
    this.prevTieType = null
  }
  /**
   * saves information for drawing ties
   * @param  {NoteModel} note
   * @param  {Number} iNote index of note
   */
  TieManager.prototype.checkTie = function (note, iNote) {
    var tieType

    if (note.isTie()) {
      tieType = note.getTie()
      if (tieType == 'start') {
        this.ties[this.numTies] = []
        this.ties[this.numTies].push(iNote)
      } else {
        // (tieType=="stop" || tieType=="stop_start"){

        if (this.prevTieType == 'stop' || this.prevTieType === null) {
          this.ties[this.numTies] = []
          this.ties[this.numTies].push(null)
        }
        this.ties[this.numTies].push(iNote)
        this.numTies++
      }
      if (tieType == 'stop_start') {
        this.ties[this.numTies] = []
        this.ties[this.numTies].push(iNote)
      }
      this.prevTieType = tieType
    }
  }
  /**
   * @param  {Context} ctx
   * @param  {Array} noteViews of LSNoteView
   * @param  {NoteManagerModel} nm
   */
  TieManager.prototype.draw = function (ctx, noteViews, nm, barWidthMng, song) {
    function drawTie(note1, note2) {
      var vxTie = new Vex.Flow.StaveTie({
        first_note: note1,
        last_note: note2,
      })
      vxTie.setContext(ctx)
      vxTie.draw()
    }
    var iNoteTieStart, iNoteTieEnd, iTieStartBar, iTieEndBar, auxStartNote

    for (var i in this.ties) {
      iNoteTieStart = this.ties[i][0]
      iNoteTieEnd = this.ties[i][1]

      auxStartNote = noteViews[iNoteTieStart].getVexflowNote()

      iTieStartBar = nm.getNoteBarNumber(iNoteTieStart, song)
      iTieEndBar = nm.getNoteBarNumber(iNoteTieEnd, song)

      if (!barWidthMng.inSameLine(iTieStartBar, iTieEndBar)) {
        drawTie(auxStartNote, null)
        auxStartNote = null
      }
      drawTie(auxStartNote, noteViews[iNoteTieEnd].getVexflowNote())
    }
  }

  return TieManager
})
define('modules/LSViewer/src/TupletManager', ['vexflow'], function (Vex) {
  /**
   * LSBarView is a module called by LSViewer to draw tuplet notes
   * @exports LSViewer/TupletManager
   */
  function TupletManager() {
    this.tuplets = []
    this.numTuplets = 0
    this.prevTieType = null
  }
  /**
   * saves information for drawing tuplets later
   * @param  {NoteModel} note
   * @param  {Number} iNote index of note
   */
  TupletManager.prototype.checkTuplet = function (note, iNote) {
    var tuplet = note.getTuplet(),
      isTuplet
    if (tuplet != null) {
      if (tuplet == 'start') {
        isTuplet = 1
        this.numTuplets++
        this.tuplets[this.numTuplets] = []
        this.tuplets[this.numTuplets][0] = iNote
      } else if (tuplet == 'stop') {
        //'stop'
        this.tuplets[this.numTuplets][1] = iNote
      }
    }
  }
  /**
   * @param  {Context} ctx
   * @param  {Array} noteViews Array of Vex.Flow.StaveNote
   */
  TupletManager.prototype.draw = function (ctx, noteViews) {
    function convertToVxfNotes(noteViews) {
      var vxfNotes = []
      for (var i in noteViews) {
        vxfNotes.push(noteViews[i].getVexflowNote())
      }
      return vxfNotes
    }
    var vexflowTuplet, tupletNotes
    for (var i in this.tuplets) {
      tupletNotes = noteViews.slice(this.tuplets[i][0], this.tuplets[i][1] + 1)
      vexflowTuplet = new Vex.Flow.Tuplet(convertToVxfNotes(tupletNotes))
      vexflowTuplet.setContext(ctx).draw()
    }
  }

  return TupletManager
})
define('modules/LSViewer/src/BarWidthManager', [
  'modules/core/src/SongBarsIterator',
  'modules/core/src/SectionBarsIterator',
], function (SongBarsIterator, SectionBarsIterator) {
  /**
   *
   * @exports LSViewer/BarWidthManager
   */
  function BarWidthManager(lineHeight, lineWidth, noteWidth, barsPerLine, marginTop, lastBarWidthRatio) {
    if (lineHeight === undefined) throw 'BarWidthManager - lineHeight not defined'
    if (lineWidth === undefined) throw 'BarWidthManager - lineWidth not defined'
    if (noteWidth === undefined) throw 'BarWidthManager - noteWidth not defined'
    if (barsPerLine === undefined) throw 'BarWidthManager - barsPerLine not defined'
    if (marginTop === undefined) throw 'BarWidthManager - marginTop not defined'

    this.lastBarWidthRatio = lastBarWidthRatio || 1

    this.WIDTH_FACTOR = 1.6 // factor by which we multiply the minimum width so that notes are not so crammed (always > 1)
    this.barsStruct = []

    this.lineHeight = Number(lineHeight)
    this.lineWidth = Number(lineWidth)
    this.noteWidth = Number(noteWidth)
    this.barsPerLine = Number(barsPerLine)
    this.marginTop = Number(marginTop)
  }
  /**
   * calculates the minimum width for each bar depending on the number of notes it has
   * @param  {SongModel} song
   * @param  {NoteManagerModel} noteMng
   * @param  {CanvasContext} ctx
   * @param  {String} font chords. ex: "18px verdana"
   *
   * last two params are needed if we are drawing chord symbols
   * @return {Array} of minimum widths    e.g.: [200,200,100,100,100,200,]
   */
  BarWidthManager.prototype.getMinWidthList = function (song, noteMng, chordsMng, ctx, fontChord) {
    var self = this,
      width,
      minWidthList = [],
      barNotes,
      barChords,
      sectionIt,
      chordWidth,
      diff,
      maxDiff,
      chord,
      marginChordFactor = 1.15 //always should be greater than 1
    var oldCtxFont = ctx.font

    ctx.font = fontChord
    var songIt = new SongBarsIterator(song)

    song.getSections().forEach(function (section) {
      sectionIt = new SectionBarsIterator(section)
      while (sectionIt.hasNext()) {
        //get minimum notes width
        barNotes = noteMng.getNotesAtCurrentBar(songIt)
        width = barNotes.length * self.noteWidth * self.WIDTH_FACTOR

        //get minimum chords width. strategy: we check if any chords of bar are longer than the space assigned for them,
        //if there are one or more, we get the longest difference and we widen ALL beats (this way we keep consistency between chord duration and chord space)
        chordWidth = width / songIt.getBarTimeSignature().getBeats()

        barChords = chordsMng.getChordsByBarNumber(songIt.getBarIndex())
        maxDiff = 0
        for (var i = 0; i < barChords.length; i++) {
          chord = barChords[i]
          //if chord is in last beat of measure or there is only one beat difference between next
          if (
            chord.getBeat() == barChords.length - 1 ||
            (i < barChords.length - 1 && chord.getBeat() == barChords[i + 1].getBeat() - 1)
          ) {
            //we check if should be longer
            diff = ctx.measureText(chord.toString()).width - chordWidth
            if (diff > 0 && diff > maxDiff) {
              maxDiff = diff
            }
          }
        }
        if (maxDiff !== 0) {
          //here we widen ALL beats a maxDiff
          width += maxDiff * marginChordFactor * songIt.getBarTimeSignature().getBeats()
        }
        minWidthList.push(width)
        songIt.next()
        sectionIt.next()
      }
    })
    ctx.fond = oldCtxFont

    return minWidthList
  }

  /**
   * decides which bars go into which line depending on the width, constraints are: can't be wider than lineWidth
   * @param  {Array} minWidthList  minimum width for each bar. e.g.: [200,200,500,500, 300,100,100,100]
   * @return {Array}	Array 2-dimensions, matrix in which each line represents a line on the score,
   * and the width for each bar fitting in the line. e.g. (being the line width 1160) [	[200,200,500],		( sum of widths is < 1160)
   *																						[500,300,100,100,100]	(< 1160)
   */
  BarWidthManager.prototype.assignBarsToLines = function (minWidthList, pickupAtStart) {
    /**
     * @param  {Array} bars
     * @param  {Integer} to   0 based index
     * @return {Integer}
     */
    function calculateWidth(bars, to) {
      var totalWidth = 0
      for (var i = 0; i <= to; i++) {
        totalWidth += bars[i]
      }
      return totalWidth
    }

    var numBarsProcessed = 0,
      lineMinWidths
    var widthsByLine = [],
      lineWidthList,
      barWidth = this.lineWidth / this.barsPerLine,
      i,
      barsToGet,
      numCarriedBars = 0,
      numCurrLastBar

    while (numBarsProcessed < minWidthList.length || numCarriedBars !== 0) {
      lineWidthList = []
      barsToGet = this.barsPerLine + numCarriedBars
      if (pickupAtStart && numBarsProcessed === 0) {
        barsToGet++
      }

      numCurrLastBar = numBarsProcessed + barsToGet

      lineMinWidths = minWidthList.slice(numBarsProcessed, numBarsProcessed + barsToGet)
      numCarriedBars = 0

      var lastBarIncluded = lineMinWidths.length - 1
      var exceedsTotal = true
      while (exceedsTotal && lastBarIncluded >= 0) {
        // we check every time if all widths fit in line
        if (calculateWidth(lineMinWidths, lastBarIncluded) < this.lineWidth) {
          // if they fit, we save them in lineWidthList
          exceedsTotal = false
          for (i = 0; i <= lastBarIncluded; i++) lineWidthList[i] = lineMinWidths[i]
        } else {
          //if not, we take out iteratively last one and put as carry for the next line
          if (lastBarIncluded > 0) {
            numCarriedBars++
            lineMinWidths.pop()
            lastBarIncluded--
          } else {
            // except if there are no widths left to take out. In that case it means that one width is already higher than lineWidth,
            // in this case we save it as lineWidth (we'll may see crammed bar notes, but we can't make lines wider than linWidth,  this is an exceptional case)
            lineWidthList.push(this.lineWidth)
            exceedsTotal = false
          }
        }
      }
      widthsByLine.push(lineWidthList)
      numBarsProcessed += lineMinWidths.length
    }
    return widthsByLine
  }
  /**
   * Gets the final widths by recalculating them depending on whether there are bars which are too wide, and making flexible the rest of bars
   * @param  {Array} minWidthsPerLine  [	[200,200,500],		( sum of widths is < 1160)
   *                                   [500,300,100,100,100]	(< 1160)
   *                                    ]
   *																					]
   * @return {Array}                 array (2-dimensions) with final widths that will be used to draw
   */
  BarWidthManager.prototype.getWidths = function (minWidthsPerLine) {
    /**
     * [getIndexOfWidthsExceedingMean description]
     * @param  {Array} lineWidthList list of widths in one line
     * @param  {Number} meanWidth
     * @return {Array}               indexes of widths that exceede the meanWidth
     */
    function getIndexOfWidthsExceedingMean(lineWidthList, meanWidth) {
      var indexes = []
      for (var i = 0; i < lineWidthList.length; i++) {
        if (lineWidthList[i] > meanWidth) indexes.push(i)
      }
      return indexes
    }
    /**
     * @param  {Integer} lengthArray
     * @return {Array}
     */
    function createZeroArray(lengthArray) {
      var zeroArray = []
      for (var i = 0; i < lengthArray; i++) {
        zeroArray[i] = 0
      }
      return zeroArray
    }

    /**
     * sets the widths on the line depending on the minimum widths (central part of getWidths)
     * @param {Array} minLineWidthList , array of one dimension representing the withs of one line
     * @param {Integer} lineWidth
     */
    function setLineWidthList(minLineWidthList, lineWidth) {
      var numWidths = minLineWidthList.length // number of widths (i.e. of bars)  this line has
      var lineWidthList = createZeroArray(numWidths) //list of widths to return, initialized to 0

      var meanWidth = lineWidth / minLineWidthList.length // if everything normal (no too wide bars), all bars should have meanWidth
      var indexes = getIndexOfWidthsExceedingMean(minLineWidthList, meanWidth) // we get indexes of bars that are too wide

      // in bars which are too wide, we set the original value, we also calculate the total with the wide bars take
      var takenWidth = 0
      for (var i = 0; i < indexes.length; i++) {
        lineWidthList[indexes[i]] = minLineWidthList[indexes[i]]
        takenWidth += minLineWidthList[indexes[i]]
      }

      var numWidthsLessMean = numWidths - indexes.length // number of bars that are not too wide
      var totalWidthLessMean = lineWidth - takenWidth //  total remaining width

      //all bars that are not too wide will have same standard width
      var standardWidth = Math.round((totalWidthLessMean / numWidthsLessMean) * 1000) / 1000

      // we set the standard width to bars that are not too wide
      for (i = 0; i < lineWidthList.length; i++) {
        if (lineWidthList[i] === 0) lineWidthList[i] = standardWidth
      }
      return lineWidthList
    }

    var finalWidths = [],
      lineFinalWidths

    for (var i = 0; i < minWidthsPerLine.length; i++) {
      lineFinalWidths = setLineWidthList(minWidthsPerLine[i], this.lineWidth)
      finalWidths.push(lineFinalWidths)
    }

    //we shorten last bar by lastBarWidthRatio
    var lastRow = finalWidths.length - 1,
      lastColumn = finalWidths[lastRow].length - 1
    finalWidths[lastRow][lastColumn] *= this.lastBarWidthRatio
    return finalWidths
  }
  BarWidthManager.prototype.setBarsStruct = function (barsStruct) {
    this.barsStruct = barsStruct
  }
  /**
   * Decides which bar goes into which line depending on its width, and sets the final width depending on the distribution of bars among lines
   * @param {SongMoel} song
   * @param {NoteManagerModel} noteMng [description]
   */

  BarWidthManager.prototype.calculateBarsStructure = function (song, noteMng, chordsMng, ctx, fontChords) {
    var minWidthList = this.getMinWidthList(song, noteMng, chordsMng, ctx, fontChords)
    var pickupAtStart
    if (typeof song.getSection(0) !== 'undefined') {
      pickupAtStart = song.getSection(0).getNumberOfBars() == 1
    }
    var minWidthPerLineList = this.assignBarsToLines(minWidthList, pickupAtStart)
    this.setBarsStruct(this.getWidths(minWidthPerLineList))
  }

  /**
   * returns top,left and width of a given bar. Used when drawing
   * @param  {Integer} numBar
   * @return {Object} {
   *						top: topValue,
   *						left: leftValue,
   *						width: widthValue
   *					}
   */
  BarWidthManager.prototype.getDimensions = function (numBar) {
    var i,
      j,
      currentNumBar = 0,
      currentLine = 0,
      left = 0
    for (i = 0; i < this.barsStruct.length; i++) {
      for (j = 0; j < this.barsStruct[i].length; j++) {
        if (currentNumBar == numBar) {
          return {
            left: left,
            width: this.barsStruct[i][j],
            top: currentLine * this.lineHeight + this.marginTop,
            height: this.lineHeight,
          }
        }
        currentNumBar++
        left += this.barsStruct[i][j]
      }
      left = 0
      currentLine++
    }
  }

  BarWidthManager.prototype.inSameLine = function (iBar1, iBar2) {
    var numBar = 0,
      line1 = -1,
      line2 = -1
    labelMainFor: for (var line = 0; line < this.barsStruct.length; line++) {
      for (var j = 0; j < this.barsStruct[line].length; j++) {
        if (numBar == iBar1) line1 = line
        if (numBar == iBar2) line2 = line
        if (line1 != -1 && line2 != -1) break labelMainFor
        numBar++
      }
    }
    return line1 == line2
  }
  return BarWidthManager
})
/**
 * CanvasLayer is a canvas place on top of the basic canvas to manage edition and to draw elements such as cursors (to optimize rendering)
 * @param {LSViewer} viewer
 */
define('modules/LSViewer/src/CanvasLayer', ['jquery', 'pubsub'], function ($, pubsub) {
  /**
   * Canvas layer module manages fast drawn interaction,
   * it creates an hover canvas that is fast and repetively drawn, it's usefull to draw cursor or selection for eg
   * @exports LSViewer/CanvasLayer
   */
  function CanvasLayer(viewer, detectEventOnAllDocument, interactiveCanvasLayer) {
    if (!viewer.canvas) {
      throw 'LSViewer cannot create layer because canvas does not exist'
    }

    this.viewer = viewer
    var canvasLayer = this._createLayer(viewer)
    this.canvasLayer = canvasLayer[0]
    this.ctx = canvasLayer[0].getContext('2d')
    this.color = 'rgba(0,0,255,1)'
    this.mouseCoordsIni = null
    this.mouseCoordsEnd = null
    this.coords = {}
    this.mouseDown = false
    this.detectEventOnAllDocument = detectEventOnAllDocument !== undefined ? detectEventOnAllDocument : false
    if (interactiveCanvasLayer) this._listenEvents(canvasLayer)
    this.elems = {} //elements to be added (can be CLICKABLE or CURSOR)
    this.order = [] //we keep trace of order in which elements are added, to decide which should be prioritized on click
    this.ctrlPressed = false
  }

  CanvasLayer.prototype._createLayer = function (viewer) {
    var canvasEl = $(viewer.canvas),
      idCanvas = canvasEl.attr('id'),
      idLayer = idCanvas + '-layer',
      offset = canvasEl.offset(),
      //top depends on the position (absolute, static..) of the canvas container element
      top = canvasEl.parent().css('position') == 'absolute' ? 0 : offset.top

    var layersProps = {
      position: 'absolute',
      left: offset.left,
      top: top,
    }
    var canvasLayer
    //we remove it, to create a new one (_createLayer it's called only at the beginning or when resizing)
    if ($('canvas#' + idLayer).length !== 0) {
      $('canvas#' + idLayer).remove()
    }
    $(
      "<canvas id='" + idLayer + "' width='" + canvasEl.width() + "' height='" + canvasEl.height() + "'></canvas>"
    ).insertAfter(canvasEl)
    canvasLayer = $('#' + idLayer)
    canvasLayer.css(layersProps)
    canvasLayer.css('z-index', 10)
    return canvasLayer
  }

  CanvasLayer.prototype._getXandY = function (element, event) {
    return {
      x: event.pageX - element.offset().left,
      y: event.pageY - element.offset().top,
    }
  }

  /**
   * Element should have properties:
   *		CL_NAME
   *		CL_TYPE
   *	methods:
   *		getType
   *		iEnabled
   *		enable
   *		disable
   *		onSelected
   *		inPath
   *
   * CLICKABLE elements will be enabled always, but 'disable' function is useful for example to simulate event 'onBlur' when unfocusing element
   *
   * CL_TYPE can be 'CURSOR' or 'CLICKABLE' or 'NOT_INTERACTIVE'
   * if it's CURSOR, it needs to have also this methods:
   *		getYs
   *		name
   *		drawCursor
   *		setCursorEditable
   */
  CanvasLayer.prototype.addElement = function (elem, priority) {
    if (!elem || !elem.CL_NAME || !elem.getType()) {
      throw 'CanvasLayer element needs CL_NAME and CL_TYPE property'
    }
    var self = this

    function addOrderedElemName(elemName, priority) {
      if (priority) {
        self.order.unshift(elemName) //we put it in the first position
      } else {
        self.order.push(elemName)
      }
    }
    // if it's new, we save its order
    if (!(elem.CL_NAME in this.elems)) {
      addOrderedElemName(elem.CL_NAME, priority)
      //order is useful to control z-index of drawn elements, last drawn elements will be prioritized on click. (see getOneActiveElement())
    }
    //this will update it if not new, and will create the value in the object if it is new. We were having problems when entering it only when it was not new, because
    //audioComments where not updated
    this.elems[elem.CL_NAME] = elem
  }

  CanvasLayer.prototype._listenEvents = function () {
    var self = this,
      xy,
      coords
    this.mouseDown = false
    /**
     * when selecting we need to know which kind of elements (being normally notes, chords or audio), are at the top and at the bottom of the selection.
     * We will decide by that, which elements will be editable. So far, we take maximum two.
     * E.g.1 if notes at top and notes at bottom of selection, we only enable edition for notes (even if there are chords in the middle)
     * E.g.2 if notes at top and chords at bottom of selection, we enable edition on notes and chords at the same time.
     * @param  {Object} coords e.g.:  {x:12, y:21}
     *
     * @return {Array}        array of active elements (being elements like ChordSpaceManager, NoteSpaceManager, WaveDrawer. TextElementManager will never be returned because it is not selectable (it does not have getY() function), it is only thought for being clicked)
     */
    function getElemsByYs(coords) {
      var minY = 999999,
        maxY = 0,
        minName,
        maxName,
        ys
      var activeElems = []
      for (var name in self.elems) {
        if (self.elems[name].getType() === 'CURSOR') {
          ys = self.elems[name].getYs(coords)
          if (ys.topY < minY) {
            minY = ys.topY
            minName = name
          }
          if (ys.bottomY > maxY) {
            maxY = ys.bottomY
            maxName = name
          }
        }
      }
      if (minName) {
        activeElems.push(self.elems[minName])
      }
      if (maxName && minName != maxName) {
        activeElems.push(self.elems[maxName])
      }
      return activeElems
    }
    /**
     * when clicking on an element we will select one only element, this function chooses which one depending on coords
     * @param  {Object} coords  e.g.:  {x:12, y:21}
     * @return {Object}        class of active element (ChordSpaceManager, NoteSpaceManager, WaveDrawer. TextElementManager...etc.)
     */
    function getOneActiveElement(coords) {
      var name, elem

      for (var i = 0; i < self.order.length; i++) {
        name = self.order[i]
        elem = self.elems[name]
        if (elem.getType() !== 'NOT_INTERACTIVE' && elem.inPath(coords)) {
          return [elem]
        }
      }
    }

    function resetElems() {
      for (var name in self.elems) {
        if (self.elems[name].getType() == 'CURSOR') {
          self.elems[name].setCursorEditable(false)
        }
        self.elems[name].disable()
      }
    }

    /**
     * [selection description]
     * @param  {Boolean} clicked true when clicked (mouseDown and mouseUp in same position) false when moved mouse onMouseDown
     */
    function selection(clicked, mouseUp) {
      var cursorPos
      if (!self.ctrlPressed) {
        resetElems()
      }
      var activElems
      if (clicked) {
        activElems = getOneActiveElement(self.coords)
      } else {
        activElems = getElemsByYs(self.coords)
      }
      for (var i in activElems) {
        activElems[i].onSelected(
          self.coords,
          self.mouseCoordsIni,
          self.mouseCoordsEnd,
          clicked,
          mouseUp,
          self.ctrlPressed
        )
        if (activElems[i].getType() == 'CURSOR') {
          activElems[i].setCursorEditable(true)
        }
        activElems[i].enable()
      }
      self.refresh()
    }

    /**
     * cursor set to pointer to indicate when an element is clickable. Before it was managed by each element edition class (notes,chords...etc.) but we moved it here
     * because it has to be centralized otherwise events were interfering to each other (notes pointer when mouse is over notes would not work if at the same time chords editor asks to set pointer to default when mouse is not over chords)
     * @param {Object} xy  e.g.:  {x:12, y:21}
     */
    function setPointerIfInPath(xy) {
      if (typeof self.viewer.divContainer.style !== 'undefined') {
        var found = false
        for (var name in self.elems) {
          if (typeof self.elems[name].inPath !== 'function') {
            continue
          }
          if (self.elems[name].inPath(xy)) {
            self.viewer.divContainer.style.cursor = 'pointer'
            found = true
          }
        }
        if (!found) {
          self.viewer.divContainer.style.cursor = 'default'
        }
      }
    }

    if (this.detectEventOnAllDocument) {
      $('html').on('mousedown', function (evt) {
        mouseDown(evt)
        //evt.stopImmediatePropagation();
      })
      // Mouseup on canvas is usefull to allow unselect
      $('html').on('mouseup', function (evt) {
        mouseUp(evt)
        //evt.stopImmediatePropagation();
      })
    } else {
      $(this.canvasLayer).mousedown(function (evt) {
        mouseDown(evt)
      })
      // Mouseup on canvas is usefull to allow unselect
      $(this.canvasLayer).mouseup(function (evt) {
        mouseUp(evt)
      })
    }

    function mouseDown(evt) {
      var d = evt.srcElement || evt.target
      if (
        d.tagName.toUpperCase() === 'TEXTAREA' ||
        d.tagName.toUpperCase() === 'INPUT' ||
        d.tagName.toUpperCase() === 'SELECT' ||
        d.tagName.toUpperCase() === 'OPTION'
      ) {
        return
      }
      coords = self._getXandY($(self.canvasLayer), evt)
      self.mouseCoordsIni = [coords.x, coords.y]
      self._setCoords(self.mouseCoordsIni, self.mouseCoordsIni)
      self.mouseDown = true
    }

    function mouseUp(evt) {
      self.mouseDown = false
      var isClick = self.mouseDidntMove()
      if (isClick && evt.button == 2) {
        // $.publish('right-click');
      } else {
        if (isTargetValid(evt)) {
          selection(isClick, true)
        }
      }
    }
    // check if we click on something that is canvas or that contain canvas to prevent click on something that is above a player or menu etc
    function isTargetValid(evt) {
      if (evt.target.id === $(self.canvasLayer).attr('id') || $(evt.target).find($(self.canvasLayer)).length > 0) {
        return true
      }
      return false
    }

    $('html').on('mousemove', function (evt) {
      //draw cursor selection
      var xy = self._getXandY($(self.canvasLayer), evt)
      if (self.mouseDown) {
        var ctx = self.ctx
        self.mouseCoordsEnd = [xy.x, xy.y]
        self._setCoords(self.mouseCoordsIni, self.mouseCoordsEnd)
        self._clampCoords($(self.canvasLayer))
        if (isTargetValid(evt)) {
          selection()
        }
      }
      setPointerIfInPath(xy)
    })
    $.subscribe('ctrlPressed', function (el) {
      self.ctrlPressed = true
    })
    $.subscribe('ctrlUnpressed', function (el) {
      self.ctrlPressed = false
    })
    $.subscribe('CanvasLayer-refresh', function (el) {
      self.refresh()
    })
  }

  /**
   * true if position on mouseDown is the same (or almost) as position on mouseUp
   * @return {Booelan}
   */
  CanvasLayer.prototype.mouseDidntMove = function () {
    return Math.abs(this.coords.x - this.coords.xe) < 5 && Math.abs(this.coords.y - this.coords.ye) < 5
  }

  CanvasLayer.prototype._clampCoords = function (element) {
    xeElement = element.width()
    yeElement = element.height()
    if (this.coords.x < 0) {
      this.coords.x = 1
    }
    if (this.coords.y < 0) {
      this.coords.y = 1
    }
    if (this.coords.xe > xeElement) {
      this.coords.xe = Math.floor(xeElement) - 1
    }
    if (this.coords.ye > yeElement) {
      this.coords.ye = Math.floor(yeElement) - 1
    }
  }

  CanvasLayer.prototype._setCoords = function (mouseCoordsIni, mouseCoordsEnd) {
    function get(xory, type) {
      var evaluation
      var num = xory == 'x' ? 0 : 1
      if (type == 'smaller') evaluation = mouseCoordsIni[num] < mouseCoordsEnd[num]
      else if (type == 'greater') evaluation = mouseCoordsIni[num] > mouseCoordsEnd[num]
      return evaluation ? mouseCoordsIni[num] : mouseCoordsEnd[num]
    }
    this.coords.x = get('x', 'smaller')
    this.coords.y = get('y', 'smaller')
    this.coords.xe = get('x', 'greater')
    this.coords.ye = get('y', 'greater')
  }

  CanvasLayer.prototype.getCanvas = function () {
    return this.canvasLayer
  }

  /**
   * Refresh canvas layer: all elements in canvas layer should be elements cursors or elements that change fast
   */
  CanvasLayer.prototype.refresh = function () {
    //console.log('refresh');
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
    this.viewer.scale(this.ctx)
    // console.log(name1+","+name2);
    // console.log(this.elems);
    var elem
    for (var name in this.elems) {
      elem = this.elems[name]
      if (elem.isEnabled() && (elem.getType() === 'CURSOR' || elem.getType() === 'NOT_INTERACTIVE')) {
        //drawing cursor for notesManager, chordsManager and AudioCursor (selection cursor)
        elem.drawCursor(this.ctx)
      }
      //TODO refactor, drawCursor only exists in AudioCursor to draw playing cursor
      if (typeof elem.drawPlayingCursor === 'function') {
        elem.drawPlayingCursor(this.ctx)
      }
    }
    this.viewer.resetScale(this.ctx)
    if (this.mouseDown) {
      var style = this.ctx.strokeStyle
      this.ctx.strokeStyle = this.color
      this.ctx.strokeRect(this.coords.x, this.coords.y, this.coords.xe - this.coords.x, this.coords.ye - this.coords.y)
      this.ctx.strokeStyle = style
    }
  }
  CanvasLayer.prototype.destroy = function () {
    $('html').off('mousedown')
    $('html').off('mouseup')
    $('html').off('mousemove')
    $.unsubscribe('ctrlPressed')
    $.unsubscribe('ctrlUnpressed')
    $.unsubscribe('CanvasLayer-refresh')
  }
  return CanvasLayer
})
define('modules/LSViewer/src/Scaler', [], function () {
  /**
   * Scaler helps decoupling from LSViewer all classes that have to scale
   * @exports LSViewer/Scaler
   * @param {Float} scaler that will be multiplied by all positions
   */
  function Scaler(scale) {
    if (scale) {
      this.setScale(scale)
    }
  }
  Scaler.prototype.setScale = function (scale) {
    this.scale = scale
  }
  /**
   * function to scale plain objects, normally they will be positions
   * @param  {Object} obj normally in the form of {x: 23, y:130, xe: 33, ye: 23}
   * @return {Object} in the form of {x: 23, y:130, xe: 33, ye: 23}
   */
  Scaler.prototype.getScaledObj = function (obj) {
    if (obj instanceof Object) {
      var r = {}
      for (var prop in obj) {
        r[prop] = obj[prop] * this.scale
      }
      return r
    } else if (!isNaN(parseFloat(obj)) && isFinite(obj)) {
      return obj * this.scale
    } else {
      throw 'Scaler only accept obj or number'
    }
  }
  return Scaler
})
define('modules/LSViewer/src/LSViewer', [
  'vexflow',
  'modules/LSViewer/src/LSNoteView',
  'modules/NoteEdition/src/NoteSpaceView',
  'modules/LSViewer/src/LSChordView',
  'modules/LSViewer/src/LSBarView',
  'modules/LSViewer/src/BeamManager',
  'modules/LSViewer/src/TieManager',
  'modules/LSViewer/src/TupletManager',
  'modules/LSViewer/src/BarWidthManager',
  'modules/core/src/SectionBarsIterator',
  'modules/core/src/SongBarsIterator',
  'modules/LSViewer/src/CanvasLayer',
  'modules/LSViewer/src/Scaler',
  'jquery',
  'pubsub',
], function (
  Vex,
  LSNoteView,
  NoteSpaceView,
  LSChordView,
  LSBarView,
  BeamManager,
  TieManager,
  TupletManager,
  BarWidthManager,
  SectionBarsIterator,
  SongBarsIterator,
  CanvasLayer,
  Scaler,
  $,
  pubsub
) {
  /**
   * LSViewer module manage interaction between canvas, core model and vexflow, it's the main module that allow drawing
   * @exports LSViewer/LSViewer
   * @param {domObject} jQuery divContainer ; e.g.: $("#divContainerId");
   * @param {Object} params, possible params:
   *<ul>
   *  <li>width: in pixels</li>
   *  <li>heightOverflow: "scroll" | "auto".</li>
   *    If scroll, when canvas is larger than containing div, it will scroll, if not, it will change div width
   *  <li>typeResize: "scale" | "fluid",
   *    If scale, when canvas is wider than containing div, it will scale to fit; if "fluid" it will try to fit withouth scaling. // TODO: possibility of combining both (scale partially and then fluid)
   *  <li>displayTitle</li>
   *  <li>displayComposer</li>
   *  <li>layer: true 	// Layer represents the interaction layer, so if true, can use mouse (but layer=true is not enough to be able to select notes)</li>
   *
   */
  function LSViewer(divContainer, params) {
    this._init(divContainer, params)
    this._initSubscribe()
  }
  LSViewer.prototype._init = function (divContainer, params) {
    if (!$(divContainer).prop('tagName')) {
      throw 'LSViewer: divContainer is not a valid Dom element'
    }
    params = params || {}
    this.DEFAULT_HEIGHT = 1000
    this.scaler = new Scaler() //object that scales objects. Used in NoteSpaceView and ChordSpaceView
    this.SCALE = null //scale from 0 to 1
    //0.999  fixes vexflow bug that doesn't draw last pixel on end bar
    this.SCALE_FIX = 0.995

    this.CANVAS_DIV_WIDTH_PROPORTION = 0.9 //width proportion between canvas created and divContainer (space between canvas border and divContainer border)
    this.NOTE_WIDTH = 20 // estimated note width in order to be more flexible
    this.LINE_WIDTH = 1550
    this.BARS_PER_LINE = 4
    this.ENDINGS_Y = 20 //0 -> thisChordsPosY==40, the greater the closer to stave
    this.LABELS_Y = 0 //like this.ENDINGS_Y
    this.CHORDS_DISTANCE_STAVE = params.chordDistanceStave || 20 //distance from stave (if negative, will be insied stave)
    this.DISPLAY_TITLE = params.displayTitle != undefined ? params.displayTitle : true
    this.DISPLAY_COMPOSER = params.displayComposer != undefined ? params.displayComposer : true
    // constant with INITIAL prefix refer to inital values, as they can be changed when visualizing audio
    this.INITIAL_LINE_HEIGHT = params.initialLineHeight || 150
    this.INITIAL_MARGIN_TOP = 100
    this.INITIAL_LINE_MARGIN_TOP = 0
    this.LAST_BAR_WIDTH_RATIO = 0.75 //in case of this.shortenLastBar = true (rendering audio), we make the last bar more compressed so that we left space for recordings longer than piece
    this.FONT_CHORDS = params.fontChords || '18px Verdana'
    this.PADDING_LEFT_CHORDS = params.paddingLeftChords || 0

    this.DRAW_STAVE_NUMBERS = params.drawStaveNumbers === undefined ? true : params.drawStaveNumbers
    this.ONLY_CHORDS = !!params.onlyChords
    this.DRAW_CLEF = !params.onlyChords
    this.DRAW_KEY_SIGNATURE = !params.onlyChords
    this.DRAW_STAVE_LINES = params.drawStaveLines === undefined ? true : params.drawStaveLines
    this.TEXT_CLOSER_TO_STAVE = !!params.onlyChords

    this.CURSOR_MARGIN_LEFT = 6
    this.CURSOR_MARGIN_TOP = 20
    this.CURSOR_MARGIN_RIGHT = 9
    this.CURSOR_HEIGHT = 80

    //by default false, needed when ChordSpaceManager is in mode 'ONLY_CHORDS' (nothing to do with LSViewer.ONLY_CHORDS )
    //SAVE_CHORDS will save coordenates of drawed chords in an array (so there more memory needed)
    this.SAVE_CHORDS = params.saveChords === undefined ? false : params.saveChords

    // for edition CanvasLayer should be interactive, but if we only want to play we need canvasLayer to update cursor, but we may not want interaction
    this.INTERACTIVE_CANVAS_LAYER = params.interactiveCanvasLayer === undefined ? true : params.interactiveCanvasLayer

    //next three fields are set as vars and not constants because they change (e.g. when visualizing audio)
    this.lineMarginTop = this.INITIAL_LINE_MARGIN_TOP
    this.marginTop = this.INITIAL_MARGIN_TOP
    this.lineHeight = this.INITIAL_LINE_HEIGHT

    if (!this.DISPLAY_TITLE) this.marginTop -= 70
    if (!this.DISPLAY_COMPOSER) this.marginTop -= 30

    this.shortenLastBar = false

    this.heightOverflow = params.heightOverflow || 'auto'
    this.divContainer = divContainer
    this.resizable = !params.width //if there is a width specified, we assume that it wont be resized on window resize

    this.canvasId = 'ls' + ($('canvas').length + 1)
    var width = params.width ? params.width : this._getWidthFromContainer(divContainer)
    this.detectEventOnAllDocument = !!params.detectEventOnAllDocument // canvasLayer attributes
    this.canvas = this._createCanvas(this.canvasId, width, this.DEFAULT_HEIGHT)
    var renderer = new Vex.Flow.Renderer(this.canvas, Vex.Flow.Renderer.Backends.CANVAS)
    this.ctx = renderer.getContext('2d')

    this.typeResize = params.typeResize || 'fluid'
    this._resize(width)
    this.layer = params.layer
  }

  LSViewer.prototype._getWidthFromContainer = function (divContainer) {
    return $(this.divContainer).width() * this.CANVAS_DIV_WIDTH_PROPORTION
  }
  /**
   * Creates and returns a dom element
   */
  LSViewer.prototype._createCanvas = function (canvasId, width, height) {
    var canvas = $("<canvas id='" + canvasId + "'></canvas>")
    canvas[0].width = width
    canvas[0].height = height

    canvas.appendTo(this.divContainer)
    var divCss = {
      textAlign: 'center',
    }
    this.barWidthMng = null

    $(this.divContainer).css(divCss)
    return canvas[0]
  }

  LSViewer.prototype._initSubscribe = function () {
    var self = this
    $.subscribe('ToViewer-draw', function (el, songModel, forceNewCanvasLayer) {
      if (!songModel) {
        throw 'Need songModel to draw'
      }
      self.forceNewCanvasLayer = forceNewCanvasLayer
      self.draw(songModel)
    })

    $.subscribe('ToViewer-resize', function (el, songModel) {
      if (!songModel) {
        throw 'Need songModel to draw'
      }
      var width = self._getWidthFromContainer(this.divContainer)
      self.canvas.width = width
      self._resize(width)
      self.forceNewCanvasLayer = true
      self.draw(songModel)
    })
  }
  LSViewer.prototype._resize = function (width) {
    if (this.typeResize == 'scale') {
      var scale = width / this.LINE_WIDTH
      this.setScale(scale * this.SCALE_FIX)
    } else {
      // typeResize == 'fluid'
      this.setScale(this.SCALE_FIX)
      this._setWidth(width)
    }
  }
  LSViewer.prototype._setWidth = function (width) {
    var viewerWidth = width || this.LINE_WIDTH
    //if (viewerWidth < this.LINE_WIDTH){
    this.LINE_WIDTH = viewerWidth
    //}
  }

  LSViewer.prototype.scale = function (ctx) {
    ctx = ctx || this.ctx
    ctx.scale(this.SCALE, this.SCALE)
  }
  LSViewer.prototype.resetScale = function (ctx) {
    ctx = ctx || this.ctx
    ctx.scale(1 / this.SCALE, 1 / this.SCALE)
  }
  /**
   * function useful to be called in 'draw' function between this.scale() and this.resetScale().
   * It takes the width without taking into account we are scaling. This way we can place elements correctly (e.g. centering the title)
   */
  LSViewer.prototype._getNonScaledWidth = function () {
    return this.canvas.width / this.SCALE
  }
  /**
   * gets the BoundingBox
   * @param  {Object} metrics ( return by ctx.getMeasureText )
   * @param  {Integer} height
   * @return {Object}   with properties x,y,w,h
   */
  /**
   * returns getBoundingBox
   * @param  {Context} ctx
   * @param  {String} value
   * @param  {Number} x
   * @param  {Number} y
   * @return {Object}              {x:, y:, w:, h:}
   */
  LSViewer.prototype._getTextBoundingBox = function (ctx, value, x, y) {
    var metrics = ctx.measureText(value)
    var width, substractY, height, substractX
    // new browsers should
    if (metrics.actualBoundingBoxAscent !== undefined) {
      width = metrics.actualBoundingBoxRight
      substractY = metrics.actualBoundingBoxAscent
      height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
    } else {
      substractY = Number(ctx.font.substr(0, ctx.font.indexOf('px')))
      width = metrics.width
      height = substractY
    }
    //if not top, hanging nor middle, other values are bottom, alpabetic, ideographic (we do not make difference)
    substractY =
      ctx.textBaseline === 'middle'
        ? substractY / 2
        : ctx.textBaseline === 'top' || ctx.textBaseline === 'hanging'
        ? 0
        : substractY
    //we assume start and left are the same, for the moment, only support for ltr (occidental) language
    substractX =
      ctx.textAlign === 'center' ? width / 2 : ctx.textAlign === 'start' || ctx.textAlign === 'left' ? 0 : width

    var boundingBox = {
      x: x - substractX,
      y: y - substractY,
      w: width,
      h: height,
    }
    return boundingBox
  }

  LSViewer.prototype._displayTitle = function (title) {
    var oldTextAlign = this.ctx.textAlign
    this.ctx.textAlign = 'center'
    this.ctx.textBaseline = 'bottom'
    this.ctx.font = '32px lato Verdana'
    var x = this._getNonScaledWidth() / 2,
      y = 60,
      maxWidth = this.canvas.width
    this.ctx.fillText(title, x, y, maxWidth)
    this.titleView = this._getTextBoundingBox(this.ctx, title, x, y)
    this.ctx.textAlign = oldTextAlign
  }

  LSViewer.prototype._displayComposer = function (composer) {
    var oldTextAlign = this.ctx.textAlign
    this.ctx.textAlign = 'right'
    this.ctx.font = '24px lato Verdana'
    if (typeof composer === 'undefined') {
      composer = 'Unknown'
    }
    var x = this._getNonScaledWidth() - 20,
      y = 20,
      maxWidth = this._getNonScaledWidth()
    this.ctx.fillText(composer, x, y, maxWidth)
    this.composerView = this._getTextBoundingBox(this.ctx, composer, x, y)
    this.ctx.textAlign = oldTextAlign
  }
  LSViewer.prototype.setScale = function (scale) {
    this.SCALE = scale
    this.scaler.setScale(scale)
  }
  LSViewer.prototype.setLineMarginTop = function (lineMarginTop, bottom) {
    if (!bottom) {
      this.marginTop += lineMarginTop
    } else {
      this.lineMarginTop = lineMarginTop
    }
    this.lineHeight += lineMarginTop
  }

  LSViewer.prototype.getLineHeight = function () {
    return this.lineHeight
  }
  LSViewer.prototype.setLineHeight = function (lineHeight) {
    if (!isNaN(lineHeight)) {
      this.lineHeight = lineHeight
    }
  }
  LSViewer.prototype.resetLinesHeight = function () {
    this.lineHeight = this.INITIAL_LINE_HEIGHT
    this.marginTop = this.INITIAL_MARGIN_TOP
    this.lineMarginTop = this.INITIAL_LINE_MARGIN_TOP
  }

  LSViewer.prototype.setHeight = function (song, barWidthMng) {
    var totalNumBars = song.getComponent('bars').getTotal()
    this.canvas.height = (barWidthMng.getDimensions(totalNumBars - 1).top + this.lineHeight) * this.SCALE

    if (this.canvas.height != $(this.divContainer).height()) {
      if (this.heightOverflow == 'scroll') {
        $(this.divContainer).css({
          overflowY: 'scroll',
        })
      } else {
        $(this.divContainer).height(this.canvas.height)
      }
    }
  }
  LSViewer.prototype.setShortenLastBar = function (bool) {
    this.shortenLastBar = bool
  }

  LSViewer.prototype.draw = function (song) {
    if (typeof song === 'undefined') {
      console.warn('song is empty') // only for debug, remove after 1 week safe
      return
    }
    //console.log("draw");
    //console.time('whole draw');
    var i, j, v, c

    var numBar = 0,
      self = this,
      nm = song.getComponent('notes'),
      cm = song.getComponent('chords'),
      barNotes,
      barChords,
      beamMng,
      tupletMng,
      bar,
      noteView,
      chordView,
      iNote = 0,
      stave,
      vxfBeams,
      noteViews = [],
      chordViews = [],
      barNoteViews,
      vxfBars = [],
      barDimensions,
      tieMng = new TieManager()

    var lastBarWidthRatio = this.shortenLastBar ? this.LAST_BAR_WIDTH_RATIO : 1
    this.barWidthMng = new BarWidthManager(
      this.lineHeight,
      this.LINE_WIDTH,
      this.NOTE_WIDTH,
      this.BARS_PER_LINE,
      this.marginTop,
      lastBarWidthRatio
    )
    this.barWidthMng.calculateBarsStructure(song, nm, cm, this.ctx, this.FONT_CHORDS)
    this.setHeight(song, this.barWidthMng)
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
    this.scale()

    var numSection = 0
    var songIt = new SongBarsIterator(song)
    var barView
    var sectionIt

    song.getSections().forEach(function (section) {
      // for each bar
      sectionIt = new SectionBarsIterator(section)
      while (sectionIt.hasNext()) {
        //console.time('whole bar');
        barNoteViews = []

        beamMng = new BeamManager()
        tupletMng = new TupletManager()
        bar = []

        if (!self.ONLY_CHORDS) {
          barNotes = nm.getNotesAtCurrentBar(songIt)
          for (j = 0, v = barNotes.length; j < v; j++) {
            tieMng.checkTie(barNotes[j], iNote)
            tupletMng.checkTuplet(barNotes[j], j)
            noteView = new LSNoteView(barNotes[j])
            beamMng.checkBeam(nm, iNote, noteView)

            bar.push(noteView.getVexflowNote())
            barNoteViews.push(noteView)
            iNote++
          }
        }
        //BARS
        barDimensions = self.barWidthMng.getDimensions(songIt.getBarIndex())
        var barViewParams = {
          draw_clef: self.DRAW_CLEF,
          draw_key_signature: self.DRAW_KEY_SIGNATURE,
          draw_stave_numbers: self.DRAW_STAVE_NUMBERS,
        }
        if (!self.DRAW_STAVE_LINES) {
          barViewParams.fill_style = '#FFF' //we assume background is white
        }
        if (self.TEXT_CLOSER_TO_STAVE) {
          //this way, endings and text such as coda, segno, section names are closer
          barViewParams.top_text_position = 0
        }

        barView = new LSBarView(barDimensions, barViewParams)
        barView.draw(self.ctx, songIt, sectionIt, self.ENDINGS_Y, self.LABELS_Y)

        vxfBars.push({
          barDimensions: barDimensions,
          timeSignature: songIt.getBarTimeSignature(),
        })

        barChords = cm.getChordsByBarNumber(songIt.getBarIndex())
        for (i = 0, c = barChords.length; i < c; i++) {
          chordView = new LSChordView(barChords[i]).draw(
            self.ctx,
            barDimensions,
            songIt.getBarTimeSignature(),
            self.CHORDS_DISTANCE_STAVE,
            self.FONT_CHORDS,
            self.PADDING_LEFT_CHORDS,
            self.SAVE_CHORDS ? self._getTextBoundingBox : null
          )
          if (self.SAVE_CHORDS) chordViews.push(chordView)
        }
        vxfBeams = beamMng.getVexflowBeams() // we need to do getVexflowBeams before drawing notes

        if (!self.ONLY_CHORDS) {
          Vex.Flow.Formatter.FormatAndDraw(self.ctx, barView.getVexflowStave(), bar, {
            autobeam: false,
          })
          beamMng.draw(self.ctx, vxfBeams) // and draw beams needs to be done after drawing notes
          tupletMng.draw(self.ctx, barNoteViews)
          noteViews = noteViews.concat(barNoteViews)
        }
        songIt.next()
        sectionIt.next()
      }
      numSection++
    })
    tieMng.draw(this.ctx, noteViews, nm, this.barWidthMng, song)

    this.chordViews = chordViews
    this.vxfBars = vxfBars
    this.ctx.fillStyle = 'black'
    this.ctx.strokeStyle = 'black'
    if (this.DISPLAY_COMPOSER) {
      this._displayComposer(song.getComposer())
    }
    if (this.DISPLAY_TITLE) {
      this._displayTitle(song.getTitle())
    }
    this.ctx.globalAlpha = 1
    this.resetScale()

    // if constructor was supposed to have a layer and either canvasLayer is not created, either we are forcing to recreate it (e.g. on resize)
    if (this.layer && (this.forceNewCanvasLayer || !this.canvasLayer)) {
      this.forceNewCanvasLayer = false
      if (this.canvasLayer) {
        this.canvasLayer.destroy() //to remove html listeners
      }
      this.canvasLayer = new CanvasLayer(this, this.detectEventOnAllDocument, this.INTERACTIVE_CANVAS_LAYER) //the canvasLayer needs to be created after the score has been drawn
    }
    this.noteViews = this._getNoteViewsArea(noteViews)
    $.publish('LSViewer-drawEnd', this)
  }

  LSViewer.prototype._getNoteViewsArea = function (noteViews) {
    var noteSpaceViews = [],
      area

    for (var i = 0; i < noteViews.length; i++) {
      area = noteViews[i].getArea()
      area.x -= this.CURSOR_MARGIN_LEFT
      area.y += this.CURSOR_MARGIN_TOP
      area.w += this.CURSOR_MARGIN_LEFT + this.CURSOR_MARGIN_RIGHT
      area.h = this.CURSOR_HEIGHT
      noteSpaceViews.push(new NoteSpaceView(area, this.scaler))
    }
    return noteSpaceViews
  }
  /**
   * When drawing an element from another module, it has to use this function
   * @param  {Function} drawFunc function that draws the element
   */
  LSViewer.prototype.drawElem = function (drawFunc) {
    this.scale(this.ctx)
    drawFunc()
    this.resetScale(this.ctx)
  }
  return LSViewer
})
define('utils/apiFlowMachines/ComposerServlet', ['jquery'], function ($) {
  var ComposerServlet = {}

  /**
   * Return correct request for simple audio get
   */
  ComposerServlet.getRequestForSimpleAudio = function (leadsheet, tempo, playComping, playTick, style) {
    var request = {
      'ls.leadsheet': leadsheet,
      type: 'audio',
      'ex.tempo': tempo,
      'seq.tick.play': playTick,
      'seq.comping.play': playComping,
      'seq.bass.play': playComping,
      'ex.audio.sampleRate': 48000,
      'ex.audio.bitrate': 320,
    }
    return request
  }
  /**
   * Return correct request for simple midi get
   */
  ComposerServlet.getRequestForSimpleMidi = function (leadsheet, tempo, playComping, playTick) {
    var request = {
      'ls.leadsheet': leadsheet,
      type: 'midi',
      'ex.tempo': tempo,
      'seq.tick.play': playTick,
      'seq.comping.play': playComping,
      'seq.bass.play': playComping,
    }
    return request
  }

  return ComposerServlet
})
define('utils/PopIn', ['mustache'], function (Mustache) {
  /**
   * @param {String}  title
   * @param {String}  content    Can be the content or the link to a template to load (in case it's a template set istemplate to true)
   * @param {Object} options  	options.classTitle is the name of the class that will use
   */
  function PopIn(title, content, options) {
    this.title = title
    this.content = content

    options = options || {}

    this.classTitle = options.classTitle !== undefined ? options.classTitle : 'foregroundPopin'

    this.footerButtonTitle = options.footerButtonTitle !== undefined ? options.footerButtonTitle : 'Ok'
    if (options.isTemplate !== undefined && options.isTemplate === true) {
      this.isTemplate = true
      this.template = content
    } else {
      this.isTemplate = false
      this.content = content
    }
    this.onSubmitFunction = options.onSubmit
    this.onCloseFunction = options.onClose // close function is launched on hiding popin AND on submit
    this.backgroundOpacity = 0.5
  }

  PopIn.prototype.render = function () {
    this.initView()
    if (this.isTemplate) {
      var self = this
      this.renderTemplate(function () {
        self.initController()
        self.initKeyboard()
      })
    } else {
      this.initController()
      this.initKeyboard()
    }
  }

  /**
   * Function initializes background and foreground of the popin.
   * When content is available (in case it's not a template) it's directly inserted
   */
  PopIn.prototype.initView = function () {
    var backgroundPopin =
      '<div class="backgroundPopin" style="display:none;opacity:' + this.backgroundOpacity + '"></div>'
    $(document.body).append(backgroundPopin)
    var content = ''
    if (!this.isTemplate) {
      content = this.content
    }
    var txt = ''
    txt +=
      '<div style="display:none;padding: 1em;z-index: 9001;" class="modal ' +
      this.classTitle +
      '" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">'
    txt += '<div class="modal-dialog">'
    txt += '<div class="modal-content">'
    txt += '<div class="modal-header">'
    txt +=
      '<button type="button" class="popin_close close" style="float:right" data-dismiss="modal" aria-hidden="true">&times;</button>'
    txt += '<h4 class="modal-title">' + this.title + '</h4>'
    txt += '</div>'
    txt += '<div class="modal-body contentPopIn">' + content + '</div>'

    txt +=
      '<div class="modal-footer"><span class="modal-footer-text"></span><button type="button" class="btn btn-default popin_close">Close</button>'
    txt +=
      ' <button type="button" class="btn btn-primary popin_close modal_submit">' +
      this.footerButtonTitle +
      '</button></div>'

    txt += '</div>'
    txt += '</div>'
    txt += '</div>'
    $(document.body).append(txt)
  }

  /**
   * Function gets the template, render it and insert as the content
   * @param  {Function} callback function that will be executed after
   * @return {String}            Render template
   */
  PopIn.prototype.renderTemplate = function (callback) {
    var self = this
    $.get(this.template, function (template) {
      var rendered = Mustache.render(template)
      $('.' + self.classTitle + ' .contentPopIn').html(rendered)
      if (typeof callback === 'function') {
        callback()
      }
      return rendered
    })
  }

  PopIn.prototype.initController = function () {
    var self = this
    $('.backgroundPopin, .popin_close').click(function () {
      self.hide()
      if (self.onCloseFunction) self.onCloseFunction()
    })
    $('.' + self.classTitle + ' .modal_submit').click(function () {
      if (self.onSubmitFunction) self.onSubmitFunction()
      if (self.onCloseFunction) self.onCloseFunction()
    })
  }

  PopIn.prototype.initKeyboard = function () {
    var self = this
    $(document).keydown(function (evt) {
      var keyCode = evt === null ? event.keyCode : evt.keyCode
      if (keyCode === 27) {
        // Escape touch close view
        self.hide()
      }
    })
  }

  PopIn.prototype.show = function () {
    $('.backgroundPopin').fadeIn('slow')
    $('.' + this.classTitle).fadeIn('slow')
  }

  PopIn.prototype.hide = function () {
    $('.backgroundPopin').fadeOut('slow')
    $('.' + this.classTitle).fadeOut('slow')
  }

  return PopIn
})
define('modules/FileEdition/src/FileEditionController', [
  'mustache',
  'modules/core/src/SongModel',
  'modules/converters/MusicCSLJson/src/SongModel_CSLJson',
  'modules/converters/MusicXML/src/SongModel_MusicXML',
  'modules/LSViewer/src/LSViewer',
  'pubsub',
  'utils/UserLog',
  'utils/apiFlowMachines/ComposerServlet',
  'utils/PopIn',
  'jsPDF',
  'jquery',
], function (
  Mustache,
  SongModel,
  SongModel_CSLJson,
  SongModel_MusicXML,
  LSViewer,
  pubsub,
  UserLog,
  ComposerServlet,
  PopIn,
  jsPDF,
  $
) {
  /**
   * FileEditionController manages all file interaction like save, import, export
   * @exports FileEdition/FileEditionController
   */
  function FileEditionController(songModel, viewer, saveFunction, saveAs) {
    if (viewer) {
      this.viewer = viewer
      if (viewer.canvas) {
        this.viewerCanvas = viewer.canvas
      }
    }
    this.songModel = songModel || new SongModel()
    this.initSubscribe()
    var self = this
    if (saveAs) {
      this.initSubscribeSaveAS()
    }
    if (saveFunction) {
      this.saveFn = saveFunction
    }
  }

  /**
   * Subscribe to view events
   */
  FileEditionController.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('FileEditionView-importMusicCSLJSON', function (el, JSONSong) {
      self.importMusicCSLJSON(JSONSong)
    })
    $.subscribe('FileEditionView-importMusicXML', function (el, musicXMLSong) {
      self.importMusicXML(musicXMLSong)
    })

    $.subscribe('FileEditionView-exportPNG', function (el) {
      self.exportPNG()
    })
    $.subscribe('FileEditionView-exportPDF', function (el) {
      self.exportAndPromptLeadsheetToPDF(
        self.songModel.getTitle(),
        self.songModel.getComposer(),
        self.songModel.getTimeSignature(),
        self.songModel.getStyle()
      )
    })
    $.subscribe('FileEditionView-exportMusicCSLJSON', function (el) {
      self.exportLeadsheetJSON()
    })
    $.subscribe('FileEditionView-save', function (el) {
      self.save()
    })
    $.subscribe('FileEditionView-saveAs', function (el) {
      self.saveToServer()
    })
    $.subscribe('ToUpdateModel', function (el) {
      self.save()
    })
  }
  //TODO: this logic is dependent on the application that uses LeadsheetJS, not on LeadsheetJS, maybe it should be moved, just like 'save' function
  FileEditionController.prototype.initSubscribeSaveAS = function (first_argument) {
    var content =
      "<div class='controls form-inline'>" +
      "<label style='padding:5px;'>New Title</label><input name='title' type='text'></input>" +
      "&nbsp;&nbsp;<label style='padding:5px;'>Link to original lead sheet</label><input type='checkbox' name='linked' checked='true'/>" +
      '</div>'
    var classTitle = 'saveAs'
    this.popin = new PopIn('Save As', content, { classTitle: classTitle })
    this.popin.render()
    var self = this
    $(document).on('click', '.' + classTitle + ' .modal_submit', function (data) {
      var title = $('input[name=title]').val()
      title = title || 'Copy of ' + self.songModel.getTitle()
      self.songModel.setTitle(title)
      var linked = $("input[name='linked']")[0].checked
      self.save(self.songModel, false, linked)
      $.publish('ToViewer-draw', self.songModel)
    })
  }

  FileEditionController.prototype.importMusicCSLJSON = function (JSONSong) {
    if (typeof JSONSong === 'undefined') {
      throw 'FileEditionController - importMusicCSLJSON File imported is not defined ' + JSONSong
    }
    SongModel_CSLJson.importFromMusicCSLJSON(JSONSong, this.songModel)
    $.publish('ToHistory-add', 'Open MusicCSLJson - ' + this.songModel.getTitle())
    $.publish('ToViewer-draw', [this.songModel, true])
  }

  FileEditionController.prototype.importMusicXML = function (musicXMLSong) {
    if (typeof musicXMLSong === 'undefined') {
      throw 'FileEditionController - importMusicXML File imported is not defined ' + musicXMLSong
    }
    SongModel_MusicXML.importFromMusicXML(musicXMLSong, this.songModel)
    $.publish('ToHistory-add', 'Open MusicXML - ' + this.songModel.getTitle())
    $.publish('ToViewer-draw', this.songModel)
  }

  /**
   * Propose file to be downloaded by user
   * @param  {String} title     title of file downloaded, title can contain extension eg "my_file" or "my_file.png"
   * @param  {String} path      Real path to download from eg "www.url.com/my_tmp_file_is_here.mp3"
   * @param  {String} extension optionnal arguments, if defined, be carefull to write the dot at begining, eg ".mp3"
   */
  FileEditionController.prototype.promptFile = function (title, path, extension) {
    if (typeof extension === 'undefined') {
      extension = ''
    }
    var export_link = $('<a>', {
      download: title + extension,
      href: path,
    }).prependTo('body')
    export_link[0].click()
    export_link.remove()
  }

  FileEditionController.prototype.exportPNG = function () {
    var resolutionRatio = 3 // don't go over 3-4 because then toDataUrl is getting too big on long leadsheet and export doesn't work
    // augment resolution
    this.viewer.canvas.width = this.viewer.canvas.width * resolutionRatio
    this.viewer.typeResize = 'scale'
    this.viewer._resize(this.viewer.canvas.width)
    this.viewer.draw(this.songModel)

    // screenshot and export
    this.promptFile(this.songModel.getTitle() + '.png', this.viewer.canvas.toDataURL('image/png'))

    // reduce resolution
    this.viewer.typeResize = 'fluid'
    this.viewer.canvas.width = Math.ceil(this.viewer.canvas.width / resolutionRatio)
    this.viewer._resize(this.viewer.canvas.width)
    this.viewer.draw(this.songModel)
  }

  FileEditionController.prototype.exportAndPromptLeadsheetToPDF = function (
    title,
    composer,
    timeSignature,
    style,
    sources_abr
  ) {
    var srcCanvas = this.viewerCanvas
    // create a dummy CANVAS to create a new viewer without selection or edition
    var destinationElement = document.createElement('div')
    var currentViewer = new LSViewer(destinationElement, {
      width: srcCanvas.width - 10,
    })
    currentViewer.setLineHeight(this.viewer.getLineHeight())
    currentViewer.draw(this.songModel)

    // create another dummy CANVAS in which we will draw the first canvas, it prevents black screen to appear
    var destinationCanvas = document.createElement('canvas')
    destinationCanvas.width = srcCanvas.width
    destinationCanvas.height = srcCanvas.height
    var destCtx = destinationCanvas.getContext('2d')
    // create a rectangle with the desired color
    destCtx.fillStyle = '#FFFFFF'
    destCtx.fillRect(0, 0, srcCanvas.width, srcCanvas.height)
    // draw the original canvas onto the destination canvas
    destCtx.drawImage(currentViewer.canvas, 0, 0)
    var imgData = destinationCanvas.toDataURL('image/jpeg', 1)

    var totalWidth = 200
    var totalHeight = totalWidth * (srcCanvas.height / srcCanvas.width)

    var doc = new jsPDF()
    doc.setFontSize(34)
    // doc.text(15, 20, title);
    // doc.setFontSize(18);
    // doc.text(15, 30, composer);
    doc.addImage(imgData, 'JPEG', 10, 23, totalWidth, totalHeight)
    doc.setFontSize(10)
    doc.text(15, 20, style + ' (' + timeSignature + ')')
    if (totalHeight >= 365) {
      doc.addPage()
      doc.addImage(imgData, 'JPEG', 10, -270, totalWidth, totalHeight)
    }
    if (sources_abr && sources_abr !== '') {
      sources_abr = '_' + sources_abr
    } else {
      sources_abr = ''
    }
    doc.save(title + sources_abr + '.pdf')
  }

  FileEditionController.prototype.exportLeadsheetJSON = function () {
    var JSONSong = SongModel_CSLJson.exportToMusicCSLJSON(this.songModel)
    // Code is a bit special for json because we transform data and we add a 'data:' prefix after href to make it works
    var data = 'text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(JSONSong))
    var export_link = $('<a>', {
      download: this.songModel.getTitle() + '.json',
      href: 'data:' + data,
    }).prependTo('body')
    export_link[0].click()
    export_link.remove()
  }

  FileEditionController.prototype.save = function (newLeadsheet, showConfirm, derived) {
    showConfirm = showConfirm !== undefined ? showConfirm : true

    var songId
    if (!newLeadsheet && this.songModel._id !== undefined) {
      songId = this.songModel._id
    }
    var derivedId = derived ? this.songModel._id : null

    this.songModel._id = undefined // we need to clean songModel id otherwise update doesn't work
    var JSONSong = SongModel_CSLJson.exportToMusicCSLJSON(this.songModel)
    if (window.parent.updateModel !== undefined) {
      window.parent.updateModel(JSONSong, songId, this.viewer, this.songModel)
    }
  }

  FileEditionController.prototype.saveAs = function () {
    this.popin.show()
  }

  FileEditionController.prototype.saveToServer = function (newLeadsheet, showConfirm, derived) {
    showConfirm = showConfirm !== undefined ? showConfirm : true

    var songId
    if (!newLeadsheet && this.songModel._id !== undefined) {
      songId = this.songModel._id
    }
    var derivedId = derived ? this.songModel._id : null

    this.songModel._id = undefined // we need to clean songModel id otherwise update doesn't work
    var JSONSong = SongModel_CSLJson.exportToMusicCSLJSON(this.songModel)

    if (this.saveFn !== undefined) {
      if (
        showConfirm &&
        !confirm(
          '你确定要暂存' + this.songModel.getTitle() + '这首曲目?暂存后仅保存当前曲目，并不提交，请于截止日期前提交！'
        )
      ) {
        return
      }
      var self = this
      var idLog = UserLog.log('info', '提交中...')
      this.saveFn(JSONSong, songId, { derivedId: derivedId }, function (data) {
        UserLog.removeLog(idLog)
        if (data.error) {
          UserLog.logAutoFade('暂存失败', data.msg)
        } else {
          UserLog.logAutoFade('暂存成功', '成功暂存至服务器！')
        }
        self.songModel._id = data.id
      })
    }
  }

  return FileEditionController
})
define('modules/FileEdition/src/FileEdition', [
  'modules/FileEdition/src/FileEditionView',
  'modules/FileEdition/src/FileEditionController',
], function (FileEditionView, FileEditionController) {
  /**
   * FileEdition constructor
   * @exports FileEdition
   */
  function FileEdition(songModel, viewer, saveFunction, params, saveAsF) {
    this.view = new FileEditionView(params)
    new FileEditionController(songModel, viewer, saveFunction, true) //saveAs is true
  }
  return FileEdition
})
define('modules/History/src/HistoryController', [
  'modules/core/src/SongModel',
  'modules/converters/MusicCSLJson/src/SongModel_CSLJson',
  'mustache',
  'utils/UserLog',
  'jquery',
  'pubsub',
], function (SongModel, SongModel_CSLJson, Mustache, UserLog, $, pubsub) {
  /**
   * History constroller
   * @exports History/HistoryController
   */
  function HistoryController(model, songModel) {
    this.model = model || new HistoryModel()
    this.songModel = songModel || new SongModel()
    this.initSubscribe()
  }

  /**
   * Subscribe to view events
   */
  HistoryController.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('HistoryView-selectHistory', function (el, indexItem) {
      self.loadHistory(indexItem)
    })
    $.subscribe('HistoryView-moveSelectHistory', function (el, inc) {
      self.moveSelectHistory(inc)
    })
    $.subscribe('ToHistory-add', function (el, title, updateLastEntry) {
      self.addToHistory(title, updateLastEntry)
    })
    $.subscribe('ToHistory-updateLastEntry', function () {
      self.updateLastEntry()
    })
  }

  /**
   * Function is called to load the state of one history
   * @param  {int} currentHistory represent the index of history that will be loaded
   */
  HistoryController.prototype.loadHistory = function (currentHistory) {
    if (typeof this.model.historyList[currentHistory] === 'undefined') {
      UserLog.logAutoFade('error', 'No history available')
      return
    }
    this.model.setCurrentPosition(currentHistory)
    if (this.songModel) {
      var retrievedLeadsheet = this.model.getCurrentState()
      if (retrievedLeadsheet) {
        SongModel_CSLJson.importFromMusicCSLJSON(retrievedLeadsheet, this.songModel)
        $.publish('ToLayers-removeLayer')
        $.publish('ToViewer-draw', this.songModel)
      }
    }
  }

  /**
   * Function is called to load the state of one history before or after (typically, ctrl+z or ctrl+y)
   * @param  {int} inc represent the decal of history relative to currentHistory to be loaded
   */
  HistoryController.prototype.moveSelectHistory = function (inc) {
    if (isNaN(inc)) {
      throw 'HistoryController - moveSelectHistory - inc must be an int ' + inc
    }
    this.loadHistory(this.model.getCurrentPosition() + inc)
  }

  /**
   * Function is called to save a state to history
   */
  HistoryController.prototype.addToHistory = function (title, updateLastEntry) {
    var JSONSong = SongModel_CSLJson.exportToMusicCSLJSON(this.songModel) // Exporting current songModel to json
    this.model.addToHistory(JSONSong, title, updateLastEntry)
  }

  /**
   * Function is called to update last entry songModel state, but title is merged, it's used to not create another entry in history state
   */
  HistoryController.prototype.updateLastEntry = function () {
    var JSONSong = SongModel_CSLJson.exportToMusicCSLJSON(this.songModel) // Exporting current songModel to json
    this.model.getCurrentState().leadsheet = JSONSong
  }

  return HistoryController
})
define('modules/History/src/HistoryView', ['mustache', 'utils/UserLog', 'jquery', 'pubsub'], function (
  Mustache,
  UserLog,
  $,
  pubsub
) {
  /**
   * History view
   * @exports History/HistoryView
   */
  function HistoryView(parentHTML, displayHistory, displayTime) {
    this.el = undefined
    this.parentHTML = parentHTML ? parentHTML : $('#rightPanel')
    this.displayHistory = typeof displayHistory !== 'undefined' ? displayHistory : true
    this.displayTime = !!displayTime
    this.isActive = true
    this.initController()
    this.initKeyboard()
    this.initSubscribe()
    this.render()
    this.activeView()
  }

  /**
   * Render will build and display a new dom in parentHTML using model historyList
   */
  HistoryView.prototype.render = function (model) {
    if (this.displayHistory === false || !this.parentHTML) {
      return
    }

    var history = ''
    history += '<span class="pull-right history-fold">></span>'
    history += '<div class="history-container">'
    history += '<h3>History</h3>'
    history += '<ul class="history_ul">'
    var text = '',
      classCurrent = ''
    // loop through each history state
    if (model) {
      for (var i = 0, c = model.historyList.length; i < c; i++) {
        classCurrent = ''
        if (i == model.currentPosition) {
          classCurrent = 'current_history'
        }
        text = ''
        if (model.historyList[i]['title'] !== '') {
          text += model.historyList[i]['title'] + ' '
        }
        if (this.displayTime) {
          text += model.historyList[i]['time']
        }
        history += '<li class="' + classCurrent + '" data-history="' + i + '">' + text + '</li>'
      }
    }
    history += '</ul>'
    history += '</div>'
    this.parentHTML.html(history)
    //$.publish('HistoryView-render');
  }

  HistoryView.prototype.initKeyboard = function (evt) {
    $.subscribe('ctrl-z', function (el) {
      $.publish('HistoryView-moveSelectHistory', -1)
    })
    $.subscribe('ctrl-y', function (el) {
      $.publish('HistoryView-moveSelectHistory', 1)
    })
  }

  /**
   * Publish event after receiving dom events
   */
  HistoryView.prototype.initController = function () {
    var self = this
    this.parentHTML.on('click', '.history_ul li', function () {
      var indexItem = parseInt($(this).attr('data-history'), 10)
      $.publish('HistoryView-selectHistory', indexItem)
    })

    this.parentHTML.addClass('history-open')
    this.parentHTML.on('click', '.history-fold', function () {
      if (self.isActive === true) {
        $('.history-fold').html('<')
        self.parentHTML.removeClass('history-open')
        self.parentHTML.addClass('history-close')
        self.parentHTML.find('.history-container').hide()
        self.isActive = false
      } else {
        $('.history-fold').html('>')
        self.parentHTML.removeClass('history-close')
        self.parentHTML.addClass('history-open')
        self.parentHTML.find('.history-container').show()
        self.isActive = true
      }
    })
  }

  /**
   * Subscribe to model events
   */
  HistoryView.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('HistoryModel-setCurrentPosition', function (el, model) {
      self.render(model)
    })
    $.subscribe('HistoryModel-addToHistory', function (el, model) {
      self.render(model)
    })
    $.subscribe('toHistoryView-unactiveView', function () {
      self.unactiveView()
    })
    $.subscribe('toHistoryView-activeView', function () {
      self.activeView()
    })
  }

  HistoryView.prototype.unactiveView = function () {
    //$('#rightPanel').hide('slow');
  }

  HistoryView.prototype.activeView = function () {
    $(this.parentHTML).show('slow')
  }

  return HistoryView
})
define('modules/History/src/HistoryModel', ['mustache', 'jquery', 'utils/UserLog', 'pubsub', 'JsonDelta'], function (
  Mustache,
  $,
  UserLog,
  pubsub,
  JSON_delta
) {
  /**
   * HistoryModel is an array of state, it allow a high level management of Historys
   * @exports History/HistoryModel
   * @param {object} options
   */
  var HistoryModel = function (options) {
    this.init()
    this.maxHistoryLength = options && !isNaN(options.maxHistoryLength) ? options.maxHistoryLength : 10000
    this.lastLeadsheet = null
  }

  /**
   * Initialise historyList by cleaning historyList
   * By default currentPosition is on 0
   */
  HistoryModel.prototype.init = function () {
    this.historyList = [] // state list
    this.currentPosition = -1 // current Position start at 0
  }

  HistoryModel.prototype.getCurrentPosition = function () {
    return this.currentPosition
  }

  HistoryModel.prototype.getState = function (position) {
    var leadsheet = JSON.parse(JSON.stringify(this.lastLeadsheet)) //cloning,so that this.lastLeadsheet is not affected
    for (var i = this.historyList.length - 1; i > position; i--) {
      leadsheet = JSON_delta.patch(leadsheet, this.historyList[i].invertedDelta)
    }
    return leadsheet
  }

  HistoryModel.prototype.getCurrentState = function () {
    return this.getState(this.currentPosition)
  }

  HistoryModel.prototype.setCurrentPosition = function (position) {
    if (!isNaN(position) && position >= -1 && position < this.historyList.length) {
      this.currentPosition = position
      $.publish('HistoryModel-setCurrentPosition', this)
    }
  }

  /**
   * Add a state to History
   * @param {Object} leadsheet contain a state, it's often a leadsheet
   * @param {string} title     state name, view can display this message to user.
   * @param {Boolean} updateLastEntry     if updating last entry, true, this is common when changing pitch note, first time pitch is changed, we add a new entry entry,
   *                                      but if pitch is changed many times in the same note without moving the cursor, we just update it in order to not have very long historics
   *
   */
  HistoryModel.prototype.addToHistory = function (leadsheet, title, updateLastEntry) {
    var time = new Date().toLocaleString()
    title = title ? title : ''
    var invertedDelta
    var leadsheetToCompareTo
    //first time lastLeadsheet will be null so there will be no delta to obtain
    if (this.lastLeadsheet) {
      if (updateLastEntry) {
        leadsheetToCompareTo = this.getState(this.currentPosition - 1) //get previous leadsheet, as we want delta to get to previous leadsheet, not the last
      } else {
        leadsheetToCompareTo = this.getState(this.currentPosition) //get leadsheet of currentPosition
      }
      invertedDelta = JSON_delta.diff(leadsheet, leadsheetToCompareTo)
      if (invertedDelta.length === 0) {
        //in case there was no change (not probable)
        return
      }
    } else {
      invertedDelta = null
    }

    var newHistorical = {
      invertedDelta: invertedDelta,
      title: title,
      time: time,
    }

    if (updateLastEntry) {
      this.historyList[this.historyList.length - 1] = newHistorical
    } else {
      this.historyList = this.historyList.slice(0, this.currentPosition + 1)
      this.historyList.push(newHistorical)
      if (this.historyList.length > this.maxHistoryLength) {
        this.historyList.splice(0, 1)
      }
      this.setCurrentPosition(this.currentPosition + 1)
    }
    this.lastLeadsheet = leadsheet
    $.publish('HistoryModel-addToHistory', this)
  }

  return HistoryModel
})
define('modules/History/src/HistoryC', [
  'modules/History/src/HistoryController',
  'modules/History/src/HistoryView',
  'modules/History/src/HistoryModel',
], function (HistoryController, HistoryView, HistoryModel) {
  /**
   * History constructor
   * @exports History/HistoryC
   */
  function HistoryC(songModel, parentHTML, modelOptions, displayHistory, displayTime) {
    var historyM = new HistoryModel(modelOptions)
    var historyV = new HistoryView(parentHTML, displayHistory, displayTime)
    new HistoryController(historyM, songModel)
  }
  return HistoryC
})
define('modules/LSViewer/src/OnWindowResizer', ['jquery'], function ($) {
  /**
   * Manage windows resize event
   * @exports LSViewer/OnWindowResizer
   */
  var OnWindowResizer = function (songModel) {
    $(window).resize(function () {
      window.setTimeout(function () {
        $.publish('ToViewer-resize', songModel)
      }, 0)
    })
  }
  return OnWindowResizer
})
define('modules/MainMenu/src/MainMenuModel', ['jquery', 'pubsub'], function ($, pubsub) {
  /**
   * MainMenuModel is the model containing a set of menuList, each menuList contain a menu, each menu contain at least a title
   * @exports MainMenu/MainMenuModel
   */
  function MainMenuModel(allowChangeUrl) {
    this.menuList = [] // array of menus
    this.currentMenu = this.menuList[0] // Current menu represent the current selected menu
    this.allowChangeUrl = allowChangeUrl ? allowChangeUrl : false
  }

  MainMenuModel.prototype.isAllowChangeUrl = function () {
    return this.allowChangeUrl
  }

  MainMenuModel.prototype.getMenuLength = function () {
    return this.menuList.length
  }

  MainMenuModel.prototype.getMenu = function (index) {
    if (isNaN(index) || typeof this.menuList[index] === 'undefined') {
      throw 'MainMenuModel - getMenu - index is undefined or is not a number or doesnt exist ' + index
    }
    return this.menuList[index]
  }

  MainMenuModel.prototype.addMenu = function (menu) {
    if (typeof menu === 'undefined' || menu.title == 'undefined') {
      throw 'MainMenuModel - addMenu - menu is undefined' + menu
    }
    if (this.hasMenu(menu.title) === false) {
      if (typeof menu.order === 'undefined') {
        menu.order = this.menuList.length + 1
      }
      this.menuList.push(menu)
      this.sortMenu()
      window.clearTimeout(this.eventOptimizer)
      this.eventOptimizer = window.setTimeout(function () {
        $.publish('MainMenuModel-addMenu', menu)
      }, 10)
    } else {
      console.warn('MainMenuModel - addMenu - menu ' + menu.title + ' already exist')
    }
  }

  MainMenuModel.prototype.sortMenu = function () {
    this.menuList.sort(function (a, b) {
      if (a.order > b.order) {
        return 1
      }
      if (a.order < b.order) {
        return -1
      }
      // a doit être égale à b
      return 0
    })
  }

  MainMenuModel.prototype.hasMenu = function (menuTitle) {
    if (typeof menuTitle === '') {
      throw "MainMenuModel - hasModule - menuTitle can't be equal to an empty string"
    }
    for (var i = 0, c = this.menuList.length; i < c; i++) {
      if (this.menuList[i].title === menuTitle) {
        return true
      }
    }
    return false
  }

  MainMenuModel.prototype.searchMenuIndex = function (menuTitle) {
    if (typeof menuTitle === '') {
      throw "MainMenuModel - searchMenuIndex - menuTitle can't be equal to an empty string"
    }
    for (var i = 0, c = this.menuList.length; i < c; i++) {
      if (this.menuList[i].title === menuTitle) {
        return i
      }
    }
    return -1
  }

  MainMenuModel.prototype.removeMenu = function (menuTitle) {
    var index = this.searchMenuIndex(menuTitle)
    if (index !== -1) {
      this.menuList[index] = undefined
      this.menuList.splice(index, 1)
      $.publish('MainMenuModel-removeMenu', menuTitle)
      return true
    }
    return false
  }

  MainMenuModel.prototype.getCurrentMenu = function () {
    return this.currentMenu
  }

  MainMenuModel.prototype.setCurrentMenu = function (currentMenu) {
    if (typeof currentMenu === 'undefined') {
      return
    }
    this.currentMenu = currentMenu
    $.publish('MainMenuModel-setCurrentMenu', this.currentMenu)
  }

  return MainMenuModel
})
define('modules/MainMenu/src/MainMenuController', [
  'modules/MainMenu/src/MainMenuModel',
  'jquery',
  'pubsub',
  'mustache',
], function (MainMenuModel, $, pubsub, Mustache) {
  /**
   * MainMenuController manages all chords edition function
   * @exports MainMenu/MainMenuController
   */
  function MainMenuController(model) {
    this.model = model || new MainMenuModel()
    var self = this
    $.subscribe('MainMenuView-active_menu', function (el, menuTitle) {
      self.activeMenu(menuTitle)
    })
  }

  MainMenuController.prototype.activeMenu = function (menuTitle) {
    var index = this.model.searchMenuIndex(menuTitle)
    if (index !== -1) {
      var currentMenu = this.model.getMenu(index)
      this.model.setCurrentMenu(currentMenu)
      if (this.model.isAllowChangeUrl()) {
        this.pushStateTab(menuTitle)
      }
    }
  }

  MainMenuController.prototype.pushStateTab = function (tabName) {
    var stateObject = {}
    var title = ''
    var newUrl = window.location.href.split('#')[0] + '#' + tabName
    history.pushState(stateObject, title, newUrl)
  }

  MainMenuController.prototype.loadStateTab = function () {
    // Init menu with current location
    var id = decodeURI(window.location.href.split('#')[1])
    if (typeof id !== 'undefined') {
      this.activeMenu(id)
    }
  }

  return MainMenuController
})

define('text!modules/MainMenu/src/MainMenuTemplate.html', [], function () {
  return '<div id="view_main_menu">\n\t<div id="main_menu_first_level"></div>\n\t<div id="main_menu_second_level"></div>\n</div>'
})

define('modules/MainMenu/src/MainMenuView', [
  'modules/MainMenu/src/MainMenuModel',
  'jquery',
  'pubsub',
  'mustache',
  'text!modules/MainMenu/src/MainMenuTemplate.html',
], function (MainMenuModel, $, pubsub, Mustache, MainMenuTemplate) {
  /**
   * MainMenuView is the model containing a set of menu, each menu contain at least a title
   * MainMenuView creates menu template and call each view of menu that are loaded
   * @exports MainMenu/MainMenuView
   */
  function MainMenuView(model, parentHTML) {
    this.model = model ? model : new MainMenuModel()
    this.el = undefined
    this.selectedClassName = 'main_menu_first_level_selected'
    var self = this

    if (typeof parentHTML !== 'undefined') {
      this.initView(parentHTML, function () {
        self.initSubscribe()
        self.initController()
      })
    }
  }

  MainMenuView.prototype.initView = function (parentHTML, callback) {
    var self = this
    //$.get('/modules/MainMenu/src/MainMenuTemplate.html', function(template) {
    var rendered = Mustache.render(MainMenuTemplate)
    parentHTML.innerHTML += rendered
    self.el = parentHTML
    if (typeof callback === 'function') {
      callback()
    }
    //});
  }

  MainMenuView.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('MainMenuModel-addMenu', function (el, menu) {
      // we rebuild everything to take into account the order
      self.removeMenu()
      self.buildMenu()
    })
    $.subscribe('MainMenuModel-removeMenu', function (el, menu) {
      self.removeMenu(menu)
    })
    $.subscribe('MainMenuModel-setCurrentMenu', function (el, menu) {
      self.setCurrentMenu(menu)
    })
  }

  MainMenuView.prototype.initController = function () {
    var self = this
    $('body').on('click', '.main_menu_item', function () {
      var menuTitle = $(this).attr('data-menuTitle')
      $.publish('MainMenuView-active_menu', menuTitle)
    })
  }

  MainMenuView.prototype.buildMenu = function () {
    var first_level = ''
    var second_level = ''
    $('#main_menu_first_level').html()
    $('#main_menu_second_level').html()
    var currentMenu = this.model.getCurrentMenu()
    var currentMenuIndex = -1
    if (typeof currentMenu !== 'undefined') {
      currentMenuIndex = this.model.searchMenuIndex(currentMenu.title)
    }
    var firstClassName = ''
    var secondStyle = ''
    var menu
    for (var i = 0, c = this.model.getMenuLength(); i < c; i++) {
      menu = this.model.getMenu(i)
      secondStyle = ' style="display:none"'
      firstClassName = ''
      if (i === currentMenuIndex) {
        firstClassName = this.selectedClassName
        secondStyle = ''
      }
      first_level +=
        '<div id="' +
        this._concatTitle(menu.title) +
        '_first_level" class="first_level main_menu_item ' +
        firstClassName +
        '" data-menuTitle="' +
        menu.title +
        '">' +
        menu.title +
        '</div>'
      second_level +=
        '<div id="' +
        this._concatTitle(menu.title) +
        '_second_level" class="second_level" data-menuTitle="' +
        menu.title +
        '"' +
        secondStyle +
        '>' +
        menu.view.el +
        '</div>'
    }
    $('#main_menu_first_level').html(first_level)
    $('#main_menu_second_level').html(second_level)

    // init controller
    for (i = 0, c = this.model.getMenuLength(); i < c; i++) {
      menu = this.model.getMenu(i)
      menu.view.initController()
    }
    $.publish('MainMenuView-render')
  }

  MainMenuView.prototype.removeMenu = function (menuTitle) {
    $('#' + menuTitle + '_first_level').remove()
    $('#' + menuTitle + '_second_level').remove()
  }

  MainMenuView.prototype.setCurrentMenu = function (menu) {
    // update view
    this.hideAllMenus(menu)
    this.showMenu(menu)
  }

  MainMenuView.prototype._concatTitle = function (title) {
    return title.replace(' ', '_')
  }

  MainMenuView.prototype.hideAllMenus = function (menu) {
    $('#main_menu_second_level > div').each(function () {
      $(this).hide()
    })
    var self = this
    for (var i = 0, c = this.model.menuList.length; i < c; i++) {
      if (this.model.menuList[i] !== menu) {
        if (this.model.menuList[i].view && typeof this.model.menuList[i].view.unactiveView === 'function') {
          this.model.menuList[i].view.unactiveView()
        }
      }
    }
    // remove active class
    $('.' + this.selectedClassName).each(function () {
      $(this).removeClass(self.selectedClassName)
    })
  }

  MainMenuView.prototype.showMenu = function (menu) {
    var self = this
    // add active class
    $('#' + this._concatTitle(menu.title) + '_first_level').addClass(self.selectedClassName)

    $('#' + this._concatTitle(menu.title) + '_second_level').show(0, function () {
      // self.initController(menuTitle);
      if (typeof menu.view.activeView === 'function') {
        menu.view.activeView()
      }
    })
  }

  MainMenuView.prototype.hide = function () {
    this.el.style.display = 'none'
  }

  MainMenuView.prototype.show = function () {
    this.el.style.display = 'block'
  }

  return MainMenuView
})
define('modules/MainMenu/src/MainMenu', [
  'modules/MainMenu/src/MainMenuController',
  'modules/MainMenu/src/MainMenuModel',
  'modules/MainMenu/src/MainMenuView',
], function (MainMenuController, MainMenuModel, MainMenuView) {
  /**
   * MainMenu constructor
   * @exports MainMenu
   */
  function MainMenu(elemContainer, allowChangeUrl) {
    this.model = new MainMenuModel(allowChangeUrl)
    this.controller = new MainMenuController(this.model)
    new MainMenuView(this.model, elemContainer)
  }
  return MainMenu
})
define('modules/MidiCSL/src/model/NoteModel_MidiCSL', [], function () {
  /**
   * NoteModel_MidiCSL represent a note that is ready to be readed by midi player
   * @exports MidiCSL/NoteModel_MidiCSL
   */
  function NoteModel_MidiCSL(option) {
    this.currentTime =
      typeof option !== 'undefined' && typeof option.currentTime !== 'undefined' ? option.currentTime : 0.0 // currentTime in beat
    this.duration = typeof option !== 'undefined' && typeof option.duration !== 'undefined' ? option.duration : 0.0 // duration in beat
    this.type = typeof option !== 'undefined' && typeof option.type !== 'undefined' ? option.type : undefined // type is melody or chord
    this.midiNote = typeof option !== 'undefined' && typeof option.midiNote !== 'undefined' ? option.midiNote : []
    this.noteIndex =
      typeof option !== 'undefined' && typeof option.noteIndex !== 'undefined' ? option.noteIndex : undefined
  }

  NoteModel_MidiCSL.prototype.getCurrentTime = function () {
    return this.currentTime
  }

  NoteModel_MidiCSL.prototype.setCurrentTime = function (currentTime) {
    if (typeof currentTime === 'undefined' || isNaN(currentTime) || currentTime < 0) {
      throw 'NoteModel_MidiCSL - setCurrentTime - currentTime must be a positive float ' + currentTime
    }
    this.currentTime = currentTime
  }

  NoteModel_MidiCSL.prototype.getDuration = function () {
    return this.duration
  }

  NoteModel_MidiCSL.prototype.setDuration = function (duration) {
    if (typeof duration === 'undefined' || isNaN(duration) || duration < 0) {
      throw 'NoteModel_MidiCSL - setCurrentTime - duration must be a positive float ' + duration
    }
    this.duration = duration
  }

  NoteModel_MidiCSL.prototype.getType = function () {
    return this.type
  }

  NoteModel_MidiCSL.prototype.setType = function (type) {
    if (typeof type === 'undefined') {
      throw 'NoteModel_MidiCSL - setType - type is undefined ' + type
    }
    this.type = type
  }

  NoteModel_MidiCSL.prototype.getMidiNote = function () {
    return this.midiNote
  }

  NoteModel_MidiCSL.prototype.setMidiNote = function (midiNote) {
    if (typeof midiNote === 'undefined') {
      throw 'NoteModel_MidiCSL - setType - midiNote is undefined ' + midiNote
    }
    this.midiNote = midiNote
  }

  NoteModel_MidiCSL.prototype.getNoteIndex = function () {
    return this.noteIndex
  }

  NoteModel_MidiCSL.prototype.getTransposeMidiNote = function (semi_tons) {
    var midiNote = []
    var computedMidiNote
    if (this.midiNote !== 'undefined') {
      for (var i = 0, c = this.midiNote.length; i < c; i++) {
        computedMidiNote = this.midiNote[i] + semi_tons
        if (computedMidiNote >= 21 && computedMidiNote <= 108) {
          midiNote[i] = computedMidiNote
        }
      }
    }
    return midiNote
  }

  NoteModel_MidiCSL.prototype.serialize = function () {
    //return JSON.stringify(this.currentTime + this.duration + this.type + this.midiNote);
    var noteModel_midiCSL = {}
    noteModel_midiCSL.currentTime = this.currentTime
    noteModel_midiCSL.duration = this.duration
    noteModel_midiCSL.type = this.type
    noteModel_midiCSL.midiNote = this.midiNote
    return noteModel_midiCSL
  }

  NoteModel_MidiCSL.prototype.clone = function () {
    return new NoteModel_MidiCSL(this.serialize())
  }

  return NoteModel_MidiCSL
})
define('modules/MidiCSL/src/model/SongModel_MidiCSL', ['modules/MidiCSL/src/model/NoteModel_MidiCSL'], function (
  NoteModel_MidiCSL
) {
  /**
   * SongModel_MidiCSL represent a song that is ready to be readed by midi player
   * @exports MidiCSL/SongModel_MidiCSL
   */
  function SongModel_MidiCSL(option) {
    this.song = typeof option !== 'undefined' && typeof option.song !== 'undefined' ? option.song : []
  }

  SongModel_MidiCSL.prototype.getSong = function () {
    return this.song
  }

  SongModel_MidiCSL.prototype.setSong = function (song, replaceBool) {
    if (typeof replaceBool !== 'undefined' && replaceBool) {
      this.song = song
    } else {
      this.song = this.song.concat(song)
    }
  }

  SongModel_MidiCSL.prototype.setFromType = function (song, type) {
    if (typeof type === 'undefined') {
      return
    }
    for (var i = this.song.length - 1; i >= 0; i--) {
      if (this.song[i].getType() === type) {
        this.song.splice(i, 1)
      }
    }
    this.song = this.song.concat(song)
    /*console.log(this.song);*/
  }

  SongModel_MidiCSL.prototype.getFromType = function (type) {
    var elements = []
    if (typeof type !== 'undefined') {
      for (var i = 0, c = this.song.length; i < c; i++) {
        if (this.song[i].getType() === type) {
          elements.push(this.song[i])
        }
      }
    }
    return elements
  }

  SongModel_MidiCSL.prototype.removeFromType = function (type) {
    if (typeof type === 'undefined') {
      return
    }
    for (var i = this.song.length - 1; i >= 0; i--) {
      if (this.song[i].getType() === type) {
        this.song.splice(i, 1)
      }
    }
  }

  SongModel_MidiCSL.prototype.getLastNote = function () {
    // Looking for last note
    var lastNote = this.song[0]
    var lastNoteEndTime = lastNote.getCurrentTime() + lastNote.getDuration()
    var currentNote, currentEndTime
    for (var i = 0, c = this.song.length; i < c; i++) {
      currentNote = this.song[i]
      if (currentNote && currentNote.getType() !== 'metronome') {
        currentEndTime = currentNote.getCurrentTime() + currentNote.getDuration()
        if (lastNoteEndTime < currentEndTime) {
          lastNoteEndTime = currentEndTime
          lastNote = currentNote
        }
      }
    }
    return lastNote
  }

  SongModel_MidiCSL.prototype.getMidiSoundModelIndex = function (midiSoundModel) {
    if (typeof midiSoundModel !== 'undefined' && midiSoundModel instanceof SongModel_MidiCSL) {
      var comp = midiSoundModel.serialize()
      for (var i = 0, c = this.song.length; i < c; i++) {
        if (this.song[i].serialize() === comp) {
          return i
        }
      }
    }
    return -1
  }

  SongModel_MidiCSL.prototype.getMelodySoundModelFromIndex = function (index) {
    if (!isNaN(index) && index >= 0) {
      for (var i = 0, c = this.song.length; i < c; i++) {
        if (this.song[i].getNoteIndex() === index && this.song[i].getType() === 'melody') {
          return this.song[i]
        }
      }
    }
    return undefined
  }

  SongModel_MidiCSL.prototype.serialize = function () {
    var songModel_midiCSL = {}
    songModel_midiCSL.song = this.song
    return songModel_midiCSL
  }

  SongModel_MidiCSL.prototype.clone = function () {
    return new SongModel_MidiCSL(this.serialize())
  }

  SongModel_MidiCSL.prototype.generateMetronome = function (songModel) {
    var note, duration
    var noteObject = {}
    var metronome = []
    var currentTime = 0
    var notes = []
    var beatUnit = 4
    timeSig = 4
    if (typeof songModel !== 'undefined') {
      timeSig = songModel.timeSignature.getBeats()
      beatUnit = songModel.timeSignature.getBeatUnitQuarter()
    }
    for (var i = 0, c = 200; i < c; i++) {
      if (i % timeSig === 0) {
        notes = [105] // A7
      } else {
        notes = [93] // A6
      }
      duration = 0.5
      noteObject = new NoteModel_MidiCSL({
        midiNote: notes,
        type: 'metronome',
        currentTime: currentTime,
        duration: duration,
      })
      currentTime += beatUnit
      metronome.push(noteObject)
    }
    return metronome
  }

  return SongModel_MidiCSL
})
/**
 * Publishable Events
 * PlayerModel_MidiCSL-onload
 * PlayerModel_MidiCSL-onplay
 * PlayerModel_MidiCSL-onstop
 * PlayerModel_MidiCSL-onpause
 * PlayerModel_MidiCSL-onloopstart
 * PlayerModel_MidiCSL-onfinish
 * PlayerModel_MidiCSL-onvolumechange
 */

//var NoteModel_MidiCSL = require('modules/MidiCSL/src/model/NoteModel_MidiCSL');

define('modules/MidiCSL/src/model/PlayerModel_MidiCSL', [
  'jquery',
  'modules/core/src/SongModel',
  'modules/core/src/NoteModel',
  'modules/MidiCSL/src/converters/SongConverterMidi_MidiCSL',
  'modules/MidiCSL/src/model/SongModel_MidiCSL',
  'Midijs',
  'pubsub',
], function ($, SongModel, NoteModel, SongConverterMidi_MidiCSL, SongModel_MidiCSL, MIDI, pubsub) {
  /**
		 * PlayerModel_MidiCSL is the main midi player class, it creates and reads a SongModel_MidiCSL object from a SongModel
		 * @exports MidiCSL/PlayerModel_MidiCSL
		 * @param {SongModel} songModel     Songmodel that will be read by the midi player
		 * @param {String} soundfontPath url to sond fount
		 * @param {Object} option        contain
			chordsInstrument
			melodyInstrument
			loop				// make the player loop over and over
			activeMetronome		// Boolean that indicates whether the metronome is active or not
			volume				// Float Main volume for all instruments it vary between 0 and 1
		*/
  function PlayerModel_MidiCSL(songModel, soundfontPath, options) {
    options = options || {}
    this.isReady = false // boolean that indicates if player is ready to be played
    this.indexPosition = 0 // represent which notes have been lastly played
    this.playState = false // playState indicate if the player is currently playing or not, (paused player will return false)
    this.songModel = songModel
    this.isEnabled = true //this is initialized on load
    if (songModel) {
      this.tempo = songModel.getTempo()
    }
    this.soundfontPath = soundfontPath

    var initVolume
    if (options.volume !== undefined) {
      // case that developper explicitly declared volume
      initVolume = options.volume
    } else {
      // natural case (it use storage item to get last user volume)
      initVolume = this.initVolume(0.7)
    }
    this.cursorModel = options.cursorModel
    this.cursorNoteModel = options.cursorNoteModel

    this.chords = {
      volume: initVolume,
      tmpVolume: initVolume,
      instrument: typeof options.chordsInstrument !== 'undefined' ? options.chordsInstrument : 0,
    }
    this.melody = {
      volume: initVolume,
      tmpVolume: initVolume,
      instrument: typeof options.melodyInstrument !== 'undefined' ? options.melodyInstrument : 0,
    }
    this.activeMetronome = !!options.activeMetronome
    // When loop attributes is set to true, player will restart after the last note (indefinitively)
    this.loop = !!options.loop

    this.autoload = typeof options.autoload !== 'undefined' ? options.autoload : true
    if (!!this.autoload) {
      this.load()
    }
    this._startTime = 0 // it contain the start timestamp  (when play is pressed), (it change only if player is in pause)
  }

  PlayerModel_MidiCSL.prototype.setSong = function (songModel) {
    if (typeof songModel === 'undefined' || !(songModel instanceof SongModel)) {
      throw "PlayerModel_MidiCSL- setSong, song model shouldn't be empty and should be a SongModel instance" + songModel
    }
    this.songModel = songModel
  }

  PlayerModel_MidiCSL.prototype.load = function () {
    if (typeof MIDI !== 'undefined') {
      this.instrumentsIndex = this.getAllInstrumentsIndex()
      this.instrumentsName = this.getAllInstrumentsName()
      this.initMidiChannels(this.instrumentsIndex)
      this.initMidiPlugin(this.instrumentsName)
    }
  }

  PlayerModel_MidiCSL.prototype.getReady = function () {
    return this.isReady
  }

  PlayerModel_MidiCSL.prototype.setTempo = function (tempo) {
    if (!isNaN(tempo)) {
      this.tempo = tempo
      this.songModel.setTempo(tempo)
    }
  }

  PlayerModel_MidiCSL.prototype.setReady = function (isReady) {
    if (typeof isReady !== 'undefined') {
      this.isReady = isReady
    }
  }

  PlayerModel_MidiCSL.prototype.getPlayState = function () {
    return this.playState
  }

  PlayerModel_MidiCSL.prototype.doLoop = function () {
    return this.loop
  }

  PlayerModel_MidiCSL.prototype.setLoop = function (loop) {
    if (!this.isEnabled) {
      return
    }
    if (typeof loop !== 'undefined') {
      this.loop = !!loop
      $.publish('PlayerModel-toggleLoop', loop)
      return true
    } else {
      return false
    }
  }

  PlayerModel_MidiCSL.prototype.toggleLoop = function () {
    if (this.loop === true) {
      this.setLoop(false)
    } else {
      this.setLoop(true)
    }
    return this.loop
  }

  PlayerModel_MidiCSL.prototype.mute = function () {
    this.chords.tmpVolume = this.getChordsVolume()
    this.melody.tmpVolume = this.getMelodyVolume()
    this.setVolume(0)
  }

  PlayerModel_MidiCSL.prototype.unmute = function () {
    this.setVolume(this.chords.tmpVolume)
  }

  PlayerModel_MidiCSL.prototype.doMetronome = function () {
    return this.activeMetronome
  }

  PlayerModel_MidiCSL.prototype.muteMetronome = function () {
    this.activeMetronome = false
    $.publish('PlayerModel-toggleMetronome', false)
  }

  PlayerModel_MidiCSL.prototype.unmuteMetronome = function () {
    this.activeMetronome = true
    $.publish('PlayerModel-toggleMetronome', true)
  }

  PlayerModel_MidiCSL.prototype.initVolume = function (volume, force) {
    var oldVolume = localStorage.getItem('player-volume')
    if (oldVolume === null) {
      return volume
    }
    return oldVolume
  }

  PlayerModel_MidiCSL.prototype.setVolume = function (volume) {
    if (typeof volume === 'undefined' || isNaN(volume)) {
      throw 'PlayerModel_MidiCSL - setVolume - volume must be a number ' + volume
    }
    $.publish('PlayerModel-onvolumechange', volume)
    this.setMelodyVolume(volume)
    this.setChordsVolume(volume)
    localStorage.setItem('player-volume', volume)
  }

  PlayerModel_MidiCSL.prototype.getChordsVolume = function () {
    return this.chords.volume
  }

  PlayerModel_MidiCSL.prototype.setChordsVolume = function (volume) {
    if (typeof volume === 'undefined' || isNaN(volume)) {
      throw 'PlayerModel_MidiCSL - setChordsVolume - volume must be a number ' + volume
    }
    /*MIDI.setVolume(1, volume * 127);*/
    this.chords.volume = volume
  }

  PlayerModel_MidiCSL.prototype.getMelodyVolume = function () {
    return this.melody.volume
  }

  PlayerModel_MidiCSL.prototype.setMelodyVolume = function (volume) {
    if (typeof volume === 'undefined' || isNaN(volume)) {
      throw 'PlayerModel_MidiCSL - setMelodyVolume - volume must be a number ' + volume
    }
    /*MIDI.setVolume(0, volume * 127);*/
    this.melody.volume = volume
  }

  PlayerModel_MidiCSL.prototype.getChordsInstrument = function () {
    return this.chords.instrument
  }

  PlayerModel_MidiCSL.prototype.setChordsInstrument = function (instrument) {
    if (typeof instrument !== 'undefined') {
      this.chords.instrument = instrument
      $.publish('PlayerModel-onChordsInstrument', instrument)
      return true
    } else {
      return false
    }
  }

  PlayerModel_MidiCSL.prototype.getMelodyInstrument = function () {
    return this.melody.instrument
  }

  PlayerModel_MidiCSL.prototype.setMelodyInstrument = function (instrument) {
    if (typeof instrument !== 'undefined') {
      this.melody.instrument = instrument
      $.publish('PlayerModel-onMelodyInstrument', instrument)
      return true
    } else {
      return false
    }
  }

  PlayerModel_MidiCSL.prototype.getPositionIndex = function () {
    return this.indexPosition
  }

  PlayerModel_MidiCSL.prototype.setPositionIndex = function (indexPosition) {
    if (typeof indexPosition === 'undefined') {
      throw 'PlayerModel_MidiCSL - setPositionIndex - indexPosition must be defined ' + indexPosition
    }
    this.indexPosition = indexPosition
    this.cursorModel.setPos(indexPosition)
    $.publish('CanvasLayer-refresh')
  }

  /**
   * Function set position between 0 and 1
   * @param {int} between 0 and 1
   */
  PlayerModel_MidiCSL.prototype.setPositionInPercent = function (positionInPercent) {
    this.positionInPercent = positionInPercent
    $.publish('PlayerModel-positionPerCent', {
      positionInPercent: positionInPercent,
      songDuration: this.getSongDuration(),
    })
  }

  /**
   * Give position of player in the song
   * @return {float} between 0 (not started) and 1 (finished)
   */
  PlayerModel_MidiCSL.prototype.getPosition = function () {
    if (
      typeof this._startTime === 'undefined' ||
      isNaN(this._startTime) ||
      typeof this.songDuration === 'undefined' ||
      isNaN(this.songDuration)
    ) {
      throw (
        'PlayerModel_MidiCSL - getPosition - _startTime and songDuration must be numbers ' +
        this._startTime +
        ' ' +
        this.songDuration
      )
    }
    var position = (Date.now() - this._startTime) / this.songDuration
    if (position > 1) {
      position = 1
    }
    return position
  }

  PlayerModel_MidiCSL.prototype.getSongDuration = function () {
    return this.songDuration ? this.songDuration : 0
  }

  PlayerModel_MidiCSL.prototype.getBeatDuration = function (tempo) {
    if (typeof tempo === 'undefined' || isNaN(tempo)) {
      throw 'PlayerModel_MidiCSL - getBeatDuration - tempo must be a number ' + tempo
    }
    return 1000 * (60 / tempo)
  }

  /**
   * Launch midi.noteon and noteoff instructions, this function is the main play function
   * @param  {int} tempo in bpm, it influence how fast the song will be played
   * @param  {float} playFrom is an optionnal attributes, if it's filled then player will start to play the note after playFrom, in sec
   * @param  {float} playTo is an optionnal attributes, if it's filled then player will play until playTo in sec, otherwise it play til the end
   */
  PlayerModel_MidiCSL.prototype.play = function (tempo, playFrom, playTo) {
    if (this.isEnabled === false || this.getReady() === false) {
      return
    }
    if (typeof tempo === 'undefined' || isNaN(tempo)) {
      throw 'PlayerModel_MidiCSL - play - tempo must be a number ' + tempo
    }
    this.emptyPlayNotes()
    var self = this
    this.playState = true
    $.publish('PlayerModel-onplay')
    // Convert songmodel to a readable model that we can insert in SongModel_MidiCSL
    SongConverterMidi_MidiCSL.exportToMidiCSL(this.songModel, true, function (midiSong) {
      var midiSongModel = new SongModel_MidiCSL({
        song: midiSong,
      })
      var metronome = midiSongModel.generateMetronome(self.songModel)
      midiSongModel.setFromType(metronome, 'metronome')
      var song = midiSongModel.getSong()
      if (song.length !== 0) {
        var lastNote = midiSongModel.getLastNote() // Looking for last note
        var beatDuration = self.getBeatDuration(tempo)
        self.noteTimeOut = [] // Keep every setTimeout so we can clear them on pause/stop
        var beatOfLastNoteOff = lastNote.getCurrentTime() + lastNote.getDuration()
        var endTime = beatOfLastNoteOff * beatDuration + Date.now()
        self.songDuration = beatOfLastNoteOff * beatDuration
        if (playFrom === undefined || isNaN(playFrom)) {
          var cursorPosition = self.cursorNoteModel ? self.cursorNoteModel.getPos() : [null]

          if (cursorPosition[0] == null) cursorPosition = [0, 0]
          playFrom = 0
          // should check here if cursor is enabled
          if (cursorPosition[0] !== 0) {
            if (typeof midiSongModel.getMelodySoundModelFromIndex(cursorPosition[0]) !== 'undefined') {
              playFrom = midiSongModel.getMelodySoundModelFromIndex(cursorPosition[0]).getCurrentTime() * beatDuration
            } else {
              // case of tie notes
              playFrom =
                midiSongModel.getMelodySoundModelFromIndex(cursorPosition[0] - 1).getCurrentTime() * beatDuration
            }
          }
          if (cursorPosition.length !== 1 && cursorPosition[1] !== cursorPosition[0]) {
            if (typeof midiSongModel.getMelodySoundModelFromIndex(cursorPosition[1]) !== 'undefined') {
              playTo = midiSongModel.getMelodySoundModelFromIndex(cursorPosition[1]).getCurrentTime() * beatDuration
            } else {
              // case of tie notes
              playTo = midiSongModel.getMelodySoundModelFromIndex(cursorPosition[1] - 1).getCurrentTime() * beatDuration
            }
          }
        }

        self._startTime = Date.now() - playFrom

        var velocityMin = 80
        var randomVelocityRange = 40

        var realIndex = 0
        var metronomeChannel = 9

        // for each different position in the song
        for (var i = 0, c = song.length; i < c; i++) {
          var currentNote = song[i]
          if (currentNote && currentNote.getCurrentTime() * beatDuration >= playFrom) {
            // for each notes on a position (polyphonic song will have j > 1)
            for (var j = 0, v = currentNote.getMidiNote().length; j < v; j++) {
              // Use let instead of var when ES6 will be supported across browser
              ;(function (currentNote, realIndex, i, j) {
                self.noteTimeOut[realIndex] = setTimeout(function () {
                  var currentMidiNote, duration, velocityNote, channel, volume
                  var playNote = false
                  if (currentNote.getMidiNote() === 'undefined') {
                    return
                  }
                  currentMidiNote = currentNote.getMidiNote()[j]
                  if (currentMidiNote === false) {
                  } // Silence
                  else {
                    if (currentNote.getType() == 'melody') {
                      channel = self.getMelodyInstrument()
                      volume = 127 * self.getMelodyVolume()
                      velocityNote = Math.random() * randomVelocityRange + velocityMin
                      playNote = true
                    } else if (currentNote.getType() == 'chord') {
                      channel = self.getChordsInstrument()
                      volume = 80 * self.getChordsVolume()
                      velocityNote = Math.random() * randomVelocityRange + velocityMin
                      MIDI.setVolume(channel, 80 * self.getChordsVolume())
                      playNote = true
                    } else if (currentNote.getType() == 'metronome' && self.doMetronome() === true) {
                      channel = metronomeChannel
                      volume = 127 * self.getMelodyVolume()
                      velocityNote = Math.random() * randomVelocityRange + velocityMin
                      playNote = true
                    }
                    if (playNote === true) {
                      MIDI.setVolume(channel, volume)
                      duration = currentNote.getDuration() * (60 / tempo)
                      MIDI.noteOn(channel, currentMidiNote, velocityNote)
                      MIDI.noteOff(channel, currentMidiNote, currentNote.getDuration() * (60 / tempo))
                    }
                  }
                  if (currentNote.getType() == 'melody') {
                    if (typeof currentNote.tieNotesNumber !== 'undefined' && currentNote.tieNotesNumber) {
                      self.setPositionIndex([
                        currentNote.getNoteIndex(),
                        currentNote.getNoteIndex() + currentNote.tieNotesNumber - 1,
                      ])
                    } else {
                      self.setPositionIndex(currentNote.getNoteIndex())
                    }
                    self.setPositionInPercent((Date.now() - self._startTime) / self.songDuration)
                  }
                  if (currentNote == lastNote || currentNote.getCurrentTime() * self.getBeatDuration(tempo) >= playTo) {
                    //self.setPositionInPercent(1);
                    if (self.doLoop() !== false) {
                      self.stop() // TODO stop on setTimeout Else make it buggy
                    }
                    setTimeout(function () {
                      if (self.doLoop() === false) {
                        self.stop()
                        self.setPositionIndex(0)
                        self.setPositionInPercent(0)
                        $.publish('PlayerModel-onfinish')
                      } else {
                        self.play(tempo, playFrom, playTo)
                      }
                    }, duration * 1000)
                  }
                }, currentNote.getCurrentTime() * self.getBeatDuration(tempo) - playFrom)
              })(currentNote, realIndex, i, j)
              realIndex++
            }
          }
        }
      }
    })
  }

  PlayerModel_MidiCSL.prototype.emptyPlayNotes = function () {
    if (typeof MIDI.stopAllNotes !== 'undefined') {
      MIDI.stopAllNotes()
    }
    // melody and metronome
    for (var i in this.noteTimeOut) {
      window.clearTimeout(this.noteTimeOut[i])
    }
  }

  PlayerModel_MidiCSL.prototype.pause = function () {
    this.playState = false
    if (typeof MIDI.stopAllNotes !== 'undefined') {
      MIDI.stopAllNotes()
    }
    // melody and metronome
    for (var i in this.noteTimeOut) {
      window.clearTimeout(this.noteTimeOut[i])
    }
    $.publish('PlayerModel-onpause')
  }

  PlayerModel_MidiCSL.prototype.stop = function () {
    this.playState = false
    if (typeof MIDI.stopAllNotes !== 'undefined') {
      MIDI.stopAllNotes()
    }
    for (var i in this.noteTimeOut) {
      window.clearTimeout(this.noteTimeOut[i])
    }
    this.setPositionIndex(0)
    this.setPositionInPercent(0)
    $.publish('PlayerModel-onstop')
  }

  PlayerModel_MidiCSL.prototype.enable = function () {
    this.isEnabled = true
  }
  PlayerModel_MidiCSL.prototype.disable = function () {
    this.stop()
    this.isEnabled = false
  }

  PlayerModel_MidiCSL.prototype.getAllInstruments = function () {
    // check MIDI/Plugin.js for number (you have to remove 1)
    var instruments = {
      0: 'acoustic_grand_piano',
      /*		27 : "electric_guitar_clean",
				30 : "distortion_guitar",
				24 : "acoustic_guitar_nylon",
				25 : "acoustic_guitar_steel",
				26 : "electric_guitar_jazz",
				33 : "electric_bass_finger",
				34 : "electric_bass_pick",
				56 : "trumpet",
				61 : "brass_section",
				64 : "soprano_sax",*/
      /*65: "alto_sax",*/
      /*		66 : "tenor_sax",
				67 : "baritone_sax",
				73 : "flute",*/
      116: 'taiko_drum',
    }
    return instruments
  }

  PlayerModel_MidiCSL.prototype.getAllInstrumentsIndex = function () {
    var instruments = this.getAllInstruments()
    var instrumentsIndex = []
    for (var instru in instruments) {
      instrumentsIndex.push(instru)
    }
    return instrumentsIndex
  }

  PlayerModel_MidiCSL.prototype.getAllInstrumentsName = function () {
    var instruments = this.getAllInstruments()
    var instrumentsName = []
    for (var instru in instruments) {
      instrumentsName.push(instruments[instru])
    }
    return instrumentsName
  }

  PlayerModel_MidiCSL.prototype.initMidiChannels = function (instruments) {
    if (typeof instruments === 'undefined') {
      throw 'PlayerModel_MidiCSL - initMidiChannels - instruments must be defined'
    }
    var channels = {}
    if (typeof instruments !== 'undefined') {
      for (var i = 0, c = instruments.length; i < c; i++) {
        if (instruments[i] != '116') {
          channels[i] = {
            instrument: parseInt(instruments[i], 10),
            number: parseInt(instruments[i], 10),
            program: parseInt(instruments[i], 10),
            mute: false,
            mono: false,
            omni: false,
            solo: false,
          }
        }
      }
    }
    channels[9] = {
      instrument: 116,
      number: 116,
      program: 116,
      mute: false,
      mono: false,
      omni: false,
      solo: false,
    }
    MIDI.channels = channels
  }
  PlayerModel_MidiCSL.prototype.initMidiPlugin = function (instruments) {
    if (typeof instruments === 'undefined') {
      throw 'PlayerModel_MidiCSL - initMidiPlugin - instruments must be defined'
    }
    var self = this

    MIDI.loadPlugin({
      soundfontUrl: self.soundfontPath,
      instruments: instruments,
      onsuccess: self.MidiPluginIsReady.bind(self),
    })
  }

  PlayerModel_MidiCSL.prototype.MidiPluginIsReady = function () {
    this.setReady(true)
    $.publish('PlayerModel-onload', 'midi')
  }

  return PlayerModel_MidiCSL
})
define('modules/MidiCSL/src/PlayerController_MidiCSL', [
  'jquery',
  'mustache',
  'modules/MidiCSL/src/model/PlayerModel_MidiCSL',
  'utils/UserLog',
  'pubsub',
], function ($, Mustache, PlayerModel_MidiCSL, UserLog, pubsub) {
  /**
   * PlayerController manages all interaction between player view and player model
   * @exports MidiCSL/PlayerController
   */
  function PlayerController(model, view) {
    this.model = model || new PlayerModel_MidiCSL()
    this.view = view
    this.initView()
    this.initSubscribe()
  }

  /**
   * Subscribe to view events
   */
  PlayerController.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('ToPlayer-play', function (el, tempo) {
      $.publish('ToNoteSpaceManager-enable')

      self.play(tempo)
    })
    $.subscribe('ToPlayer-playFromPercent', function (el, obj) {
      self.playFromPercent(obj.tempo, obj.percent)
    })

    $.subscribe('ToPlayer-playPause', function (el, tempo) {
      self.playPause(tempo)
    })

    $.subscribe('ToPlayer-stop', function (el) {
      self.stop()
    })

    $.subscribe('ToPlayer-pause', function (el) {
      self.pause()
    })

    $.subscribe('ToPlayer-onToggleMute', function (el, volume) {
      self.toggleMute(volume)
    })
    $.subscribe('ToPlayer-onVolume', function (el, volume) {
      self.onVolumeChange(volume)
    })
    $.subscribe('ToPlayer-onToggleMetronome', function (el, isMetronome) {
      self.metronomeChange(isMetronome)
    })
    $.subscribe('ToPlayer-onTempo', function (el, tempo) {
      self.onTempoChange(tempo)
    })
    $.subscribe('ToPlayer-toggleLoop', function (el) {
      self.toggleLoop()
    })

    $.subscribe('ToMidiPlayer-enable', function (el) {
      self.enable()
    })
    $.subscribe('ToMidiPlayer-disable', function (el) {
      self.disable()
    })
    $.subscribe('ToPlayer-disableAll', function (el) {
      self.disable()
    })
    $.subscribe('PlayerView-render', function (el) {
      self.initView()
    })

    // Enable midi player when we remove all layers, it means that song has changed
    $.subscribe('ToLayers-removeLayer', function () {
      self.enable()
    })
  }

  /**
   * Function playpause call play if player is in pause, and call pause if player is in play state
   * @param  {int} tempo in BPM
   */
  PlayerController.prototype.playPause = function (tempo) {
    if (this.model.playState) {
      this.pause()
    } else {
      this.play(tempo)
    }
  }

  PlayerController.prototype.playFromPercent = function (tempo, percent) {
    var timeSec = this.model.getSongDuration() * percent
    this.model.play(tempo, timeSec)
  }

  PlayerController.prototype.play = function (tempo, playFrom) {
    this.model.play(tempo, playFrom)
  }

  PlayerController.prototype.stop = function () {
    this.model.stop()
  }

  PlayerController.prototype.pause = function () {
    this.model.pause()
  }

  PlayerController.prototype.tempoChange = function (tempo) {
    this.model.setTempo(tempo)
    this.model.stop()
  }

  PlayerController.prototype.toggleLoop = function () {
    this.model.toggleLoop()
  }

  PlayerController.prototype.toggleMute = function (volume) {
    if (volume === 0) {
      this.model.mute()
    } else {
      this.model.unmute()
    }
  }

  PlayerController.prototype.metronomeChange = function (isMetronome) {
    if (isMetronome) {
      this.model.unmuteMetronome()
    } else {
      this.model.muteMetronome()
    }
  }

  PlayerController.prototype.onTempoChange = function (tempo) {
    this.model.setTempo(tempo)
  }

  PlayerController.prototype.onVolumeChange = function (volume) {
    if (volume === 0) {
      this.model.mute()
    } else {
      this.model.setVolume(volume)
    }
  }

  PlayerController.prototype.onChordInstrumentChange = function (instrument) {
    this.model.setChordsInstrument(instrument)
  }
  PlayerController.prototype.onMelodyInstrumentChange = function (instrument) {
    this.model.setMelodyInstrument(instrument)
  }

  PlayerController.prototype.enable = function () {
    this.model.enable()
  }

  PlayerController.prototype.disable = function () {
    this.model.disable()
  }

  /**
   * Function is called to load the state of the player
   */
  PlayerController.prototype.initView = function () {
    $.publish('PlayerModel-onvolumechange', this.model.getMelodyVolume())
  }

  return PlayerController
})
define('modules/MidiCSL/src/main', [
  'modules/MidiCSL/src/converters/ChordConverterMidi_MidiCSL',
  'modules/MidiCSL/src/converters/ChordManagerConverterMidi_MidiCSL',
  'modules/MidiCSL/src/converters/SongConverterMidi_MidiCSL',
  'modules/MidiCSL/src/model/NoteModel_MidiCSL',
  'modules/MidiCSL/src/model/PlayerModel_MidiCSL',
  'modules/MidiCSL/src/model/SongModel_MidiCSL',
  'modules/MidiCSL/src/PlayerController_MidiCSL',
], function (
  ChordConverterMidi_MidiCSL,
  ChordManagerConverterMidi_MidiCSL,
  SongConverterMidi_MidiCSL,
  NoteModel_MidiCSL,
  PlayerModel_MidiCSL,
  SongModel_MidiCSL,
  PlayerController
) {
  return {
    ChordConverterMidi_MidiCSL: ChordConverterMidi_MidiCSL,
    ChordManagerConverterMidi_MidiCSL: ChordManagerConverterMidi_MidiCSL,
    SongConverterMidi_MidiCSL: SongConverterMidi_MidiCSL,
    NoteModel_MidiCSL: NoteModel_MidiCSL,
    PlayerModel_MidiCSL: PlayerModel_MidiCSL,
    SongModel_MidiCSL: SongModel_MidiCSL,
    PlayerController: PlayerController,
  }
})

define('text!modules/PlayerView/src/PlayerTemplate.html', [], function () {
  return '<div id="playerview">\n\t{{#progressBar}}\n\t<div class="progress progress_bar_player">\n\t\t<div class="progress bar warning" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">\n\t\t\t<span>00:00 - 00:00</span>\n\t\t</div>\n\t</div>\n\t{{/progressBar}}\n\t\n\t<div id="player_buttons_container">\n\t\t\n\t\t<div id="type_button_container" style="display:none">\n\t\t\t<span>MIDI <input type="radio" style="vertical-align: top" name="typeSwitch" value="midi"></span><br/>\n\t\t\t<span>Audio <input type="radio" style="vertical-align: top" name="typeSwitch" value="audio" checked="true"></span>\n\t\t</div>\n\t\t<div id="stop_button_container" class="player_button">\n\t\t\t<div id="stop_button">\n\t\t\t\t<img src="{{imgPath}}/stop.png" alt="stop" title="Stop" />\n\t\t\t</div>\n\t\t\t<div class="player_text">\n\t\t\t\tStop\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div id="play_button_container" class="player_button">\n\t\t\t<div id="play_button">\n\t\t\t\t<img src="{{imgPath}}/play_grey.png" alt="play" title="Play" />\n\t\t\t</div>\n\t\t\t<div class="player_text">\n\t\t\t\tLoading\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div id="pause_button_container" class="player_button">\n\t\t\t<div id="pause_button">\n\t\t\t\t<img src="{{imgPath}}/pause.png" alt="pause" title="Pause" />\n\t\t\t</div>\n\t\t\t<div class="player_text">\n\t\t\t\tPause\n\t\t\t</div>\n\t\t</div>\n\n\t\t<div id="volume_container" class="player_button">\n\t\t\t<span id="all-sound">\n\t\t\t\t<img src="{{imgPath}}/sound_on.png" class="sound_on" alt="sound_on" title="Mute" /><img src="{{imgPath}}/sound_2.png" class="sound_2" alt="sound_2" title="Mute" /><img src="{{imgPath}}/sound_1.png" class="sound_1" alt="sound_1" title="Mute" /><img src="{{imgPath}}/sound_off.png" class="sound_off" alt="sound_off" title="Unmute" />\n\t\t\t</span>\n\t\t\t<div class="player_text">\n\t\t\t\tVolume\n\t\t\t</div>\n\t\t</div>\n\t\t<div id="volume_slider_container">\n\t\t\t<img id="volume_controller_barre" src="{{imgPath}}/barre.png" width="33" height="19" alt="" />\n\t\t\t<img id="volume_controller" src="{{imgPath}}/control_sansbarre.png" width="28" height="68" alt="" />\n\t\t</div>\n\t\t\n\t\t{{#displayTempo}}\n\t\t<div id="tempo_container" style="margin-left:20px">\n\t\t\t<input type="number" value="{{tempo}}" min="20" max="300" id="tempo" name="tempo" />\n\t\t\t<div class="player_text">\n\t\t\t\tTempo\n\t\t\t</div>\n\t\t</div>\n\t\t{{/displayTempo}}\n\n\t\t{{#displayLoop}}\n\t\t<div id="loop_button_container" class="player_button">\n\t\t\t<div id="loop_button">\n\t\t\t\t<img src="{{imgPath}}/loop_grey.png" class="loop_off" alt="loop_off" title="Unactive Loop" /><img src="{{imgPath}}/loop.png" class="loop_on" alt="loop_on" title="Active Loop" />\n\t\t\t</div>\n\t\t\t<div class="player_text">\n\t\t\t\tLoop\n\t\t\t</div>\n\t\t</div>\n\t\t{{/displayLoop}}\n\n\t\t{{#displayMetronome}}\n\t\t<div id="metronome_container" class="player_button">\n\t\t\t<span id="all-metronome">\n\t\t\t\t<img src="{{imgPath}}/metronome_on.png" class="metronome_on" alt="metronome_on" title="Active Metronome" /><img src="{{imgPath}}/metronome_off.png" class="metronome_off" alt="metronome_off" title="Mute Metronome" />\n\t\t\t</span>\n\t\t\t<div class="player_text">\n\t\t\t\tMetronome\n\t\t\t</div>\n\t\t</div>\n\t\t{{/displayMetronome}}\n\n\t</div>\n\t\n</div>'
})

define('modules/PlayerView/src/PlayerView', [
  'jquery',
  'mustache',
  'utils/UserLog',
  'pubsub',
  'text!modules/PlayerView/src/PlayerTemplate.html',
], function ($, Mustache, UserLog, pubsub, PlayerTemplate) {
  /**
   * PlayerView creates player template
   * @exports PlayerView
   * @param {HTMLDOMElement} parentHTML html in which template will be inserted
   * @param {String} imgPath    url where player will look for pictures
   * @param {Object} options    player options : Boolean displayMetronome, displayLoop, displayTempo, progressBar and Integer tempo
   */
  function PlayerView(parentHTML, imgPath, options) {
    options = options || {}
    //PlayerView can be playing Midi, audio or both at the same time
    this.midiPlayer = false
    this.audioPlayer = false

    this.displayMetronome = !!options.displayMetronome
    this.displayLoop = !!options.displayLoop
    this.displayTempo = !!options.displayTempo
    this.progressBar = !!options.progressBar
    this.tempo = options.tempo ? options.tempo : 120
    this.el = undefined
    this.imgPath = imgPath
    this.initSubscribe()
    this.render(parentHTML)
  }

  PlayerView.prototype.render = function (parentHTML) {
    // case el has never been rendered
    var self = this
    parentHTML.innerHTML = Mustache.render(PlayerTemplate, {
      imgPath: self.imgPath,
      displayLoop: self.displayLoop,
      displayTypeSwitch: self.displayTypeSwitch,
      displayMetronome: self.displayMetronome,
      displayTempo: self.displayTempo,
      progressBar: self.progressBar,
      tempo: self.tempo,
    })

    self.el = parentHTML
    self.initController()
    self.initKeyboard()
    $.publish('PlayerView-render')
  }

  /**
   * Publish event after receiving dom events
   */
  PlayerView.prototype.initController = function () {
    var self = this
    $('#play_button_container').click(function () {
      var tempo = self.getTempo()
      $.publish('ToPlayer-play', tempo)
    })
    $('#stop_button_container').click(function () {
      $.publish('ToPlayer-stop')
    })
    $('#pause_button_container').click(function () {
      $.publish('ToPlayer-pause')
    })

    $('#loop_button_container').click(function () {
      if ($('#loop_button_container .loop_on').is(':visible')) {
        $.publish('ToPlayer-toggleLoop', true)
      } else {
        $.publish('ToPlayer-toggleLoop', false)
      }
    })

    // .on('input') Event is fired every time the input changes (work with paste, delete, type things)
    $('#tempo_container #tempo').on('change', function () {
      var tempo = $(this).val()
      $('#pause_button_container').hide()
      $('#play_button_container').show()
      $.publish('ToPlayer-onTempo', tempo)
    })

    $('#metronome_container').click(function () {
      if ($('#metronome_container .metronome_on').is(':visible')) {
        //mute
        $.publish('ToPlayer-onToggleMetronome', false)
      } else {
        //unmute
        $.publish('ToPlayer-onToggleMetronome', true)
      }
    })

    // volume - toggle mute icons
    $('#volume_container').click(function () {
      if ($('#volume_container .sound_off').is(':visible')) {
        $.publish('ToPlayer-onToggleMute')
      } else {
        $.publish('ToPlayer-onToggleMute', 0)
      }
    })
    $('input[type=radio][name=typeSwitch]').on('change', function () {
      $.publish('ToPlayer-stop')
      if ($(this).val() == 'midi') {
        $.publish('ToAudioPlayer-disable')
        $.publish('ToMidiPlayer-enable')
      } else {
        //$(this).val() == 'audio'
        $.publish('ToMidiPlayer-disable')
        $.publish('ToAudioPlayer-enable')
      }
    })

    // volume slider
    var dragStart = false
    $('#volume_controller_barre').bind('dragstart', function (e) {
      e.preventDefault()
      return false
    })
    $('#volume_controller').bind('dragstart', function (e) {
      e.preventDefault()
      return false
    })
    $('#volume_controller_barre').mousedown(function () {
      dragStart = true
    })
    $('#volume_controller_barre').mouseup(function () {
      dragStart = false
    })
    $('body').mouseup(function () {
      dragStart = false
    })
    $('#volume_controller').mousemove(function (evt) {
      if (dragStart) {
        self._dragVolumeController(evt)
      }
    })
    $('#volume_controller').mousedown(function (evt) {
      self._dragVolumeController(evt)
      dragStart = true
    })
    $('#volume_controller').mouseup(function () {
      dragStart = false
    })
    $('#volume_controller_barre').mousemove(function (evt) {
      if (dragStart) {
        self._dragVolumeController(evt)
      }
    })

    $('.progress_bar_player').click(function (e) {
      var width = $(this).width()
      var relX = e.pageX - $(this).parent().offset().left
      var tempo = self.getTempo()
      $.publish('ToPlayer-playFromPercent', {
        tempo: tempo,
        percent: relX / width,
      })

      e.preventDefault()
    })
  }
  PlayerView.prototype.setPlayer = function (type) {
    if (type === 'midi') {
      this.midiPlayer = true
    } else {
      //type === 'audio'
      this.audioPlayer = true
    }
  }

  PlayerView.prototype.unsetPlayer = function (type) {
    if (type === 'midi') {
      this.midiPlayer = false
    } else {
      //type === 'audio'
      this.audioPlayer = false
    }
  }

  PlayerView.prototype.initKeyboard = function () {
    var self = this
    $.subscribe('spacebar', function (el) {
      var tempo = self.getTempo()
      $.publish('ToPlayer-playPause', tempo)
    })
  }

  /**
   * Subscribe to model events
   */
  PlayerView.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('PlayerModel-onplay', function (el) {
      self.play()
    })
    $.subscribe('PlayerModel-onpause', function (el) {
      self.pause()
    })
    $.subscribe('PlayerModel-onstop', function (el) {
      self.pause()
    })
    $.subscribe('PlayerModel-onfinish', function (el) {
      self.pause()
    })

    $.subscribe('PlayerModel-toggleLoop', function (el, isLoop) {
      if (isLoop) {
        self.activeLoop()
      } else {
        self.unactiveLoop()
      }
    })

    $.subscribe('PlayerModel-onvolumechange', function (el, volume) {
      self.setVolume(volume)
    })

    $.subscribe('PlayerModel-onload', function (el, type) {
      self.setPlayer(type)
      self.updateSwitch()
      self.playerIsReady()
    })
    $.subscribe('Audio-disabled', function () {
      self.setPlayer('midi')
      self.unsetPlayer('audio')
      self.updateSwitch()
    })
    $.subscribe('ToAudioPlayer-disable', function () {
      $('input[name=typeSwitch][value=midi]').prop('checked', true)
    })
    $.subscribe('PlayerModel-toggleMetronome', function (el, isMetronome) {
      if (isMetronome) {
        self.muteMetronome()
      } else {
        self.unmuteMetronome()
      }
    })
    $.subscribe('PlayerModel-positionPerCent', function (el, obj) {
      self.updateProgressbar(obj.positionInPercent * 100, obj.songDuration)
    })
    $.subscribe('setPlayerNotReady', function () {
      self.playerIsNotReady()
      $.publish('ToMidiPlayer-disable')
    })
  }

  // play / pause
  PlayerView.prototype.play = function () {
    $('#pause_button_container').show()
    $('#pause_button_container').css('display', 'inline-block')
    $('#play_button_container').hide()
  }

  PlayerView.prototype.pause = function () {
    $('#pause_button_container').hide()
    $('#play_button_container').show()
  }

  // ready
  PlayerView.prototype.playerIsReady = function () {
    $('#play_button img').attr('src', this.imgPath + '/play.png')
    $('#play_button_container .player_text').html('Play')
  }

  PlayerView.prototype.playerIsNotReady = function () {
    $('#play_button img').attr('src', this.imgPath + '/play_grey.png')
    $('#play_button_container .player_text').html('Loading')
  }

  // loop
  PlayerView.prototype.activeLoop = function () {
    $('#loop_button_container .loop_off').hide()
    $('#loop_button_container .loop_on').show()
  }

  PlayerView.prototype.unactiveLoop = function () {
    $('#loop_button_container .loop_on').hide()
    $('#loop_button_container .loop_off').show()
  }

  // volume interface
  PlayerView.prototype.setVolume = function (volume) {
    if (isNaN(volume) || volume < 0) {
      return
    }
    this.adaptSoundButton(volume)
    this.setControllerPosition(1 - volume)
  }

  // metronome
  PlayerView.prototype.muteMetronome = function () {
    $('#metronome_container .metronome_off').hide()
    $('#metronome_container .metronome_on').show()
  }

  PlayerView.prototype.unmuteMetronome = function () {
    $('#metronome_container .metronome_on').hide()
    $('#metronome_container .metronome_off').show()
  }

  PlayerView.prototype.adaptSoundButton = function (volume) {
    if (volume < 0.33) {
      pic = 'sound_off'
    }
    if (0 < volume && volume <= 0.33) {
      pic = 'sound_1'
    } else if (0.33 < volume && volume <= 0.66) {
      pic = 'sound_2'
    } else if (0.66 < volume) {
      pic = 'sound_on'
    }
    if (!$('#volume_container .' + pic).is(':visible')) {
      $('#volume_container .sound_off').hide()
      $('#volume_container .sound_on').hide()
      $('#volume_container .sound_1').hide()
      $('#volume_container .sound_2').hide()
      $('#volume_container .' + pic).show()
    }
  }

  PlayerView.prototype.getTempo = function () {
    var tempo = $('#tempo_container #tempo').val()
    if (typeof tempo === 'undefined') {
      tempo = 120
    }
    return tempo
  }

  PlayerView.prototype._convertSecondToPrintableTime = function (seconds) {
    if (isNaN(seconds)) {
      throw 'PlayerView - _convertSecondToPrintableTime, seconds is not a number ' + seconds
    }
    var date = new Date(null)
    date.setSeconds(seconds) // specify value for SECONDS here
    return date.toISOString().substr(14, 5)
  }

  PlayerView.prototype.updateProgressbar = function (value, duration) {
    var $div = $('.progress_bar_player').find('div')
    $div.attr('aria-valuenow', value)
    $div.css('width', value + '%')
    var $span = $div.find('span')

    var currentTime = ((value / 100) * duration) / 1000
    var durationTime = duration / 1000
    var ct = this._convertSecondToPrintableTime(currentTime)
    var dt = this._convertSecondToPrintableTime(durationTime)
    $span.text(ct + ' / ' + dt)
  }

  PlayerView.prototype._dragVolumeController = function (evt) {
    var heightParent = $('#volume_controller').height()
    var topPositionParent = $('#volume_controller').offset().top
    var topPosition = evt.pageY
    var decal = 5 // shadow of barre at the top/bottom

    var realHeight = heightParent - 2 * decal
    var relativePosition = topPosition - topPositionParent
    if (relativePosition < decal) {
      relativePosition = decal
    }
    if (relativePosition > heightParent - decal) {
      relativePosition = heightParent - decal
    }
    var volume = 1 - (relativePosition - decal) / realHeight
    //this.setControllerPosition((relativePosition - decal) / realHeight);
    $.publish('ToPlayer-onVolume', volume)
  }

  /**
   * Set position of volume controller
   * @param {float} position of controller as a float. 0(volume = 1) <= position <= 1(volume = 0)
   */
  PlayerView.prototype.setControllerPosition = function (position) {
    var decal = 5 // shadow of barre at the top/bottom
    var heightParent = $('#volume_controller').height()
    if (heightParent === null) {
      heightParent = 68
    }
    var realHeight = heightParent - 2 * decal
    var relativePosition = position * realHeight
    if (relativePosition < decal) {
      relativePosition = decal
    }
    if (relativePosition > heightParent - decal) {
      relativePosition = heightParent
    }
    var middleController = $('#volume_controller_barre').height() / 2 // to be at the center of controller
    $('#volume_controller_barre').css({
      top: relativePosition - middleController + 'px',
    })
  }
  PlayerView.prototype.updateSwitch = function () {
    var typeSwitch = $('#type_button_container')
    var visible = typeSwitch.css('display') !== 'none'

    if (this.midiPlayer && this.audioPlayer) {
      if (!visible) {
        typeSwitch.show()
      }
      $('input[name=typeSwitch][value=audio]').prop('checked', true)
    } else {
      typeSwitch.hide()
    }
  }

  PlayerView.prototype.hide = function () {
    this.el.style.display = 'none'
  }

  PlayerView.prototype.show = function () {
    this.el.style.display = 'inline-block'
  }

  return PlayerView
})
define('modules/Tag/src/TagSpaceView', [], function () {
  /**
   * Allow tags to be selected
   * @exports Tag/TagSpaceView
   * @param {Array} position : array of objects like {x:10,y:10,w:20,h:20} (this is because an area can inlcude several lines)
   * @param {String} name     the tag name
   */
  function TagSpaceView(position, name, color) {
    this.position = position
    this.name = name
    this.color = color
  }

  TagSpaceView.prototype.isInPath = function (coords) {
    coords.xe = coords.xe || coords.x
    coords.ye = coords.ye || coords.y //in case xe and ye are not defined, they take the same value a x and y respectively
    var lastPosition = this.position[this.position.length - 1]
    var posXe = lastPosition.x + lastPosition.w
    var posYe = lastPosition.y + lastPosition.h
    return coords.x < posXe && coords.xe > lastPosition.x && coords.y < posYe && coords.ye > lastPosition.y
  }

  TagSpaceView.prototype.isInPathDelete = function (coords) {
    coords.xe = coords.xe || coords.x
    coords.ye = coords.ye || coords.y //in case xe and ye are not defined, they take the same value a x and y respectively
    var lastPosition = this.position[this.position.length - 1]
    var posXe = lastPosition.x + lastPosition.w
    var posYe = lastPosition.y + 20
    var posX = posXe - 20
    return coords.x < posXe && coords.xe > posX && coords.y < posYe && coords.ye > lastPosition.y
  }

  return TagSpaceView
})
define('modules/Tag/src/Tag', ['modules/Edition/src/ElementManager'], function (ElementManager) {
  var Tag = function (tag) {
    return {
      startBeat: tag.startBeat,
      endBeat: tag.endBeat,
      name: tag.name,
      type: tag.type,
      elemMng: new ElementManager(),
    }
  }
  return Tag
})
define('modules/Tag/src/NotesTag', ['modules/Tag/src/Tag'], function (Tag) {
  var NotesTag = function (tagParams, song, noteSpaceMng) {
    var startBeat = tagParams.startBeat
    var endBeat = tagParams.endBeat
    tagParams.type = 'notes'
    var tag = Tag(tagParams)

    tag.getArea = function () {
      var notesMng = song.getComponent('notes')
      var startEnd = notesMng.getIndexesStartingBetweenBeatInterval(startBeat, endBeat, true)
      var fromIndex = startEnd[0],
        toIndex = startEnd[1]

      return tag.elemMng.getElementsAreaFromCursor(noteSpaceMng.noteSpace, [fromIndex, toIndex])
    }
    return tag
  }
  return NotesTag
})
define('modules/Tag/src/ChordsTag', ['modules/Tag/src/Tag'], function (Tag) {
  var ChordsTag = function (tagParams, song, chordSpaceMng) {
    var startBeat = tagParams.startBeat
    var endBeat = tagParams.endBeat
    tagParams.type = 'chords'
    var tag = Tag(startBeat, endBeat, name, 'chords')

    tag.getArea = function () {
      var chordMng = song.getComponent('chords')
      var indexesChords = chordMng.getChordsRelativeToBeat(song, startBeat, endBeat)

      var fromIndex = indexesChords[0].index,
        toIndex = indexesChords[indexesChords.length - 1].index

      return tag.elemMng.getElementsAreaFromCursor(chordSpaceMng.chordSpaces, [fromIndex, toIndex])
    }
    return tag
  }
  return ChordsTag
})
define('modules/Tag/src/TagManager', [
  'modules/Tag/src/TagSpaceView',
  'modules/Tag/src/Tag',
  'modules/Tag/src/NotesTag',
  'modules/Tag/src/ChordsTag',
  'jquery',
  'pubsub',
], function (TagSpaceView, Tag, NotesTag, ChordsTag, $, pubsub) {
  /**
   * Create and display tags
   * @exports Tag/TagManager
   * @param {Object} songModel
   * @param {Array} tags      Array of object that contain at least a startBeat, a endBeat, can also contain a name
   * @param {Array} colors    Array of colors in rgba or hexadecimal or html color
   * @param {Boolean} isActive    Indicates if we draw it or not
   * @param {Boolean} isEditable  Indicates if it's editable or not
   */
  /**
   * [TagManager description]
   * @param {SongModel}  songModel
   * @param {[type]}  elems      [description]
   * @param {[type]}  tags       [description]
   * @param {[type]}  colors     [description]
   * @param {Boolean} isActive   [description]
   * @param {Boolean} isEditable [description]
   */
  function TagManager(songModel, elemManagers, tags, colors, isActive, isEditable) {
    if (!songModel || !elemManagers || (!elemManagers.notes && !elemManagers.chords)) {
      throw 'TagManager- missing params'
    }

    this.songModel = songModel
    this.chordSpaceManager = elemManagers.chords
    this.noteSpaceManager = elemManagers.notes

    this.CL_NAME = 'TagManager'
    this.CL_TYPE = 'CLICKABLE'

    this.colorMap = []
    this.colors = colors || ['#559', '#995', '#599', '#595']
    this.tagSpaces = []
    this.isActive = isActive !== undefined ? isActive : true
    this.isEditable = isEditable !== undefined ? isEditable : false
    this.setTags(tags)
    this.initSubscribe()
  }
  TagManager.prototype.tagCreate = function (tag) {
    tag.type = tag.type || 'notes'
    if (tag.type == 'notes') {
      return new NotesTag(tag, this.songModel, this.noteSpaceManager)
    } else {
      //chords
      return new ChordsTag(tag, this.songModel, this.chordSpaceManager)
    }
  }

  TagManager.prototype.getType = function () {
    return this.CL_TYPE
  }

  TagManager.prototype.getTags = function () {
    return this.tags
  }

  TagManager.prototype.setTags = function (tags) {
    this.tags = []
    if (tags === undefined) {
      throw 'TagManager - setTags tags must be an array '
    }
    for (var i = 0; i < tags.length; i++) {
      this.tags.push(this.tagCreate(tags[i]))
    }
  }

  TagManager.prototype.getColors = function () {
    return this.colors
  }

  TagManager.prototype.setColors = function (colors) {
    if (colors === undefined) {
      throw 'TagManager - setColors colors must be an array ' + colors
    }
    this.colors = colors
    //$.publish('TagManager-setColors', this);
  }

  TagManager.prototype.setActive = function (active) {
    this.isActive = !!active
  }

  TagManager.prototype.getActive = function () {
    return this.isActive
  }

  TagManager.prototype.onSelected = function (coords) {
    var indexTagClicked = this.inPathPosition(coords)
    // console.log(indexTagClicked);
    var self = this
    if (this.tagSpaces[indexTagClicked].isInPathDelete(coords)) {
      //console.log('delete', indexTagClicked);
      this.tags.splice(indexTagClicked, 1)
      $.publish('ToViewer-draw', self.songModel)
    }
  }

  TagManager.prototype.isEnabled = function () {
    return true
  }
  TagManager.prototype.enable = function () {}
  TagManager.prototype.disable = function () {}

  /**
   * Subscribe to view events
   */
  TagManager.prototype.initSubscribe = function () {
    var self = this
    $.subscribe('LSViewer-drawEnd', function (el, viewer) {
      self.drawTags(viewer)
      //	commented as for the moment it is not interactive
      // if (self.noteSpaceManager.viewer.canvasLayer) {
      // 	self.noteSpaceManager.viewer.canvasLayer.addElement(self);
      // }
    })
  }

  TagManager.prototype.isEnabled = function () {
    return this.isActive
  }

  TagManager.prototype.inPathPosition = function (coords) {
    for (var i = 0, c = this.tagSpaces.length; i < c; i++) {
      if (typeof this.tagSpaces[i] !== 'undefined') {
        if (this.tagSpaces[i].isInPath(coords)) {
          return i
        }
      }
    }
    return false
  }

  TagManager.prototype.inPath = function (coords) {
    return false
    //for the moment, tagManager is not clickable. We return false so that CanvasLayer's getOneActiveElement function returns noteManager as active element, and not tagManager

    // if (this.inPathPosition(coords) === false) {
    // 	return false;
    // }
    // return true;
  }

  /**
   * Function takes tags and transform them into TagSpace View that can be displayed on leadsheet,
   * it basically transform beat position to x, y positions
   * @param  {Object} viewer LSViewer
   * @return {Array} array of TagSpaceViews
   */
  TagManager.prototype.getTagAreas = function (i) {
    return this.tags[i].getArea()

    /*var tag;
		var nm = this.songModel.getComponent('notes');
		var fromIndex, toIndex;

		tag = this.tags[i];
		startEnd = nm.getIndexesStartingBetweenBeatInterval(tag.startBeat, tag.endBeat, true);
		fromIndex = startEnd[0];
		toIndex = startEnd[1];
		
		return this.elemMng.getElementsAreaFromCursor(this.elems, [fromIndex, toIndex]);*/
  }

  TagManager.prototype.drawTags = function (viewer) {
    if (this.isActive !== true) {
      return
    }
    if (this.tags.length <= 0) {
      return
    }

    var ctx = viewer.ctx
    this.tagSpaces = []
    var self = this
    var areas

    var numberOfColors = self.colors.length
    var color
    for (var i = 0; i < self.tags.length; i++) {
      areas = self.getTagAreas(i, viewer)
      if (areas.length === 0) {
        console.warn('area not found for ' + i + 'th tag')
        continue
      }
      if (typeof this.tags[i].color !== 'undefined') {
        color = this.tags[i].color
      } else {
        color = this.colors[this.tagSpaces.length % numberOfColors] // permute colors each time
      }
      this.tagSpaces.push(new TagSpaceView(areas, this.tags[i].name, color))
    }

    viewer.drawElem(function () {
      var tagSpace
      var saveFillColor = ctx.fillStyle
      ctx.font = '15px Arial'

      var yDecalToggle = 3
      for (var i = 0; i < self.tagSpaces.length; i++) {
        ctx.globalAlpha = 0.4
        tagSpace = self.tagSpaces[i]
        ctx.fillStyle = tagSpace.color

        var numberOfTagPosition = tagSpace.position.length
        for (var j = 0; j < numberOfTagPosition; j++) {
          //this makes shift a bit tags , useful in case they overlap
          if (i % 2) {
            tagSpace.position[j].y += yDecalToggle
            tagSpace.position[j].h += yDecalToggle
          } else {
            tagSpace.position[j].y -= yDecalToggle
            tagSpace.position[j].h -= yDecalToggle
          }
          //we paint the area
          ctx.fillRect(tagSpace.position[j].x, tagSpace.position[j].y, tagSpace.position[j].w, tagSpace.position[j].h)
        }
        //we write the tag name
        ctx.globalAlpha = 1
        ctx.fillStyle = 'black'
        if (typeof tagSpace.name !== 'undefined') {
          ctx.fillText(tagSpace.name, tagSpace.position[0].x, tagSpace.position[0].y + tagSpace.position[0].h + 15)
        }

        if (self.isEditable === true) {
          ctx.fillStyle = '#666'
          ctx.fillRect(
            tagSpace.position[numberOfTagPosition - 1].x + tagSpace.position[numberOfTagPosition - 1].w - 20,
            tagSpace.position[numberOfTagPosition - 1].y,
            20,
            20
          )
          ctx.fillStyle = '#eee'
          ctx.fillText(
            'X',
            tagSpace.position[numberOfTagPosition - 1].x + tagSpace.position[numberOfTagPosition - 1].w - 20 + 6,
            tagSpace.position[numberOfTagPosition - 1].y + 19
          )
        }
      }
      ctx.fillStyle = saveFillColor
      ctx.globalAlpha = 1
    })
  }

  // no getYs function because it is not selectable
  return TagManager
})
4
define('utils/main', [
  'utils/AjaxUtils',
  'utils/ChordUtils',
  'utils/NoteUtils',
  'utils/PopIn',
  'utils/UserLog',
], function (AjaxUtils, ChordUtils, NoteUtils, PopIn, UserLog) {
  return {
    AjaxUtils: AjaxUtils,
    ChordUtils: ChordUtils,
    NoteUtils: NoteUtils,
    PopIn: PopIn,
    UserLog: UserLog,
  }
})
define('modules/Audio/src/AudioContext', [], function () {
  var AudioContext = window.AudioContext || window.webkitAudioContext
  if (!AudioContext) {
    // create empty Object if no audio api available (IE, phantomJS)
    return function AudioContext() {
      this.createBufferSource = function () {}
    }
  } else {
    return AudioContext
  }
})
define('modules/Audio/src/AudioController', ['jquery', 'pubsub', 'modules/Audio/src/AudioContext'], function (
  $,
  pubsub,
  AudioContext
) {
  /**
   * Low level audio treating
   * @param {Number} timeEndSong given in seconds
   */
  function AudioController(song) {
    this.song = song
    this.audioCtx = new AudioContext()
    this.source = this.audioCtx.createBufferSource()
    this.isEnabled = false //accessed publicly
    this.startedAt
    this.startMargin
    this.pausedAt = 0
    this.tempo
    this.file
    this.isPlaying = false
    this.pos = 0
    this.presetLoop //will be an object
    this.songNumBeats
    this.beatDuration
    this.timeEndSong
  }

  AudioController.prototype._setParams = function (tempo) {
    this.songNumBeats = this.song.getSongTotalBeats()
    this.beatDuration = 60 / tempo
    this.timeEndSong = this.beatDuration * this.songNumBeats //song duration until last beat (without residual audi
  }
  /**
   * @param  {String} url source of audi file
   */
  AudioController.prototype.load = function (url, tempo, startMargin, loop, callback) {
    if (!tempo) {
      throw 'AudioController load missing tempo'
    }
    var xhr = new XMLHttpRequest()
    xhr.open('GET', url)
    xhr.responseType = 'arraybuffer'
    xhr.withCredentials = false
    var self = this

    xhr.onload = function () {
      var audioData = xhr.response
      self.audioCtx.decodeAudioData(
        audioData,
        function (buffer) {
          self.buffer = buffer
          self._setParams(tempo)
          self.startMargin = startMargin || 0
          self.isEnabled = true
          if (loop) {
            self.loop() //initializing loop on whole song
          }
          $.publish('PlayerModel-onload', 'audio')
          $.publish('Audio-Loaded', [self, tempo])
          if (callback) {
            callback()
          }
        },
        function (e) {
          throw 'Error with decoding audio data' + e.err
        }
      )
    }
    xhr.send()
  }

  /**
   * it is called after audio is loaded
   */
  AudioController.prototype.enable = function (dontEnableDrawer) {
    this.isEnabled = true
    if (!dontEnableDrawer) {
      $.publish('AudioDrawer-enable')
    }
  }
  AudioController.prototype.disable = function (dontDisableDrawer) {
    this.stop()
    this.isEnabled = false
    if (!dontDisableDrawer) {
      $.publish('ToLayers-removeLayer')
    }
  }

  AudioController.prototype.play = function (pos) {
    if (this.isPlaying || !this.isEnabled) return
    $.publish('Audio-play', this)
    if (pos) {
      this.pausedAt = pos * 1000
    }
    this.source = this.audioCtx.createBufferSource() // creates a sound source
    this.source.buffer = this.buffer // tell the source which sound to play
    this.source.connect(this.audioCtx.destination) // connect the source to the context's destination (the speakers)

    if (!this.pausedAt) {
      this.startedAt = Date.now()
      this.source.start(0)
    } else {
      this.startedAt = Date.now() - this.pausedAt
      this.source.start(0, this.pausedAt / 1000)
    }
    if (this.presetLoop) {
      this.source.loop = true
      this.source.loopStart = this.presetLoop.from
      this.source.loopEnd = this.presetLoop.to
    }
    this.isPlaying = true

    var self = this
    //on end playing, we stoped if it is in the end of the file
    this.source.onended = function () {
      if (self.getCurrentTime() > self.timeEndSong) {
        self.stop()
      }
    }
    $.publish('PlayerModel-onplay')
  }
  AudioController.prototype.getDuration = function () {
    return this.buffer.duration
  }
  AudioController.prototype.getBeatDuration = function () {
    return this.beatDuration
  }

  /**
   *
   * @param  {Number} now       in milliseconds
   * @param  {Number} loopStart in seconds
   * @param  {Number} loopEnd   in seconds
   * @return {Number}           current time in milliseconds
   */
  AudioController.prototype._calcTime = function (now, loopStart, loopEnd) {
    loopStart *= 1000 //loop boundaries in ms
    loopEnd *= 1000
    var offsetLoopOn = this.offsetLoopOn || 0
    now = now - offsetLoopOn * 1000 //we saved bookmark loopOn, and we substract it

    if (now < loopStart) {
      return now
    } else {
      var offset = now - loopStart
      return loopStart + (offset % (loopEnd - loopStart))
    }
  }

  /**
   * @return {Number} Time in ms (e.g. 1532.4)
   */
  AudioController.prototype._getCurrentPlayingTime = function () {
    var now = Date.now() - this.startedAt /* + this.pos * 1000*/ //in ms
    if (this.source.loop) {
      return this._calcTime(now, this.source.loopStart, this.source.loopEnd)
    } else {
      return now
    }
  }

  /**
   * @return {Number} time in seconds (e.g. 1.5324)
   */
  AudioController.prototype.getCurrentTime = function () {
    var now = this.isPlaying ? this._getCurrentPlayingTime() : this.pausedAt
    return now / 1000
  }

  AudioController.prototype._stopPlaying = function () {
    this.source.stop(0)
    this.isPlaying = false
    this.pos = 0
    $.publish('Audio-stop', this)
  }

  AudioController.prototype.pause = function () {
    if (!this.isPlaying) return
    this._stopPlaying()
    this.pausedAt = this._getCurrentPlayingTime()
    $.publish('PlayerModel-onpause')
  }
  AudioController.prototype.stop = function () {
    if (this.isPlaying) {
      this._stopPlaying()
    }
    this.pausedAt = 0
    $.publish('PlayerModel-onstop')
  }

  /**
   * sets loop
   * @param  {Number} from time start loop (in seconds)
   * @param  {Number} to   time end loop (in seconds)
   */
  AudioController.prototype.loop = function (from, to) {
    from = from || this.startMargin
    to = to || this.timeEndSong + this.startMargin
    if (this.isPlaying) {
      this.source.loop = true
      this.source.loopStart = from
      this.source.loopEnd = to
      // this.offsetLoopOn is needed to get correct current time
      var now = (Date.now() - this.startedAt) / 1000
      if (now > to) {
        // if cursor was after loop, we set offsetLoopOn
        this.offsetLoopOn = now - from
      }
    }
    this.presetLoop = {
      from: from,
      to: to,
    }
  }

  AudioController.prototype.disableLoop = function () {
    if (!this.loopSong) {
      this.startedAt = Date.now() - this._getCurrentPlayingTime() // we update startedAt like if we had made play from here
      this.source.loop = false
      this.presetLoop = null
    }
  }

  /**
   * Enables whole loop song, can only be done if is not playing
   * @return {Boolean} returns true if action could be done, otherwise returns undefined (== falsy)
   */
  AudioController.prototype.enableLoopSong = function () {
    if (!this.loopSong && !this.isPlaying) {
      this.loop(this.startMargin, this.timeEndSong + this.startMargin)
      this.loopSong = true
      return true
    }
  }
  /**
   * Disables whole loop song, can only be done if is not playing
   * @return {Boolean} returns true if action could be done, otherwise returns undefined (== falsy)
   */
  AudioController.prototype.disableLoopSong = function () {
    if (this.loopSong && !this.isPlaying) {
      this.loopSong = false
      this.disableLoop()
      return true
    }
  }
  AudioController.prototype.isLoopSongEnabled = function () {
    return this.loopSong
  }

  /**
   * useful to draw wave
   * @param  {Number} length
   * @param  {Number} startPoint
   * @param  {Number} endPoint
   * @return {Array}
   */
  AudioController.prototype.getPeaks = function (length, startPoint, endPoint) {
    startPoint = startPoint || 0
    endPoint = endPoint || 1

    var sampleStart = ~~(startPoint * this.buffer.length),
      sampleEnd = ~~(endPoint * this.buffer.length),
      sampleSize = (sampleEnd - sampleStart) / length,
      sampleStep = ~~(sampleSize / 10) || 1,
      channels = this.buffer.numberOfChannels,
      //splitPeaks = [],
      mergedPeaks = [],
      /*peaks,*/
      chan,
      start,
      end,
      max,
      c,
      i,
      j,
      value,
      absMax = 0

    for (c = 0; c < channels; c++) {
      //peaks = splitPeaks[c] = [];
      chan = this.buffer.getChannelData(c)
      for (i = 0; i < length; i++) {
        start = ~~(i * sampleSize + sampleStart)
        end = ~~(start + sampleSize)
        max = 0
        for (j = start; j < end; j += sampleStep) {
          value = chan[j]
          if (value > max) {
            max = value
            // faster than Math.abs
          } else if (-value > max) {
            max = -value
          }
        }
        //peaks[i] = max;
        if (c === 0 || max > mergedPeaks[i]) {
          mergedPeaks[i] = max
          if (max > absMax) absMax = max
        }
      }
    }
    return mergedPeaks
  }
  return AudioController
})
define('modules/Audio/src/BarTimesManager', ['modules/core/src/SongBarsIterator'], function (SongBarsIterator) {
  /**
   * We save the time in which each bar finishes
   * @exports Wave/BarTimesManager
   */
  function BarTimesManager() {
    this.barTimes = []
  }

  BarTimesManager.prototype = {
    setBarTimes: function (song, audio) {
      function calculateBarTimes(song, audio) {
        var numBars = song.getComponent('bars').getTotal(),
          songIt = new SongBarsIterator(song),
          barTime = 0,
          barTimes = []

        while (songIt.hasNext()) {
          barTime += songIt.getBarTimeSignature().getBeats() * audio.beatDuration
          barTimes.push(barTime)
          songIt.next()
        }

        if (barTime < audio.getDuration()) {
          barTimes.push(audio.getDuration())
        }
        return barTimes
      }
      this.barTimes = calculateBarTimes(song, audio)
    },
    getLength: function () {
      return this.barTimes.length
    },
    getBarIndexByTime: function (time, barIndex) {
      barIndex = barIndex || 0
      while (barIndex < this.barTimes.length && this.barTimes[barIndex] < time) {
        barIndex++
      }
      return barIndex //to inform the value of index after being updated
    },
    getTimeLimits: function (index) {
      if (index === undefined) throw 'BarTimesManager - error: index not defined'
      return {
        start: index === 0 ? 0 : this.barTimes[index - 1],
        end: this.barTimes[index],
      }
    },
    getCurrBarTime: function (index) {
      var limits = this.getTimeLimits(index)
      return limits.end - limits.start
    },
  }

  return BarTimesManager
})
define('modules/Audio/src/WaveBarView', ['modules/Edition/src/ElementView'], function (ElementView) {
  /**
   * Allow Wave in canvas to be selected
   * @exports Wave/WaveBarView
   */
  function WaveBarView(position, viewerScaler) {
    this.position = position
    this.scaler = viewerScaler
  }
  WaveBarView.prototype.isInPath = function (coords) {
    return ElementView.isInPath(coords, this.position, this.scaler)
  }
  WaveBarView.prototype.isBetweenYs = function (coords) {
    return ElementView.isBetweenYs(coords, this.position, this.scaler)
  }
  WaveBarView.prototype.getArea = function () {
    return this.position
  }
  return WaveBarView
})
define('modules/Audio/src/AudioCursor', [
  'modules/Edition/src/ElementManager',
  'modules/Cursor/src/CursorModel',
], function (ElementManager, CursorModel) {
  function AudioCursor(audioDrawer, viewer, audioAnimation) {
    this.CL_TYPE = 'CURSOR'
    this.CL_NAME = 'audioCursor'
    this.audioDrawer = audioDrawer
    this.viewer = viewer
    this.elemMng = new ElementManager()
    this.audioAnimation = audioAnimation
    this._initSubscribe()
  }

  AudioCursor.prototype._initSubscribe = function () {
    var self = this
    $.subscribe('AudioDrawer-audioDrawn', function () {
      //if (!self.enabled) return;
      self.cursor = new CursorModel(self.audioDrawer.audio.getDuration())
      //if there is no canvasLayer we don't paint cursor
      if (self.viewer.canvasLayer) {
        self.viewer.canvasLayer.addElement(self)
        if (self.audioAnimation) {
          self.audioAnimation.addCursor(self)
        }
        self.updateCursorPlaying(0)
        self.viewer.canvasLayer.refresh()
      }
    })
    $.subscribe('ToWave-setCursor', function (el, cursorStart, cursorEnd) {
      //if audio is not being drawn, no need to move audio cursor
      if (!self.audioDrawer.isEnabled) return

      var beats = self.audioDrawer.songModel.getComponent('notes').getBeatIntervalByIndexes(cursorStart, cursorEnd)
      var startTime = self.audioDrawer.audio.beatDuration * (beats[0] - 1)
      if (self.cursor) {
        self.cursor.setPos([startTime, startTime]) //we equal cursor start and end cursor, because this way the player won't loop
        self.updateCursorPlaying(startTime)
      }
      $.publish('AudioCursor-clickedAudio', startTime)
    })
  }

  /**
   *
   * @param  {Object} coords
   * @param  {Integer} ini  initial cursor position
   * @param  {Integer} end  end cursor position
   * @param  {Boolean} clicked is not used (it is just to respect the parameter order, as this function is called on other objects)
   * @param  {Boolean} mouseUp
   */
  AudioCursor.prototype.onSelected = function (coords, ini, end, clicked, mouseUp) {
    var self = this
    var cursorBars = this.elemMng.getElemsInPath(
      this.audioDrawer.waveBarDimensions,
      coords,
      ini,
      end,
      this.getYs(coords)
    )
    var ys = this.getYs(coords)

    end = end || ini

    if (cursorBars[0] != null && cursorBars[1] != null) {
      var x1, x2
      if (
        (this.elemMng.fromLeftBottom2TopRight(ini, end) || this.elemMng.fromTopRight2BottomLeft(ini, end)) &&
        this.elemMng.includesMultipleLines(ys)
      ) {
        x1 = coords.xe
        x2 = coords.x
      } else {
        x1 = coords.x
        x2 = coords.xe
      }
      var pos1 = this._getAudioTimeFromPos(x1, cursorBars[0])
      var pos2 = this._getAudioTimeFromPos(x2, cursorBars[1])
      this.cursor.setPos([pos1, pos2])
      this.updateCursorPlaying(pos1, cursorBars[0])
    }
    if (mouseUp) {
      var posCursor = this.cursor.getPos()
      if (posCursor[0] != posCursor[1]) {
        //if there is something selected
        $.publish('AudioCursor-selectedAudio', posCursor)
      } else {
        $.publish('AudioCursor-clickedAudio', posCursor)
      }
    }
  }
  AudioCursor.prototype.getType = function () {
    return this.CL_TYPE
  }
  /**
   * @interface
   */
  AudioCursor.prototype.getYs = function (coords) {
    return this.elemMng.getYs(this.audioDrawer.waveBarDimensions, coords)
  }

  // WaveDrawer is a CanvasLayer element, so here, enabled means that user is interacting with it (selecting parts of the wave audio)
  /**
   * @interface
   */
  AudioCursor.prototype.isEnabled = function () {
    return this.enabled
  }

  /**
   * @interface
   */
  AudioCursor.prototype.enable = function () {
    this.enabled = true
  }

  /**
   * @interface
   */
  AudioCursor.prototype.disable = function () {
    this.enabled = false
  }

  /**
   * @interface
   * @param  {Object} ctx Object that usually contain mouse position
   * @return {Boolean}     Boolean indicates if coords position is on wave or not
   */
  AudioCursor.prototype.inPath = function (coords) {
    return !!this.elemMng.getElemsInPath(this.audioDrawer.waveBarDimensions, coords)
  }

  AudioCursor.prototype.drawPlayingCursor = function (ctx) {
    ctx.beginPath()
    ctx.moveTo(this.cursorPos.x, this.cursorPos.y)
    ctx.lineTo(this.cursorPos.x, this.cursorPos.y + this.cursorPos.h)
    ctx.stroke()
  }
  /**
   * @interface
   * @param  {CanvasContext} ctx
   */
  AudioCursor.prototype.drawCursor = function (ctx) {
    var saveFillColor = ctx.fillStyle
    ctx.fillStyle = '#9900FF'
    ctx.globalAlpha = 0.2
    var areas = this.getAreasFromTimeInterval(this.cursor.getStart(), this.cursor.getEnd())
    for (i = 0, c = areas.length; i < c; i++) {
      ctx.fillRect(areas[i].x, areas[i].y, areas[i].w, areas[i].h)
    }
    ctx.fillStyle = saveFillColor
    ctx.globalAlpha = 1
  }

  AudioCursor.prototype.setCursorEditable = function (bool) {
    if (this.cursor) {
      this.cursor.setEditable(bool)
    }
  }

  AudioCursor.prototype.updateCursorPlaying = function (time, barIndex) {
    this.cursorPos = this._getAudioPosFromTime(time, barIndex)
  }

  /**
   * @param  {Float} time      in seconds (e.g. 4.54)
   * @param  {Integer} barIndex number of bar in which the cursor is (should be previously calculated)
   * @return {Object}          e.g. { x: 12, y: 23, w:5, h:5}
   */
  AudioCursor.prototype._getAudioPosFromTime = function (time, barIndex) {
    barIndex = barIndex || this.audioDrawer.barTimesMng.getBarIndexByTime(time)
    var timeBoundaries = this.audioDrawer.barTimesMng.getTimeLimits(barIndex)
    var timeDist = timeBoundaries.end - timeBoundaries.start
    var dim = this.audioDrawer.waveBarDimensions[barIndex].getArea()
    var percent = (time - timeBoundaries.start) / (timeBoundaries.end - timeBoundaries.start)
    var newDim = {}
    newDim.y = dim.y + this.audioDrawer.marginCursor
    newDim.h = dim.h - this.audioDrawer.marginCursor * 2
    newDim.x = dim.x + percent * dim.w
    newDim.w = dim.w
    return newDim
  }
  /**
   * @param  {Integer} x        coordinate x
   * @param  {Integer} barIndex number of bar in which the cursor is (should be previously calculated)
   * @return {Float}  time in seconds (e.g. 3.94)
   */
  AudioCursor.prototype._getAudioTimeFromPos = function (x, barIndex) {
    var timeBoundaries = this.audioDrawer.barTimesMng.getTimeLimits(barIndex)
    var timeDist = timeBoundaries.end - timeBoundaries.start

    var barDim = this.viewer.scaler.getScaledObj(this.audioDrawer.waveBarDimensions[barIndex].getArea())
    var percentPos = (x - barDim.x) / barDim.w

    return percentPos * timeDist + timeBoundaries.start
  }

  AudioCursor.prototype.getAreasFromTimeInterval = function (startTime, endTime) {
    var barTimesMng = this.audioDrawer.barTimesMng
    var startBar = barTimesMng.getBarIndexByTime(startTime)
    var endBar = barTimesMng.getBarIndexByTime(endTime)
    var areas = this.elemMng.getElementsAreaFromCursor(this.audioDrawer.waveBarDimensions, [startBar, endBar])
    var cursor1 = this._getAudioPosFromTime(startTime, startBar)
    var cursor2 = this._getAudioPosFromTime(endTime, endBar)
    if (cursor1.x != cursor2.x) {
      if (cursor1.x > areas[0].x && cursor1.x < areas[0].x + areas[0].w) {
        var space = cursor1.x - areas[0].x
        areas[0].x = cursor1.x
        areas[0].w -= space
      }
      var lastArea = areas[areas.length - 1]

      if (cursor2.x > lastArea.x && cursor2.x < lastArea.x + lastArea.w) {
        lastArea.w = cursor2.x - lastArea.x
      }
    } else {
      areas = []
    }
    return areas
  }
  /**
   * Interface function for AudioAnimation
   * @param  {AudioController} audio
   */
  AudioCursor.prototype.update = function (audio) {
    var currTime = audio.getCurrentTime()
    var barIndex = this.audioDrawer.barTimesMng.getBarIndexByTime(currTime)
    if (barIndex < this.audioDrawer.barTimesMng.getLength()) {
      this.updateCursorPlaying(currTime, barIndex)
    }
  }
  return AudioCursor
})
define('modules/Audio/src/AudioDrawer', [
  'modules/Audio/src/BarTimesManager',
  'modules/core/src/SongBarsIterator',
  'modules/Audio/src/WaveBarView',
  'modules/Audio/src/AudioCursor',
  'jquery',
  'pubsub',
], function (BarTimesManager, SongBarsIterator, WaveBarView, AudioCursor, $, pubsub) {
  function AudioDrawer(songModel, viewer, useAudioCursor, audioAnimation, params) {
    params = params || {}

    this.songModel = songModel
    this.viewer = viewer
    this.tempo // value filled onload
    this.barTimesMng = new BarTimesManager()
    this.audio = null
    this.color = ['#55F', '#99F']
    //params
    this.showHalfWave = !!params.showHalfWave
    this.topAudio = params.topAudio || 80
    this.heightAudio = params.heightAudio || 100
    this.pixelRatio = params.pixelRatio || window.devicePixelRatio
    this.drawMargins = !!params.drawMargins //for debugging
    this.marginCursor = params.marginCursor || 0
    this.useAudioCursor = useAudioCursor
    if (this.useAudioCursor) {
      this.audioAnimation = audioAnimation
    }
    this._initSubscribe()
  }

  AudioDrawer.prototype._initSubscribe = function () {
    var self = this
    $.subscribe('Audio-Loaded', function (el, audio, tempo) {
      self.audio = audio
      self.tempo = tempo
      self.isEnabled = true
      self.barTimesMng.setBarTimes(self.songModel, self.audio)
      self.viewer.setShortenLastBar(true)
      self.adaptViewer()
      self.viewer.forceNewCanvasLayer = true
      self.viewer.draw(self.songModel) // we need to redraw because we change some things on the viewer
      // audio draw is done after viewer draw (event LSViewer-drawEnd)
    })
    $.subscribe('LSViewer-drawEnd', function () {
      if (self.audio && self.audio.isEnabled && self.isEnabled) {
        //we initialize cursor before draw, so that we can capture subscribed events
        if (self.useAudioCursor) {
          self.audioCursor = new AudioCursor(self, self.viewer, self.audioAnimation)
        }
        self.draw(self.barTimesMng, self.tempo, self.audio.getDuration())
      }
    })
    $.subscribe('ToLayers-removeLayer', function () {
      self.disable()
    })
    $.subscribe('AudioDrawer-enable', function () {
      self.enable()
    })
  }

  AudioDrawer.prototype._drawPeaks = function (peaks, area, color, viewer) {
    var ctx = viewer.ctx
    var self = this

    viewer.drawElem(function () {
      // A half-pixel offset makes lines crisp
      var $ = 0.5 / self.pixelRatio
      var width = area.w
      var height = area.h
      var offsetY = area.y
      var halfH = height / 2
      var length = peaks.length
      var scale
      var i, h, maxH

      // if (self.params.fillParent && width != length) {
      //     scale = width / length;
      // }
      maxH = self.showHalfWave ? halfH : height
      scale = width / length
      ctx.fillStyle = color
      if (self.drawMargins) {
        self._drawMargins(area, ctx)
      }

      ctx.beginPath()
      ctx.moveTo(area.x + $, halfH + offsetY)
      // 3 lines for printing the inferior half
      if (!self.showHalfWave) {
        for (i = 0; i < length; i++) {
          h = Math.round(peaks[i] * halfH)
          ctx.lineTo(area.x + i * scale + $, halfH + h + offsetY)
        }
      }

      ctx.lineTo(area.x + width + $, halfH + offsetY)
      ctx.moveTo(area.x + $, halfH + offsetY)

      for (i = 0; i < length; i++) {
        h = Math.round(peaks[i] * maxH)
        ctx.lineTo(area.x + i * scale + $, halfH - h + offsetY)
      }

      ctx.lineTo(area.x + width + $, halfH + offsetY)
      ctx.closePath()
      ctx.fill()
      // Always draw a median line
      ctx.fillRect(area.x, halfH + offsetY - $, width, $)
    })
  }

  AudioDrawer.prototype._drawMargins = function (area, ctx) {
    ctx.beginPath()
    ctx.moveTo(area.x, area.y)
    ctx.lineTo(area.x + area.w, area.y)
    ctx.stroke()

    ctx.moveTo(area.x, area.y + area.h)
    ctx.lineTo(area.x + area.w, area.y + area.h)
    ctx.stroke()
    ctx.closePath()
  }

  /**
   * LSViewer's params are modified so that audio fits (bigger margin between lines)
   */
  AudioDrawer.prototype.adaptViewer = function () {
    if (this.topAudio > 0) {
      // if audio is greater than 0 it means audio will be on top of score line
      this.viewer.setLineMarginTop(this.topAudio)
    } else {
      distance = this.heightAudio - this.topAudio - this.viewer.lineHeight
      if (distance > 0) {
        this.viewer.setLineMarginTop(distance, true)
      }
    }
  }

  AudioDrawer.prototype.disable = function () {
    if (!this.isEnabled) return

    this.isEnabled = false
    this.audioCursor.disable()
    this.viewer.setShortenLastBar(false)
    this.viewer.resetLinesHeight()
    this.viewer.forceNewCanvasLayer = true // force new canvas when redrawing
    this.viewer.draw(this.songModel)
  }

  AudioDrawer.prototype.enable = function () {
    this.isEnabled = true
    this.audioCursor.enable()
    this.viewer.setShortenLastBar(true)
    this.adaptViewer()
    this.viewer.forceNewCanvasLayer = true // force new canvas when redrawing
    this.viewer.draw(this.songModel)
  }

  AudioDrawer.prototype.draw = function (barTimesMng, tempo, duration) {
    if (!tempo || !duration) {
      throw 'AudioDrawer - missing parameters, tempo : ' + tempo + ', duration:' + duration
    }
    /**
     * @param  {Array} peaksPerBar array of arrays of peaks representing peaks for each bar
     * @return {Array}             same array normalized
     */
    function normalize(peaksPerBar) {
      var NORM_FACTOR = 0.8 //if 1, maximum will draw until the very top of the audio space
      var max = 0
      for (var i = 0; i < peaksPerBar.length; i++) {
        for (var j = 0; j < peaksPerBar[i].length; j++) {
          if (peaksPerBar[i][j] > max) max = peaksPerBar[i][j]
        }
      }
      if (max !== 0) {
        for (var i = 0; i < peaksPerBar.length; i++) {
          for (var j = 0; j < peaksPerBar[i].length; j++) {
            peaksPerBar[i][j] /= max / NORM_FACTOR
          }
        }
      }
      return peaksPerBar
    }

    this.waveBarDimensions = []
    var numBars = barTimesMng.getLength()
    var area,
      dim,
      prevDim,
      bar,
      barTime = 0,
      sliceSong,
      start = 0,
      peaks,
      toggleColor = 0,
      peaksPerBar = []
    // we get peaks for each measure
    for (var i = 0; i < barTimesMng.getLength(); i++) {
      sliceSong = barTimesMng.getCurrBarTime(i) / duration
      prevDim = dim
      dim = this.viewer.barWidthMng.getDimensions(i)

      if (!dim) {
        dim = prevDim
        dim.left = dim.left + dim.width
        dim.width = dim.width / this.viewer.LAST_BAR_WIDTH_RATIO - dim.width
      }
      waveBarView = new WaveBarView(
        {
          x: dim.left,
          y: dim.top - this.viewer.CHORDS_DISTANCE_STAVE - this.topAudio,
          w: dim.width,
          h: this.heightAudio,
        },
        this.viewer.scaler
      )

      this.waveBarDimensions.push(waveBarView)
      area = waveBarView.getArea()
      peaks = this.audio.getPeaks(area.w, start, start + sliceSong)
      peaksPerBar.push(peaks)
      start += sliceSong
    }
    //normalize
    peaksPerBar = normalize(peaksPerBar)
    // and drraw them
    for (var i = 0; i < this.waveBarDimensions.length; i++) {
      peaks = peaksPerBar[i]
      area = this.waveBarDimensions[i].getArea()
      this._drawPeaks(peaks, area, this.color[toggleColor], this.viewer)
      toggleColor = (toggleColor + 1) % 2
    }
    $.publish('AudioDrawer-audioDrawn', this)
  }
  return AudioDrawer
})
define('modules/Audio/src/AudioPlayer', ['jquery', 'pubsub'], function ($, pubsub) {
  function AudioPlayer(audio) {
    this.audio = audio
    this._initSubscribe()
    this.startPos = 0
    this.endPos = 0
    this.loopEnabled = false
  }
  AudioPlayer.prototype._initSubscribe = function () {
    var self = this
    $.subscribe('AudioCursor-clickedAudio', function (el, posCursor) {
      self.startPos = posCursor
      self.audio.disableLoop()
    })
    $.subscribe('AudioCursor-selectedAudio', function (el, startPos, endPos) {
      self.startPos = startPos
      self.endPos = endPos
      self.audio.loop(startPos, endPos)
    })
    $.subscribe('ToPlayer-play', function () {
      self.audio.play(self.startPos)
    })
    $.subscribe('ToPlayer-pause', function () {
      self.startPos = null
      self.audio.pause()
    })
    $.subscribe('Audio-end', function () {
      self.startPos = null
    })
    $.subscribe('ToPlayer-stop', function () {
      self.startPos = null
      self.audio.stop()
    })
    $.subscribe('ToAudioPlayer-disable', function () {
      self.audio.disable(true) //true to not disable audio
    })
    $.subscribe('ToAudioPlayer-enable', function () {
      self.audio.enable(true) //true to not disable audio
    })
    $.subscribe('ToPlayer-toggleLoop', function () {
      var toggle
      if (self.loopEnabled) {
        toggle = self.audio.disableLoopSong()
      } else {
        toggle = self.audio.enableLoopSong()
      }
      if (toggle) {
        self.loopEnabled = !self.loopEnabled
        $.publish('PlayerModel-toggleLoop', self.loopEnabled)
      }
    })
  }

  return AudioPlayer
})
define('modules/Audio/src/AudioAnimation', [], function () {
  /**
   * This object centralizes restartAnimation loops. Different cursors can be 'subscribed' to it. They need to have an 'update' method
   */
  function AudioAnimation() {
    //this.animationId;
    this.cursors = []
    this._initSubscribe()
    this.canvasLayer //canvasLayer is initialised on viewer draw (see _initSubscribe)
  }
  AudioAnimation.prototype._initSubscribe = function () {
    var self = this
    $.subscribe('LSViewer-drawEnd', function (el, viewer) {
      self.canvasLayer = viewer.canvasLayer
    })
    $.subscribe('Audio-play', function (el, audio) {
      self.restartAnimationLoop(audio)
    })
    $.subscribe('Audio-stop', function (el, audio) {
      if (self.animationId) {
        window.cancelAnimationFrame(self.animationId)
        self.animationId = null
      }
    })
  }
  AudioAnimation.prototype.restartAnimationLoop = function (audio) {
    var self = this
    if (!self.canvasLayer) {
      throw 'AudioAnimation.canvasLayer is undefined: probably event LSViewer-drawEnd was published before AudioAnimation was constructed'
    }
    var requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame

    var frame = function () {
      self.animationId = requestFrame(frame)
      for (var i = 0; i < self.cursors.length; i++) {
        self.cursors[i].update(audio)
      }
      self.canvasLayer.refresh()
    }
    frame()
  }

  AudioAnimation.prototype.addCursor = function (cursor) {
    this.cursors.push(cursor)
  }

  return AudioAnimation
})
define('modules/Audio/src/NotesCursorUpdater', [], function () {
  /**
   * Makes cursor notes move while playing
   * @param {SongModel} song   song is a dependency and not 'NoteManager', because there are cases in which we change entirely the
   *                           note manager, so we need to reference to song in order to continue it making work
   * @param {CursorModel} notesCursor
   */
  function NotesCursorUpdater(song, notesCursor) {
    this.song = song
    this.notesCursor = notesCursor
    this.prevINote = 0
  }

  NotesCursorUpdater.prototype.update = function (audio) {
    var currTime = audio.getCurrentTime()
    var noteMng = this.song.getComponent('notes')
    var iNote = noteMng.getPrevIndexNoteByBeat(currTime / audio.beatDuration + 1)
    if (iNote != this.prevINote && iNote < this.notesCursor.getListLength()) {
      this.notesCursor.setPos(iNote)
      this.prevINote = iNote
    }
  }
  return NotesCursorUpdater
})
define('modules/Audio/src/ChordsCursorUpdater', [], function () {
  /**
   * [ChordsCursorUpdater description]
   * @param {SongModel} song
   * @param {Cursor} chordsCursor
   * @param {String} chordSpaceManagerType	values: 'ALL_CHORDS_SPACES' or 'ONLY_CHORDS' see ChordSpaceManager params (should have the same value as chordSpaceManager)
   */
  function ChordsCursorUpdater(song, chordsCursor, chordSpaceManagerType) {
    this.chordMng = song.getComponent('chords')
    this.chordsCursor = chordsCursor
    this.prevIChord = 0
    this.chordSpaceManagerType = chordSpaceManagerType || 'ALL_CHORD_SPACES'
    this.beatsIndex = this.chordMng.getBeatsBasedChordIndexes(song)
  }
  ChordsCursorUpdater.prototype._getChordIndex = function (time) {
    var onlyChords = this.chordSpaceManagerType === 'ONLY_CHORDS'
    for (var i = 0; i < this.beatsIndex.length; i++) {
      if (this.beatsIndex[i] > time) {
        return onlyChords ? i - 1 : this.beatsIndex[i - 1] - 1
      }
    }
    return onlyChords ? this.beatsIndex.length - 1 : this.beatsIndex[this.beatsIndex.length - 1] - 1
  }
  /**
   * Interface function used in AudioAnimation. Updates chords cursor when playing
   * @param  {AudioController} audio
   */
  ChordsCursorUpdater.prototype.update = function (audio) {
    var currTime = audio.getCurrentTime()
    var iChord = this._getChordIndex(currTime / audio.beatDuration + 1)
    if (iChord != this.prevIChord) {
      this.chordsCursor.setPos(iChord)
      this.prevIChord = iChord
    }
  }
  return ChordsCursorUpdater
})
define('modules/Audio/src/AudioModule', [
  'modules/Audio/src/AudioController',
  'modules/Audio/src/AudioDrawer',
  'modules/Audio/src/AudioCursor',
  'modules/Audio/src/AudioPlayer',
  'modules/Audio/src/AudioAnimation',
  'modules/Audio/src/NotesCursorUpdater',
  'modules/Audio/src/ChordsCursorUpdater',
], function (
  AudioController,
  AudioDrawer,
  AudioCursor,
  AudioPlayer,
  AudioAnimation,
  NotesCursorUpdater,
  ChordsCursorUpdater
) {
  function AudioModule(song, params) {
    params = params || {}
    var audio = new AudioController(song)
    new AudioPlayer(audio)

    if (params) {
      var paramsDrawer = {
        showHalfWave: true,
        //drawMargins: true,
        topAudio: -120,
        heightAudio: 75,
      }
      // useAudioCursor unless it is explicitly set to false (default is true)
      var useAudioCursor = params.audioCursor === undefined || params.audioCursor === true
      var audioAnimation = null
      if (useAudioCursor || params.notesCursor) {
        var notesCursor = params.notesCursor
        var chordsCursor = params.chordsCursor
        audioAnimation = new AudioAnimation()

        if (notesCursor) {
          var notesCursorUpdater = new NotesCursorUpdater(song, notesCursor)
          audioAnimation.addCursor(notesCursorUpdater)
        }
        if (chordsCursor) {
          var chordsCursorUpdater = new ChordsCursorUpdater(song, chordsCursor, params.chordSpaceManagerType)
          audioAnimation.addCursor(chordsCursorUpdater)
        }
      }
      if (params.viewer) {
        var audioDrawer = new AudioDrawer(song, params.viewer, useAudioCursor, audioAnimation, paramsDrawer)
        audio.drawer = audioDrawer //needed for other modules like audioComments
      }
    }

    return audio
  }
  return AudioModule
})
//TODO: we should add jquery and pubsub, but it's working anyway??? no clear what's going on
define('modules/Edition/src/KeyboardManager', ['utils/NoteUtils', 'jquery', 'pubsub'], function (NoteUtils, $, pubsub) {
  /**
   * KeyboardManager allows to interact with keyboard using pubsub events
   * @exports Edition/KeyboardManager
   */
  function KeyboardManager(test) {
    var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0

    function stopEvent(evt) {
      evt.preventDefault()
      evt.stopPropagation()
      return false
    }

    function preventBackspace(evt, d) {
      var doPrevent = false
      if (
        d.tagName.toUpperCase() === 'TEXTAREA' ||
        (d.tagName.toUpperCase() === 'INPUT' &&
          (d.type.toUpperCase() === 'TEXT' ||
            d.type.toUpperCase() === 'PASSWORD' ||
            d.type.toUpperCase() === 'FILE' ||
            d.type.toUpperCase() === 'NUMBER'))
      ) {
        doPrevent = d.readOnly || d.disabled
      } else {
        doPrevent = true
      }
      if (doPrevent) {
        // console.log('prevent');
        stopEvent(evt)
      }
    }

    function isInHtmlInput(d) {
      return (
        d.tagName.toUpperCase() === 'TEXTAREA' ||
        d.tagName.toUpperCase() === 'SELECT' ||
        (d.tagName.toUpperCase() === 'INPUT' &&
          (d.type.toUpperCase() === 'TEXT' ||
            d.type.toUpperCase() === 'PASSWORD' ||
            d.type.toUpperCase() === 'FILE' ||
            d.type.toUpperCase() === 'NUMBER'))
      )
    }

    function publish(eventName, evt, param) {
      if (test) {
        console.log('keyboard ' + eventName)
      }
      $.publish(eventName, [param, evt])
      stopEvent(evt)
    }

    /**
     * keypress event   automatically triggers AFTER keydown event (but not always more info: http://help.dottoro.com/ljlwfxum.php and http://unixpapa.com/js/key.html).
     * In our case it will be called just if keydown function does not find the corresponding action, as if it does, it calls our publish() function which stops the event propagation (by stopEvent())
     * The only example when this triggers (by the moment) is in AZERTY configured keyboards on SAFARI browser (on Mac)
     */
    $(document).keypress(function (evt) {
      // sometimes key does not map to any command in our list, if so, we allow default usage,
      // however the code that follows does not apply to other browsers than safari
      if (!isSafari) {
        return
      }
      var keyCode = evt === null ? event.keyCode : evt.keyCode
      if (keyCode == 34) {
        publish('number-key', evt, 3)
      } else if (keyCode == 39) {
        publish('number-key', evt, 4)
      }
    })

    $(document).keydown(function (evt) {
      var keyCode = evt === null ? event.keyCode : evt.keyCode
      var key = String.fromCharCode(keyCode).toLowerCase()
      var ctrlMetaKey = !!(evt.metaKey || evt.ctrlKey)
      // console.log("metaKey");
      // console.log(metaKey);

      var d = evt.srcElement || evt.target
      var ACC_KEYS = {
        s: '#',
        v: 'b',
        n: 'n',
      }
      var inc
      if (keyCode === 8) {
        preventBackspace(evt, d)
      }
      if (isInHtmlInput(d) && keyCode != 9) {
        //if it's tab, we do run the event, even if it's in an html input, as this helps in chord edition
        //do nothing
        return
      }
      if (keyCode == 17) {
        //ctrl
        publish('ctrlPressed', evt)
        return
      }
      if (!ctrlMetaKey) {
        if (keyCode == 38 || keyCode == 40) {
          // up & down arrows
          inc = keyCode == 38 ? 1 : -1
          publish('updown-arrows', evt, inc)
        } else if (NoteUtils.getValidPitch(key) != -1 && !ctrlMetaKey) {
          publish('pitch-letter-key', evt, key.toUpperCase())
        } else if (ACC_KEYS.hasOwnProperty(key) && !ctrlMetaKey) {
          var acc = ACC_KEYS[key]
          // console.log(acc);
          if (evt.shiftKey) {
            publish('shift-accidental-key', evt, acc)
          } else {
            publish('accidental-key', evt, acc)
          }
        } else if (parseInt(key, null) >= 1 && parseInt(key, null) <= 9) {
          publish('number-key', evt, key)
        } else if (keyCode == 190 || keyCode == 59) {
          publish('dot-key', evt, evt.shiftKey)
          stopEvent(evt)
        } else if (keyCode == 58) {
          publish('colon-key', evt)
          stopEvent(evt)
        } else if (keyCode == 84) {
          // T be carefull, set key to t will be call on F5 also
          if (evt.shiftKey) {
            publish('shift-t-key', evt)
          } else {
            publish('t-key', evt)
          }
        } else if (keyCode == 82) {
          // R
          publish('R-key', evt)
        } else if (keyCode == 75) {
          // R
          publish('K-key', evt)
        } else if (keyCode == 46 || keyCode == 8) {
          //supr
          publish('supr-key', evt) // in our editor we want to replace note by silence and not delete note
        } else if (keyCode == 13) {
          //enter
          publish('enter-key', evt)
        } else if (keyCode == 32) {
          publish('spacebar', evt)
        } else if (keyCode == 9) {
          inc = evt.shiftKey ? -1 : 1
          publish('tab-key', evt, inc)
        } else if (keyCode == 36) {
          //begin
          if (evt.shiftKey) {
            publish('shift-begin', evt)
          } else {
            publish('begin', evt)
          }
        } else if (keyCode == 35) {
          //end
          if (evt.shiftKey) {
            publish('shift-end', evt)
          } else {
            publish('end', evt)
          }
        } else if (keyCode == 37 || keyCode == 39) {
          // left-right arrows
          inc = keyCode == 39 ? 1 : -1
          if (evt.shiftKey) {
            publish('shift-leftright-arrows', evt, inc)
          } else {
            publish('leftright-arrows', evt, inc)
          }
        }
      } else {
        if (keyCode == 67) {
          // Ctrl + c or Command + c (mac or windows specific key)
          publish('ctrl-c-key', evt)
        } else if (keyCode == 86) {
          // Ctrl + v or Command + v (mac or windows specific key)
          publish('ctrl-v-key', evt)
        } else if (keyCode === 90) {
          // Ctrl + z
          publish('ctrl-z', evt)
        } else if (keyCode === 89) {
          // Ctrl + y
          publish('ctrl-y', evt)
        } else if (keyCode === 65) {
          // Ctrl + y
          publish('ctrl-a', evt)
        } else if (keyCode == 37 || keyCode == 39) {
          // left-right arrows
          inc = keyCode == 39 ? 1 : -1
          publish('ctrl-leftright-arrows', evt, inc)
        }
      }
    })
    $(document).keyup(function (evt) {
      var keyCode = evt === null ? event.keyCode : evt.keyCode
      if (keyCode == 17) {
        //ctrl
        publish('ctrlUnpressed', evt)
      }
    })
  }
  return KeyboardManager
})
define('LJS', [
  'modules/Comments/src/CommentsController',
  'modules/ChordEdition/src/ChordEdition',
  'modules/chordSequence/src/SongView_chordSequence',
  'modules/converters/MusicCSLJson/src/main',
  'modules/converters/MusicXML/src/main',
  'modules/core/src/main', // most important module
  'modules/Cursor/src/Cursor',
  'modules/Edition/src/Edition',
  'modules/FileEdition/src/FileEdition',
  'modules/History/src/HistoryC',
  'modules/LSViewer/src/LSViewer',
  'modules/LSViewer/src/OnWindowResizer',
  'modules/MainMenu/src/MainMenu',
  'modules/MidiCSL/src/main',
  'modules/NoteEdition/src/NoteEdition',
  'modules/NoteEdition/src/NoteSpaceManager',
  'modules/PlayerView/src/PlayerView',
  'modules/core/src/SongModel',
  'modules/converters/MusicCSLJson/src/SongModel_CSLJson',
  'modules/StructureEdition/src/StructureEdition',
  'modules/Tag/src/TagManager',
  'utils/main',
  'modules/Audio/src/AudioModule',
  'modules/Edition/src/KeyboardManager',
  'jquery',
], function (
  Comments,
  ChordEdition,
  chordSequence,
  convertersMusicCSLJson,
  convertersMusicXML,
  core,
  Cursor,
  Edition,
  FileEdition,
  HistoryC,
  LSViewer,
  OnWindowResizer,
  MainMenu,
  MidiCSL,
  NoteEdition,
  NoteSpaceManager,
  PlayerView,
  SongModel,
  SongModel_CSLJson,
  StructureEdition,
  TagManager,
  utils,
  AudioModule,
  KeyboardManager,
  $
) {
  function singleton(constructorFn) {
    var instance
    return {
      getInstance: function () {
        if (!instance) {
          instance = constructorFn(arguments)
        }
        return instance
      },
    }
  }
  //constructors for different singletons:
  //
  var notesCursorConstructor = function (args) {
    var songModel = args[0]
    return cursorConstructor(songModel, 'notes')
  }
  var playerCursorConstructor = function (args) {
    var songModel = args[0]
    return cursorConstructor(songModel, 'player')
  }
  var cursorConstructor = function (songModel, id) {
    return new Cursor(songModel.getComponent('notes'), id, 'arrow').model
  }

  //singletons used
  var snglNotesCursor = singleton(notesCursorConstructor)
  var snglPlayerCursor = singleton(playerCursorConstructor)
  var snglNotesManager = singleton(function (args) {
    var songModel = args[0]
    var viewer = args[1]
    return new NoteSpaceManager(snglNotesCursor.getInstance(songModel), viewer, 'NotesCursor', null, true, false)
  })
  var snglKeyBoardManager = singleton(function () {
    return new KeyboardManager(false)
  })

  //functions loading different modules

  function loadViewer(htmlElem, options, song) {
    options = options || {}
    var viewer = new LSViewer(htmlElem, options)
    OnWindowResizer(song)
    return viewer
  }

  function loadPlayer(options, songModel) {
    function loadMidiPlayer(playerView, soundfontUrl) {
      var player = new MidiCSL.PlayerModel_MidiCSL(songModel, soundfontUrl, {
        cursorModel: snglPlayerCursor.getInstance(songModel),
        cursorNoteModel: snglNotesCursor.getInstance(songModel),
      })
      new MidiCSL.PlayerController(player, playerView)
      return player
    }
    var players = {}

    var useAudio = !!options.audio
    var useMidi = options.midi && options.midi.soundfontUrl

    var playerViewOptions = options.viewOptions
    playerViewOptions.displaySwitch = useAudio && useMidi && options.audio.audioFile //if audioFile is not defined, we do not load displayTypeSwitch
    playerViewOptions.tempo = !isNaN(songModel.getTempo()) ? songModel.getTempo() : null

    var playerView = new PlayerView(options.HTMLElement, options.imgUrl, playerViewOptions)

    new NoteSpaceManager(snglPlayerCursor.getInstance(songModel), viewer, 'PlayerCursor', '#0AA000', false, false)

    if (options.interactive) {
      snglNotesManager.getInstance(songModel, viewer)
    }

    snglKeyBoardManager.getInstance()

    if (useMidi) {
      players.midiPlayer = loadMidiPlayer(playerView, options.midi.soundfontUrl)
    }

    if (useAudio) {
      $.publish('ToMidiPlayer-disable')
      var audioModule = new AudioModule(songModel, {
        viewer: viewer,
        notesCursor: snglPlayerCursor.getInstance(),
      })
      if (options.audio.audioFile) {
        audioModule.load(options.audio.audioFile, options.audio.tempo)
      }
      players.audioPlayer = audioModule
    }
    return players
  }

  function loadEdition(viewer, songModel, menuHTML, params) {
    snglKeyBoardManager.getInstance()
    var menu, menuModel
    if (menuHTML && (params.notes || params.chords || params.structure)) {
      menu = new MainMenu(menuHTML)
      menuModel = menu.model
      menuModel.options = {}
      if (params.notes) {
        menuModel.options.notes = {
          active: true,
          menu: {
            title: 'Notes',
            order: 3,
          },
          imgPath: params.imgUrl.notes,
        }
      }
      if (params.chords) {
        menuModel.options.chords = {
          active: true,
          /// menu: {
          //	title: 'Chords',
          //	order: 4
          //},
          imgPath: params.imgUrl.chords,
          menu: false, // if we don't want menu
        }
      }
      if (params.structure) {
        menuModel.options.structure = {
          active: true,
          menu: {
            title: 'Structure',
            order: 5,
          },
          imgPath: params.imgUrl.structure,
        }
      }
    }
    if (params.notes) {
      params.snglNotesManager = snglNotesManager
      params.snglNotesCursor = snglNotesCursor
    }
    var returnObj = {
      edition: new Edition(viewer, songModel, menuModel, params),
    }
    if (menu) returnObj.menuController = menu.controller
    if (menuModel) returnObj.menuModel = menuModel
    return returnObj
  }

  //LJS object:
  //returns modules to be used by client
  var LJS = {
    Comments: Comments,
    //"chordSequence": chordSequence,
    converters: {
      MusicCSLJson: convertersMusicCSLJson,
      MusicXML: convertersMusicXML,
    },
    core: core,
    LSViewer: LSViewer,
    Tag: TagManager,
    OnWindowResizer: OnWindowResizer,
    utils: utils,
    Tag: TagManager,
    Audio: AudioModule,
  }
  /**
   * initializes modules asked by 'params'
   * @param  {Object} MusicCSLJSON Json object representing a lead sheet
   * @param  {Object} params       parameters that determine which modules to load and their options
   * @return {Object}              contains objects from loaded modules
   */
  LJS.init = function (MusicCSLJSON, params) {
    if (MusicCSLJSON === undefined) {
      throw 'missing MusicCLJSON song'
    }

    var songModel = SongModel_CSLJson.importFromMusicCSLJSON(MusicCSLJSON)
    var useViewer = params.viewer !== undefined
    var usePlayer = params.player !== undefined
    var useEdition = params.edition !== undefined
    var modules = { songModel: songModel }

    // Viewer

    if (useViewer) {
      if (params.viewer.HTMLElement === undefined) {
        throw 'Missing HTMLElement for viewer'
      }
      viewer = loadViewer(params.viewer.HTMLElement, params.viewer.viewOptions, songModel)
    }

    // Player
    if (usePlayer) {
      if (params.player.HTMLElement === undefined) {
        throw 'Missing HTMLElement for player'
      }

      var players = loadPlayer(params.player, songModel)

      modules.audioPlayer = players.audioPlayer
      modules.midiPlayer = players.midiPlayer
    }

    if (useEdition) {
      var menuHTML = params.edition.menu !== undefined ? params.edition.menu.HTMLElement : false
      var editionModule = loadEdition(viewer, songModel, menuHTML, params.edition)

      //menu
      if (editionModule.menuController) {
        editionModule.menuController.loadStateTab()
        if (editionModule.menuModel.getCurrentMenu() === undefined) {
          editionModule.menuController.activeMenu('Notes')
        }
      }
      //history
      if (params.edition.history) {
        if (!params.edition.history.HTMLElement) {
          throw 'Missing HTMLElement for history'
        }
        var historyHTML = params.edition.history.HTMLElement
        new HistoryC(songModel, historyHTML, null, true, false)
        $.publish('ToHistory-add', 'Open song - ' + songModel.getTitle())
      }
      var fileEdition = new FileEdition(songModel, viewer, params.edition.saveFunction, {
        saveButton: params.edition.saveButton,
        saveAsButton: params.edition.saveAsButton,
        import: params.edition.import,
      })

      // if (editionModule.menuModel) {
      //   editionModule.menuModel.addMenu({
      //     title: 'File',
      //     view: fileEdition.view,
      //     order: 1,
      //   })
      //   editionModule.menuController.loadStateTab()
      //   editionModule.menuController.activeMenu('File')
      // }

      modules.edition = editionModule.edition
      modules.menuModel = editionModule.menuModel
      modules.menuController = editionModule.menuController
    }

    //tags
    if (params.tags) {
      // TagManager take as argument your array of tags here call analysis, an array of color (here undefined because we use built in colors)
      new TagManager(
        songModel,
        { notes: snglNotesManager.getInstance(songModel, viewer) },
        params.tags,
        undefined,
        true,
        false
      )
    }

    if (useViewer) {
      viewer.draw(songModel)
      modules.viewer = viewer
    }
    if (usePlayer || useEdition || params.tags) {
      modules.notesCursor = snglNotesCursor.getInstance(songModel)
      modules.noteSpaceManager = snglNotesManager.getInstance(songModel, viewer)
    }
    return modules
  }

  /*LJS._loadChordSequence = function() {
		var optionChediak = {
			displayTitle: true,
			displayComposer: true,
			displaySection: true,
			displayBar: true,
			delimiterBar: "",
			delimiterBeat: "/",
			unfoldSong: false, //TODO unfoldSong is not working yet
			fillEmptyBar: false,
			fillEmptyBarCharacter: "%",
		};
		new chordSequence($('#chordSequence1')[0], songModel, optionChediak);
	};*/

  return LJS
})
